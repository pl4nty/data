"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
const PortalFxResources = require("../PortalFxResources");
const ActionsMenu_1 = require("../TopBar/ActionsMenu");
const String = require("../Utils/String");
const Notification_1 = require("./Notification");
const Logger_1 = require("../Logger");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const BrowserAutomation_1 = require("../BrowserAutomation");
/**
 * Represents the Portal Notifications menu.
 */
class NotificationsMenu extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        /**
         * The list of displayed notifications.
         */
        this.notifications = this.all(Notification_1.default);
        this.rootClassName = "fxs-topbar-notifications";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.rootClassName);
    }
    /**
     * Invokes the click function on notifications button.
     *
     * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
     * @returns A promise that resolves when the invoked function resolves.
     */
    async click(retryOptions) {
        const isDisplayed = await this.isDisplayed();
        if (isDisplayed) {
            return super.click(retryOptions);
        }
        else {
            const actionsMenu = ElementArrayFinder_1.default.element(ActionsMenu_1.ActionsMenu);
            return actionsMenu.getActionsMenuItem(PortalFxResources.notifications).then((item) => {
                return item.click(retryOptions);
            });
        }
    }
    /**
     * Checks if any notifications are open and if so, clicks the notification button to try to close them.
     */
    async closeNotificationIfOpen() {
        const count = await this.notifications.count();
        if (count > 0) {
            return this.click();
        }
        return;
    }
    /**
     * Waits for a new notification to show up given the specified parameters. An error is thrown if the notification
     * does not show up after the timeout is reached.
     *
     * @param {string} title The notification title.
     * @param {string} description The notification description.
     * @param {number} timeout The time to wait, in milliseconds, for the notification to show up.
     * @returns The found Notification.
     */
    async waitForNewNotification(title, description, timeout) {
        if (!title && !description) {
            throw new Error("Either title or description must be specified.");
        }
        if (title && description) {
            Logger_1.default.information(String.format("Waiting for notification with title '{0}' and description '{1}'...", title, description));
        }
        else if (title) {
            Logger_1.default.information(String.format("Waiting for notification with title '{0}'...", title));
        }
        else if (description) {
            Logger_1.default.information(String.format("Waiting for notification with description '{0}'...", description));
        }
        return await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.notifications.count().then(async (count) => {
                if (count > 0) {
                    const matchingNotifications = await this.notifications.filter(async (notification) => {
                        if (title && description) {
                            const values = await Promise.all([
                                this.tryGetText(notification.title),
                                this.tryGetText(notification.progressTitle),
                                this.tryGetText(notification.description),
                            ]);
                            if (values[0]) {
                                return values[0] === title && values[2] && values[2].includes(description);
                            }
                            else if (values[1]) {
                                return values[1] === title && values[2] && values[2].includes(description);
                            }
                            return false;
                        }
                        else if (title) {
                            const values = await Promise.all([
                                this.tryGetText(notification.title),
                                this.tryGetText(notification.progressTitle),
                            ]);
                            if (values[0]) {
                                return values[0] === title;
                            }
                            else if (values[1]) {
                                return values[1] === title;
                            }
                            return false;
                        }
                        else if (description) {
                            const text = await this.tryGetText(notification.description);
                            if (text) {
                                return text.includes(description);
                            }
                            return false;
                        }
                    });
                    if (matchingNotifications.length > 0) {
                        if (matchingNotifications.length > 1) {
                            Logger_1.default.information("More than 1 matching notification found, returning the first one");
                        }
                        return matchingNotifications[0];
                    }
                    else {
                        return null;
                    }
                }
                else {
                    Logger_1.default.information("Found no notifications in the notifications menu...");
                    return null;
                }
            }, (error) => {
                if (error.name && error.name === "StaleElementReferenceError") {
                    Logger_1.default.warning("StaleElementReferenceError caught at NotificationsMenu.waitForNewNotification.");
                    return undefined;
                }
                throw error;
            });
        }, timeout, String.format("Timed out waiting for new notification to appear.  Title: '{0}', description: '{1}'. ", title || "(null)", description || "(null)"));
    }
    async tryGetText(element) {
        const isPresent = await element.isPresent();
        if (!isPresent) {
            return null;
        }
        try {
            return await element.getText();
        }
        catch (e) {
            Logger_1.default.warning(`Error caught at NotificationsMenu.tryGetText: ${e}`);
            return null;
        }
    }
}
exports.default = NotificationsMenu;
//# sourceMappingURL=NotificationsMenu.js.map