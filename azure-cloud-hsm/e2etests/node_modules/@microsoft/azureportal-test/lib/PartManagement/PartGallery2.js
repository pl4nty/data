"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const PortalFxResources = require("../PortalFxResources");
const BrowserAutomation_1 = require("../BrowserAutomation");
const ContextPane_1 = require("../ContextPane/ContextPane");
const GroupDropDownField_1 = require("../Controls/GroupDropDownField");
const TextField_1 = require("../Controls/TextField");
const By_1 = require("../Locators/By");
const PartGalleryItem2_1 = require("./PartGalleryItem2");
/**
 * Represents a Part Gallery.
 */
class PartGallery2 extends ContextPane_1.default {
    constructor() {
        super(...arguments);
        this.loadingClassName = "fxs-partgallery2-loading";
        this.categoriesClassName = "fxs-partgallery2-categories";
        this.resourcesContainerClassName = "fxs-partgallery2-resourcetypes";
        /**
         * Gets the "Add" button.
         */
        this.addButton = this.element(By_1.default.className("fxs-tilegallery-addBtn"));
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("fxs-partgallery2");
    }
    /**
     * Gets a value indicating whether this instance is loading.
     *
     * @returns A promise that resolves to the boolean that determines whether part gallery is Loading
     */
    async isLoading() {
        const items = await this.all(By_1.default.className(this.loadingClassName)).asPortalElements();
        for (const item of items) {
            if (await item.isDisplayed()) {
                return true;
            }
        }
    }
    /**
     * Gets the items.
     *
     * @returns A promise that resolves to return all the gallery items.
     */
    async getItems() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await this.isLoading()), null, "part gallery never finished loading");
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => this.all(PartGalleryItem2_1.default), null, "part gallery never finished loading");
    }
    /**
     * Finds the single item by title.
     *
     * @param {string} title The title.
     * @returns A promise that resolves to return the gallery item matching the title.
     */
    async findSingleItemByTitle(title) {
        const findItems = await this.getItems();
        const itemsFound = [];
        for (const item of findItems) {
            if ((await item.getTitle()).toLowerCase() === title.toLowerCase()) {
                itemsFound.push(item);
            }
        }
        if (itemsFound.length === 1) {
            return itemsFound[0];
        }
        else if (itemsFound.length > 1) {
            throw Error("More than one items found.");
        }
        else {
            return null;
        }
    }
    /**
     * Awaits items in part gallery getting populated and the amount is not less than the param count.
     *
     * @param count expected amount of the part gallery items.
     */
    async awaitItemsGreaterThenCount(count) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await this.getItems()).length >= count, null, async () => {
            try {
                return `Could not find no less than ${count} part gallery items, but ${(await this.getItems()).length} part gallery items instead.`;
            }
            catch {
                return `Could not find no less than ${count} part gallery items, and encountered an additional exception when trying to get additional diagnostic data`;
            }
        });
    }
    /**
     * Performs a search by the searchString in the PartGallery.
     *
     * @param searchString The string to search.
     */
    async searchItems(searchString) {
        const searchBoxes = this.all(TextField_1.default).filter((tf) => {
            const promise = checkPlaceholderValue(tf);
            return promise;
        });
        async function checkPlaceholderValue(textField) {
            const placeHolderValue = await textField.placeholderValue();
            return placeHolderValue.includes(PortalFxResources.dashboard.partGallery.searchTiles);
        }
        if ((await searchBoxes.count()) < 1) {
            throw new Error("Could not find the search box in the PartGallery.");
        }
        const searchBox = (await searchBoxes.asPortalElements())[0];
        await searchBox.setText(searchString);
        await (0, PortalElement_1.delay)();
    }
    /**
     * Gets the categories drop down.
     */
    async getCategoriesDropDown() {
        return await this.getDropdown(this.categoriesClassName, "Could not find the categories groupdropdown");
    }
    /**
     * Gets the resources drop down.
     */
    async getResourcesDropDown() {
        return await this.getDropdown(this.resourcesContainerClassName, "Could not find the resource type groupdropdown");
    }
    /**
     * Gets the drop down.
     */
    async getDropdown(cssClassName, msgOnError) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const dropDowns = await this.all(GroupDropDownField_1.default).asPortalElements();
            for (const dropDownToCheck of dropDowns) {
                if (await dropDownToCheck.hasClass(cssClassName)) {
                    return dropDownToCheck;
                }
            }
            return null;
        }, null, msgOnError);
    }
}
exports.default = PartGallery2;
//# sourceMappingURL=PartGallery2.js.map