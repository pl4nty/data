"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const By_1 = require("../Locators/By");
const BrowserAutomation_1 = require("../BrowserAutomation");
/**
 * Represents a Form Section.
 */
class FormSection extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.formElementClassName = "msportalfx-form-formelement";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".msportalfx-form-section, .fxc-section");
    }
    /**
     * Returns a value that indicates whether the form section has been changed.
     *
     * @returns A promise that resolves with a value that indicates whether the form section has been changed.
     */
    async isChanged() {
        return ((await this.hasAttributeValue("class", "msportalfx-form-sectionChanged")) ||
            (await this.hasAttributeValue("class", "fxc-section-dirty")));
    }
    /**
     * Returns a value that indicates whether the form section is valid.
     *
     * @returns A promise that resolves with a value that indicates whether the form section is valid.
     */
    async isValid() {
        return (!(await this.hasAttributeValue("class", "msportalfx-form-sectionInvalid")) &&
            !(await this.hasAttributeValue("class", "fxc-section-invalid")));
    }
    /**
     * Finds the specified form field.
     *
     * @param fieldType The type of form field to find.
     * @param fieldLabel The label text of the field to find.
     * @returns The found form field.
     */
    async findFieldByLabel(fieldType, fieldLabel) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const filteredFormElements = this.all(fieldType).filter((element) => {
                return formElementHasLabel(element, fieldLabel);
            });
            if ((await filteredFormElements.count()) > 0) {
                return (await filteredFormElements.asPortalElements())[0];
            }
            if ((await filteredFormElements.count()) === 0) {
                return false;
            }
            async function formElementHasLabel(element, fieldLabel) {
                return (await element.label.getText()).toLowerCase() === fieldLabel.toLowerCase();
            }
        }, null, `Form field with label ${fieldLabel} not found`);
    }
    /**
     * Gets all the field elements within a form section
     */
    async getAllFields() {
        return await this.all(By_1.default.className(this.formElementClassName));
    }
}
exports.default = FormSection;
//# sourceMappingURL=FormSection.js.map