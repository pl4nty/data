"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGrid = exports.View = exports.BaseRow = exports.BaseCell = exports.BaseColumnHeader = exports.SortDirection = void 0;
const String = require("../Utils/String");
const By_1 = require("../Locators/By");
const GridCommon = require("./GridCommonBase");
const Logger_1 = require("../Logger");
const Array_1 = require("../Utils/Array");
/**
 * Represents a Grid column sort direction.
 */
exports.SortDirection = GridCommon.SortDirection;
/**
 * Represents a Grid column header.
 */
class BaseColumnHeader extends GridCommon.BaseColumnHeader {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".azc-grid-column-header, .fxc-grid-column-header, .fxc-gc-columnheader");
    }
}
exports.BaseColumnHeader = BaseColumnHeader;
/**
 * Represents a Grid cell.
 */
class BaseCell extends GridCommon.BaseCell {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".azc-grid-cell, .fxc-grid-cell, .fxc-gc-cell");
    }
    /**
     * Invokes the click function of the cell which clicks the cell content.
     *
     * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
     * @returns A promise that resolves when the invoked function resolves.
     */
    async click(retryOptions) {
        const contentElement = await this.cellContent();
        if (contentElement) {
            // Click the content
            return await contentElement.click(retryOptions);
        }
        // Check if there is a Grid2 link
        const linkCellElement = this.element(By_1.default.css(".fxc-gcflink"));
        const isLinkCellPresent = await linkCellElement.isPresent();
        if (!isLinkCellPresent) {
            // Click the cell
            return await super.click(retryOptions);
        }
        const linkElement = this.element(By_1.default.css(".fxc-gcflink-link"));
        const linkCellWidth = (await linkCellElement.getSize())?.width ?? 0;
        const linkWidth = (await linkElement.getSize())?.width ?? 0;
        const elementToClick = linkCellWidth > linkWidth ? linkElement : linkCellElement;
        // Click the link
        return await elementToClick.click(retryOptions);
    }
    async cellContent() {
        const hasClass = await this.hasClass("fxc-gc-cell");
        // Grid2 does not have content element
        if (hasClass) {
            return null;
        }
        return this.element(By_1.default.css(".azc-grid-cellContent, .fxc-grid-cellContent"));
    }
}
exports.BaseCell = BaseCell;
/**
 * Represents a Grid row.
 */
class BaseRow extends GridCommon.BaseRow {
    /**
     * Constructs a base grid row.
     *
     * @param createCell Cell constructor.
     * @param elementArrayFinder Element array finder.
     */
    constructor(createCell, elementArrayFinder) {
        super(createCell, elementArrayFinder);
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".azc-grid-row, .fxc-grid-row, .fxc-gc-row");
    }
    /**
     * Invokes the click function of the row which clicks the first visible cell.
     *
     * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
     * @returns A promise that resolves when the invoked function resolves.
     */
    async click(retryOptions) {
        const displayedCells = await (0, Array_1.filterAsync)(await this.cells, async (cell) => {
            const size = await cell.getSize();
            // Filtering out cells that are not displayed and empty cells
            return ((await cell.isDisplayed()) && size !== null && Math.round(size.height) > 1 && Math.round(size.width) > 1);
        });
        if (displayedCells.length > 0) {
            return await displayedCells[0].click(retryOptions);
        }
        return await super.click(retryOptions);
    }
    /**
     * Invokes the click function of the row which clicks the specified cell.
     *
     * @param cellIndex The index of the cell to click.
     * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
     * @returns A promise that resolves when the invoked function resolves.
     */
    async clickCell(cellIndex, retryOptions) {
        return await this.cells.get(cellIndex).click(retryOptions);
    }
    /**
     * Determines if the row has been activated.
     *
     * @returns A promise that resolves when the activation state is found.
     */
    async isActivated() {
        const activatedGrid1 = await this.hasAttributeValue("data-grid-row-activated", "true");
        return (activatedGrid1 ||
            this.hasAttributeValue("data-grid-activated", "true").then((activatedGridB) => {
                return activatedGridB || this.hasClass("fxc-gc-activated");
            }));
    }
    /**
     * Determines if the row has been selected.
     *
     * @returns A promise that resolves when the selected state is found.
     */
    async isSelected() {
        return (await this.getAttribute("aria-selected")) === "true";
    }
    /**
     * Gets a value indicating if this grid row is disabled.
     *
     * @returns A promise that resolves when the selected state is found.
     */
    async isDisabled() {
        const attribute = await this.getAttribute("aria-disabled");
        return !String.isNullOrEmptyOrUndefined(attribute) && attribute.toLowerCase() === "true";
    }
}
exports.BaseRow = BaseRow;
/**
 * Class to represent a Grid view port.
 */
class View extends GridCommon.BaseView {
    /**
     * Gets the locator associated to this element.
     */
    get locator() {
        return By_1.default.css(".azc-grid-tableScrollContainer,.fxc-grid-tableScrollContainer,.fxc-gc-tbody,.fxc-grid-tbody");
    }
}
exports.View = View;
/**
 * Generic Grid test harness that that works against Grid1 and Grid2 grids.
 */
class BaseGrid extends GridCommon.BaseGrid {
    /**
     * Constructs a base grid.
     *
     * @param createRow Constructs a Row.
     * @param createCell Constructs a Cell.
     * @param createColumnHeader Constructs a ColumnHeader.
     * @param elementArrayFinder Element array finder.
     */
    constructor(createRow, createCell, createColumnHeader, elementArrayFinder) {
        super(createRow, createCell, createColumnHeader, View, elementArrayFinder);
        /**
         * The text box used to filter grid results.  If you want to set the text value, you can use searchBoxInput instead.
         * Does not apply to Grid2 (DataGrid/EditableGrid).
         */
        this.searchBox = this.element(By_1.default.css(".azc-grid-filterable-searchBox, .fxc-grid-search-searchBox"));
        /**
         * The input text box used to filter grid results.  Use this if you want to set the text value without having to find the input element manually.
         * Does not apply to Grid2 (DataGrid/EditableGrid).
         */
        this.searchBoxInput = this.element(By_1.default.css(".azc-grid-filterable-searchBox, .fxc-grid-search-searchBox")).element(By_1.default.tagName("input"));
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".fxc-grid2, .azc-grid, .fxc-gc");
    }
    /**
     * Filters the grid rows using the specified text.
     * Does not apply to Grid2 (DataGrid/EditableGrid).
     *
     * @param {string} text The filter.
     * @returns A promise that resolves with this grid instance when filtered rows are available.
     */
    async filter(text) {
        Logger_1.default.information(String.format("Applying filter '{0}'...", text));
        await this.searchBoxInput.sendKeys(text);
        return this;
    }
    /**
     * If multi-select is enabled, the row that contains the specified text will be selected.
     *
     * @param options The set of options used to find the row.
     * @param {string} options.text The text that the row should contain.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @param {boolean} useControlClick If true, holds down the control key while clicking. If false, performs a regular click.
     * @returns A promise that resolves when the row has been selected.
     */
    async selectRow(options, useControlClick) {
        const row = await this.findRow(options);
        if (useControlClick) {
            await this.clickWithCtrlKey();
        }
        else {
            return await row
                .element(By_1.default.css(".azc-grid-selectableRow-selectionCell-wrapper, .fxs-grid-selection-cell, .fxc-gc-selectioncheckbox"))
                .click();
        }
    }
    /**
     * Checks if the row with specified text exists in the Grid.
     *
     * @param {string} rowText The text that the row should contain.
     * @param {number} cellIndex The cell index that contains the specified text.
     * @returns True, if the row with specified text is present; false, otherwise.
     */
    async isRowPresent(rowText, cellIndex) {
        let isRowPresent = false;
        await this.rows.each(async (row) => {
            if ((await row.cells.get(cellIndex).getText()) === rowText) {
                isRowPresent = true;
            }
        });
        return isRowPresent;
    }
}
exports.BaseGrid = BaseGrid;
//# sourceMappingURL=GridBase.js.map