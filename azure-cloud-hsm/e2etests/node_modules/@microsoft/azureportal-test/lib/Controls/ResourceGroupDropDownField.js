"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FormElement_1 = require("../Controls/FormElement");
const GroupDropDownField_1 = require("../Controls/GroupDropDownField");
const TextField_1 = require("../Controls/TextField");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
const BrowserAutomation_1 = require("../BrowserAutomation");
const PortalFxResources = require("../PortalFxResources");
const PortalConfigurationManager_1 = require("../PortalConfigurationManager");
const RootClassName = "fxc-resource-dropdown";
const ResourceGroupDropDownClassName = "fxt-resourcegroup-dropdown";
const DialogClassName = "azc-balloon-dialog";
/**
 * Represents a CreatorAndSelector field.
 */
class ResourceGroupDropDown extends FormElement_1.default {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.xpath(`//*[contains(concat(' ', @class, ' '), ' ${RootClassName} ') and contains(concat(' ', @class, ' '), ' ${ResourceGroupDropDownClassName} ')][1]`);
    }
    /**
     * Get the selected resource group.
     * In the old style of the control with Radio buttons, this will switch the mode to UseExisting and return the value of the dropdown.
     * In the new style of the control, this will return the value of the textbox if allowedMode is createNew, otherwise the value of the dropdown.
     *
     * @returns A promise that resolves when the resource group has been retrieved.
     */
    async getSelectedResourceGroup() {
        const input = this.element(By_1.default.className("azc-input"));
        return await input.getText();
    }
    /**
     * Set the selected resource group in the dropdown.
     * This will switch the mode of the control if using the old style control with radio buttons.
     *
     * @param {string} value the value of the text to input in the dropdown control.
     * @returns A promise that resolves when the resource group has been selected.
     */
    async setSelectedResourceGroup(value) {
        const dropdown = await this._dropDown();
        return await dropdown.selectOptionsByText([value]);
    }
    /**
     * Get the created resource group from the textbox or dropdown.
     * This will switch the mode of the control if using the old style control with radio buttons.
     */
    async getNewResourceGroup() {
        const isCreateOnly = await this._isCreateOnlyMode();
        if (isCreateOnly) {
            const textField = await this._textBox();
            return await textField.getAttribute("value");
        }
        const dropDown = await this._dropDown();
        const options = await dropDown.getOptions();
        return options[0].value;
    }
    /**
     * Creates a new resource group using the resource group control.
     * This will switch the mode of the control if using the old style control with radio buttons.
     * In the old dropdown, this will switch the mode to Create New and enter the value in the textbox.
     * In the new dropdown, this will either enter the value in the textbox (mode = createNew)
     * or use the dialog to create a new dropdown option.
     *
     * @param resourceGroupName The name of the resource group to create.
     * @returns A promise that resolves when the new resource group has been selected.
     */
    async setNewResourceGroup(resourceGroupName) {
        const createOnly = await this._isCreateOnlyMode();
        if (createOnly) {
            // Only create mode is allowed, can type directly in the text box.
            const textField = await this._textBox();
            await textField.clear();
            return await textField.sendKeys(resourceGroupName);
        }
        // Create the resource group in the popup dialog.
        return await this._createResourceGroupInDialog(resourceGroupName);
    }
    async _createResourceGroupInDialog(value) {
        let retries = 1;
        while (retries-- > 0 && (await (await this._dropDown()).getValue()) !== value) {
            await this._clickCreateNewButton();
            const dialog = ElementArrayFinder_1.default.element(this._dialog);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await dialog.isDisplayed());
            const textbox = dialog.element(TextField_1.default);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await textbox.isDisplayed());
            await textbox.clear();
            await textbox.sendKeys(value);
            // Selenium clicks too fast for the value to be sent across the iframe. Wait for that.
            await (0, PortalElement_1.delay)(500);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const okButton = dialog.element(By_1.default.xpath(`${By_1.default.currentNodeXPathPrefix()}*[(@role = 'button')][not(@aria-disabled='true')][descendant::text()='${PortalFxResources.ok}']`));
                if (await okButton.isPresent()) {
                    await okButton.click();
                    return true;
                }
            }, PortalConfigurationManager_1.default.portalContext.timeouts.timeout, "Timeout waiting for OK button to be clicked.");
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return !(await dialog.isDisplayed());
            }, PortalConfigurationManager_1.default.portalContext.timeouts.timeout, "Timeout waiting for dialog to be closed.");
        }
    }
    get _dialog() {
        return By_1.default.className(DialogClassName);
    }
    get _createNewButton() {
        return this.element(By_1.default.xpath(`${By_1.default.currentNodeXPathPrefix()}*[(@role = 'button') and text()='${PortalFxResources.createNew}']`));
    }
    async _clickCreateNewButton() {
        return await this._createNewButton.click();
    }
    async _isCreateOnlyMode() {
        // If the dropdown is present in the DOM, isCreateOnlyMode is true.
        // Will throw if element does not exist. Textbox control is used for the filter on the DropDown control.
        return !(await this.hasClass(GroupDropDownField_1.default.rootClassName));
    }
    async _textBox() {
        const input = this.element(By_1.default.tagName("input"));
        return (0, BrowserAutomation_1.getBrowser)()
            .wait(async () => await input.isDisplayed())
            .then(() => input);
    }
    async _dropDown() {
        const isCreateModeOnly = await this._isCreateOnlyMode();
        if (!isCreateModeOnly) {
            return PortalElement_1.default.fromWebElement(this.webElement, this.locator, GroupDropDownField_1.default);
        }
    }
}
exports.default = ResourceGroupDropDown;
//# sourceMappingURL=ResourceGroupDropDownField.js.map