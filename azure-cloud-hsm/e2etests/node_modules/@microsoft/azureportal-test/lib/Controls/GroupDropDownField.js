"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FormElement_1 = require("../Controls/FormElement");
const GroupDropDownFieldOption_1 = require("../Controls/GroupDropDownFieldOption");
const By_1 = require("../Locators/By");
const portalFxResources = require("../PortalFxResources");
const ExpectedConditions = require("../ExpectedConditions");
const Logger_1 = require("../Logger");
const BrowserAutomation_1 = require("../BrowserAutomation");
const TextField_1 = require("./TextField");
const diagnosticsLog = Logger_1.default.diagnostics.extend("GroupDropDownField");
/**
 * Represents a Group DropDown field.
 */
class GroupDropDownField extends FormElement_1.default {
    constructor() {
        super(...arguments);
        this.dropDownArrowClass = "fxc-group-dropdown-arrow";
        this.dropDownPopupClass = "fxc-dropdown-popup";
        this.dropDownHiddenClass = "fxc-dropdown-hidden";
        this.dropDownSelectAllOptionClass = "fxc-dropdown-selectall";
        this.dropDownSearchTextFieldClass = "azc-textField";
        this.selectAllOptionAllOptionsSelectedClass = "fxs-portal-selected";
        this.dropDownValueSelector = "azc-input";
    }
    /**
     * The collection of options that belong to this dropdown field.
     *
     * @returns The options.
     */
    get options() {
        return this.all(GroupDropDownFieldOption_1.default);
    }
    /**
     * Gets the value of the control via reading out of / writing to the input.
     *
     * @returns Promise which resolves to the value.
     */
    async getValue() {
        const valueElement = this.element(By_1.default.className(this.dropDownValueSelector));
        return (await valueElement.getAttribute("value")) ?? (await valueElement.getText());
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(GroupDropDownField.rootClassName);
    }
    async getOptions() {
        const treeElement = this.element(By_1.default.css("div[role=tree]"));
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await treeElement.isPresent());
        const script = (arg) => `
                var returnArray = [];
                var recurseThroughItems = (item) => {
                    if (item.children) {
                        item.children.forEach(child => {
                            recurseThroughItems(child);
                        });
                    } else {
                        returnArray.push(item);
                    }
                };
                var rootItems = ko.dataFor(${arg}).data.items();
                rootItems.forEach(item => recurseThroughItems(item));
                return returnArray.map(function(item) {
                    var text = null;
                    var htmlText = null;
                    var htmlTemplate = null;
                    var unwrappedText = ko.unwrap(item.text);
                    if (unwrappedText && typeof unwrappedText === 'string') {
                        text = unwrappedText;
                        htmlText = text;
                    } else if (unwrappedText && unwrappedText.htmlTemplate) {
                        htmlTemplate = unwrappedText.htmlTemplate;
                        htmlText = htmlTemplate;
                    }
                    return { text: text, htmlText: htmlText, htmlTemplate: htmlTemplate, value: ko.unwrap(item.value), ariaLabel: ko.unwrap(item.ariaLabel), disabled: ko.unwrap(item.disabled), selectedItemOverride: ko.unwrap(item.selectedItemOverride)}
                });`;
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`${script("arguments[0]")}`, treeElement), async () => await (await treeElement.getWebElements())[0].executeScript(`(htmlElem) => { ${script("htmlElem")} }`));
    }
    /**
     * Selects the first option that matches the given optionText.
     *
     * @param optionText The text of the option to select.
     * @param partial Should the option be selected with a partial match
     * @param timeout The time, in milliseconds, to wait for the dropdown to be enabled, have items and select the item (note each action is given this timeout independently so cumulative time may be longer).
     * @returns A promise that resolves when the option has been selected.
     */
    async selectOptionByText(optionText, partial = false, timeout) {
        await this.waitUntilEnabled(timeout);
        diagnosticsLog(`Opening dropdown via execute script...`);
        // In case the dropdown was off the bottom, setting `isPopUpOpen` will scrolled to the dropdown. Wait for that and then open again.
        const script = (arg) => `
                ko.dataFor(${arg}).data.isPopUpOpen(true);
                setTimeout(()=>{
                    ko.dataFor(${arg}).data.isPopUpOpen(true);
                },50);`;
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`${script("$(arguments[0]).find('.fxc-dropdown-popup')[0]")}`, this), async () => await ((await this.element(By_1.default.className(this.dropDownPopupClass)).getWebElements())[0]).executeScript(`(htmlElem) => { ${script("htmlElem")} }`));
        diagnosticsLog(`Waiting for dropdown to have items...`);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const count = await this.options.count();
            return count > 0;
        }, timeout, `Dropdown did not populate with any items within the allotted timeout ${timeout}`);
        let index = -1;
        diagnosticsLog(`Searching for '${optionText}' with partial match '${partial}'...`);
        const ddOptions = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const ddOptions = await this.options.filter(async (ddoption, optionIndex) => {
                try {
                    const text = await ddoption.getText();
                    diagnosticsLog(`Comparing dropdown text '${text}' with search text '${optionText}' with partial match '${partial}'.`);
                    if (partial ? text.includes(optionText) : text === optionText) {
                        diagnosticsLog(`Matched dropdown text '${text}' with search text '${optionText}' with partial match '${partial}'.`);
                        index === -1 && (index = optionIndex);
                        return true;
                    }
                    return false;
                }
                catch (_err) {
                    return false;
                }
            });
            // Check if we found the value
            if (ddOptions && ddOptions.length > 0) {
                diagnosticsLog(`Found dropdown text '${optionText}' with partial match '${partial}'.`);
                return ddOptions;
            }
            else {
                // Didn't find a value, possibly because we got errors (eg stale reference).  Return false so the portal.Wait does a retry
                Logger_1.default.warning(`Unable to find text that matches '${optionText}'.  Retrying...`);
                return false;
            }
        }, timeout);
        if (ddOptions && ddOptions.length > 0) {
            diagnosticsLog(`Selecting dropdown option '${optionText}' at index ${index}`);
            await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("$($(arguments[0]).find('.fxc-dropdown-option')[" + index + "]).trigger('mouseup')", this), async () => {
                await ddOptions[0].scrollIntoView();
                await ddOptions[0].click();
            });
        }
        else {
            throw `Unable to find dropdown text matching '${optionText}'.  Please double check the spelling and casing.`;
        }
    }
    /**
     * Gets the selected items
     *
     * @returns An array contains the values (not text) of the selected items.
     */
    async getSelectedValues() {
        const treeElement = this.element(By_1.default.css("div[role=tree]"));
        const result = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return ko.dataFor(arguments[0]).data.value()`, treeElement), async () => await (await treeElement.getWebElements())[0].executeScript(`(htmlElem) => ko.dataFor(htmlElem).data.value()`));
        if (Array.isArray(result)) {
            return result;
        }
        else {
            return [result];
        }
    }
    /**
     * Gets the selected item names.
     *
     * @returns a collection of strings representing the texts of the selected items. If in single select mode, returns a collection with a single text.
     */
    async getSelectedNames() {
        const values = await this.getSelectedValues();
        const options = await this.getOptions();
        const selectedNames = [];
        for (const val of values) {
            // getSelectedValues can return either an array of strings or an array of objects (not sure why)
            if (typeof val === "string") {
                const option = options.find((op) => op.value === val);
                if (option) {
                    selectedNames.push(option.htmlText);
                }
            }
            else {
                selectedNames.push(val.displayName);
            }
        }
        return selectedNames;
    }
    /**
     * Selects the specified options for this dropdown field.
     *
     * @param optionsToBeSelected List of texts of the options to be selected
     * @param leaveOpen whether to leave drop down open after selecting
     * @param partial Should the option be selected with a partial match
     * @param timeout The time, in milliseconds, to wait for the dropdown to be enabled, and select the item (note each action is given this timeout independently so cumulative time may be longer).
     * @param clearFilter Should the filter be cleared after selection
     * @returns A promise that resolves when the options have been selected.
     */
    async selectOptionsByText(optionsToBeSelected, leaveOpen, partial, timeout, clearFilter) {
        await this.openDropDown(timeout);
        const selectAllOption = this.element(By_1.default.className(this.dropDownSelectAllOptionClass));
        if (optionsToBeSelected.includes(portalFxResources.selectAll)) {
            if (!(await selectAllOption.hasAttributeValue("aria-selected", "true"))) {
                await this.selectOptionByText(portalFxResources.selectAll);
            }
            await this.closeDropDown();
            return;
        }
        if (await this.hasSelectAllOption()) {
            await this.unselectAllOptions();
        }
        const hasFilter = await this.hasDropDownSearchTextField();
        const totalItemCount = await this.options.count();
        for (const itemName of optionsToBeSelected) {
            let dropDownSearchTextField;
            if (hasFilter) {
                dropDownSearchTextField = await this.getDropDownSearchTextField();
                await dropDownSearchTextField.clear();
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    const visibleItemsCount = await this.getVisibleItemsCount();
                    return visibleItemsCount === totalItemCount;
                });
                await dropDownSearchTextField.sendKeys(itemName);
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    const visibleItemsCount = await this.getVisibleItemsCount();
                    return visibleItemsCount !== totalItemCount;
                });
            }
            console.log(`Selecting ${itemName}`);
            await this.selectOptionByText(itemName, partial, timeout);
            if (hasFilter && clearFilter) {
                await dropDownSearchTextField.clear();
            }
        }
        if (!leaveOpen) {
            await this.closeDropDown();
        }
    }
    /**
     * Toggle "Select All" checkbox in the DropDown.
     */
    async toggleSelectAll() {
        await this.openDropDown();
        await this.selectOptionByText(portalFxResources.selectAll);
        await this.closeDropDown();
    }
    /**
     * Selects the specified options for this dropdown field.
     *
     * @param {string[]} optionsToBeSelected List of texts of the options to be selected
     * @returns A promise that resolves when the options have been selected.
     */
    async toggleOptionsSelectionByText(optionsToBeSelected) {
        await this.openDropDown();
        for (const itemName of optionsToBeSelected) {
            let desiredItem;
            const allDesiredItem = await this.all(By_1.default.className("fxc-dropdown-option")).asPortalElements();
            for (const item of allDesiredItem) {
                if ((await item.getText()) === itemName) {
                    desiredItem = itemName;
                }
            }
            if (desiredItem !== null) {
                await this.selectOptionByText(itemName);
            }
            else {
                throw `Failed to find the item with text ${itemName} in the dropdown.`;
            }
        }
        await this.closeDropDown();
    }
    /**
     * Selects option by provided index.
     *
     * @param {number} index option index to select
     * @returns A promise that resolves when the option has been selected.
     */
    async selectByIndex(index) {
        // Open the dropdown, then click on the item.
        await this.openDropDown();
        await this.selectItemInDropDown(index);
        await this.closeDropDown();
    }
    async selectItemInDropDown(index) {
        const optionByIndex = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const option = this.options.get(index);
            if (await option.isDisplayed()) {
                return option;
            }
            else {
                return false;
            }
        }, null, `Did not find option with index ${index}`);
        await optionByIndex.click();
    }
    /**
     * Unselects the all options in groupDropDownfield.
     */
    async unselectAllOptions() {
        const selectAllOption = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const selectAllOption = this.element(By_1.default.className(this.dropDownSelectAllOptionClass));
            if (await selectAllOption.isDisplayed()) {
                return selectAllOption;
            }
            else {
                return false;
            }
        }, null, "'Select All' option not found");
        if (await selectAllOption.hasClass(this.selectAllOptionAllOptionsSelectedClass)) {
            await this.selectOptionByText(portalFxResources.selectAll);
        }
        else {
            let areOptionsPartiallySelected;
            const allDropDownOptions = await this.options;
            for (const option of allDropDownOptions) {
                if (await option.hasAttributeValue("aria-selected", "true")) {
                    areOptionsPartiallySelected = true;
                    break;
                }
            }
            if (areOptionsPartiallySelected) {
                await this.selectOptionByText(portalFxResources.selectAll); //all options get selected
                await this.selectOptionByText(portalFxResources.selectAll); //all options become unselected
            }
            else {
                Logger_1.default.information("All options are already unselected");
            }
        }
    }
    async hasSelectAllOption() {
        return await this.isElementPresent(By_1.default.className(this.dropDownSelectAllOptionClass));
    }
    async getVisibleItemsCount() {
        const options = this.options;
        const visibleItemsCount = await options.count();
        return visibleItemsCount;
    }
    /**
     * Checks whether drop down is open or not.
     *
     * @returns Promise which resolves to the open state.
     */
    async isDropDownOpen() {
        const dropDownPopup = this.element(By_1.default.className(this.dropDownPopupClass));
        return (await dropDownPopup.isPresent()) && !(await dropDownPopup.hasClass(this.dropDownHiddenClass));
    }
    /**
     * Opens the drop down.
     *
     * @param timeout The time, in milliseconds, to wait for the dropdown to be enabled and open (note each action is given this timeout independently so cumulative time may be longer).
     */
    async openDropDown(timeout) {
        await this.waitUntilEnabled(timeout);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (!(await this.isDropDownOpen())) {
                await this.clickDropDownArrow();
            }
            return await this.isDropDownOpen();
        }, timeout, `Unable to open dropdown`);
    }
    /**
     * Closes the drop down.
     */
    async closeDropDown() {
        if (await this.isDropDownOpen()) {
            await this.clickDropDownArrow();
        }
    }
    async clickDropDownArrow() {
        const dropDownArrow = this.element(By_1.default.className(this.dropDownArrowClass));
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("$(arguments[0]).trigger('mousedown').trigger('mouseup').trigger('click');", dropDownArrow), // For some reason the dropdown arrow is not detected as visible by webdriver, so use javascript to click it.
        async () => {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await dropDownArrow.isDisplayed());
            await dropDownArrow.click();
        });
    }
    async hasDropDownSearchTextField() {
        return await this.isElementPresent(By_1.default.className(this.dropDownSearchTextFieldClass));
    }
    /**
     * Gets the search text field in dropdown.
     *
     * @returns Promise which resolves to the search text field.
     */
    async getDropDownSearchTextField() {
        const dropDownSearchField = this.element(TextField_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(ExpectedConditions.isDisplayed(dropDownSearchField));
        return dropDownSearchField.input;
    }
}
/**
 * Root class name for the dropdown
 */
GroupDropDownField.rootClassName = "fxc-group-dropdown";
exports.default = GroupDropDownField;
//# sourceMappingURL=GroupDropDownField.js.map