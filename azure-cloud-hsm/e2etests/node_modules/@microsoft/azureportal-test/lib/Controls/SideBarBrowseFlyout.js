"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const By_1 = require("../Locators/By");
const SideBarBrowseFlyoutFilterInput_1 = require("./SideBarBrowseFlyoutFilterInput");
const String = require("../Utils/String");
const BrowserAutomation_1 = require("../BrowserAutomation");
/**
 * Represents the sidebar browse flyout.
 */
class SideBarBrowseFlyout extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.rootClassName = "fxs-sidebar-browse-flyout";
        this.sideBarNoResultClass = "fxs-sidebar-flyout-noresults";
        this.sideBarItemClass = "fxs-sidebar-flyout-item-content";
        this.sideBarCardClass = "fxs-sidebar-flyout-card";
        this.sideBarLabelClass = "fxs-sidebar-label";
        this.sideBarCardLabelClass = "fxs-sidebar-flyout-card-label";
        this.sideBarHiddenClassName = "fxs-sidebar-hide";
        this.portalHiddenClassName = "fxs-display-none";
        this.sideBarCategoryClass = "fxs-sidebar-item-category";
        this.sideBarCategoryLabelClass = "fxs-sidebar-category-label";
        this.sideBarItemMatchesClass = "fxs-sidebar-matches";
        // Active category should have both classes
        this.activeCategorySelector = ".fxs-sidebar-category-name.fxs-portal-selected";
        this.allCategoryListClassName = "fxs-sidebar-flyout-allservices-list";
        this.specificCategoryListClassName = "fxs-sidebar-flyout-services-list-with-subcategories";
        this.reservedCategoriesLC = ["all", "favorites", "recents", "recommended"];
        this.detailViewToggleClassName = "fxs-sidebar-flyout-detail-view-toggle";
        this.categoryItemClass = "fxs-sidebar-category-name";
        this.toggleControlClass = "fxc-toggle";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.rootClassName);
    }
    /**
     * Toggles the detail view of the browse flyout.
     */
    async toggleDetailView() {
        const toggle = this.element(By_1.default.className(this.detailViewToggleClassName));
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await toggle.isDisplayed(), null, "Detail view toggle should be found");
        await toggle.element(By_1.default.className(this.toggleControlClass)).click();
    }
    /**
     * Switches to the specified category.
     *
     * @param categoryName The category name to switch to.
     */
    async switchCategory(categoryName) {
        const category = this.element(By_1.default.classAndText(this.categoryItemClass, categoryName));
        await category.click();
        return category;
    }
    /**
     * Gets the filter input for the browse flyout.
     */
    async getFilterInput() {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const filterInput = this.element(SideBarBrowseFlyoutFilterInput_1.default);
            if (await filterInput.isDisplayed()) {
                return filterInput;
            }
            return null;
        }, null, "Could not find sidebar browse flyout filter input.");
    }
    /**
     * Gets the browse flyout item having the specified text
     *
     * @param text Specified text to find
     * @returns A promise wrapping the browse flyout item
     */
    async getBrowseFlyoutItem(flyoutItemText) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allItems = this.all(By_1.default.className(this.sideBarItemClass));
            const filteredItems = allItems.filter(async (item) => {
                const label = item.element(By_1.default.className(this.sideBarLabelClass));
                return await this.checkLabelHasTargetText(label, flyoutItemText);
            });
            if ((await filteredItems.count()) > 0) {
                return (await filteredItems.asPortalElements())[0];
            }
            return null;
        }, null, `No item with with text ${flyoutItemText} found`);
    }
    /**
     * Gets the browse flyout card having the specified text
     *
     * @param text Specified text to find
     * @returns A promise wrapping the browse flyout item
     */
    async getBrowseFlyoutCard(cardLabel) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allItems = this.all(By_1.default.className(this.sideBarCardClass));
            const filteredItems = allItems.filter(async (item) => {
                const label = item.element(By_1.default.className(this.sideBarCardLabelClass));
                return await this.checkLabelHasTargetText(label, cardLabel);
            });
            if ((await filteredItems.count()) > 0) {
                return (await filteredItems.asPortalElements())[0];
            }
            return null;
        }, null, `No item with with text ${cardLabel} found`);
    }
    async clickAllCategoryAndGetBrowseFlyoutItem(flyoutItemText) {
        const allCategory = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allCategory = this.element(By_1.default.classAndText("fxs-sidebarflyout-category-button", "All"));
            if (await allCategory.isDisplayed()) {
                return allCategory;
            }
            return null;
        }, null, "Sidebar category 'All' not found");
        await allCategory.click();
        return await this.getBrowseFlyoutItem(flyoutItemText);
    }
    async checkLabelHasTargetText(label, targetLabelText) {
        try {
            const labelText = (await label.getText()) || "";
            return labelText.toLocaleLowerCase().startsWith(targetLabelText.toLocaleLowerCase());
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Gets the count of categories on browse flyout. This count doesn't include reserved categories such as 'All', 'Favorites', 'Recents'.
     *
     * @returns A promise wrapping the count of categories on browse flyout
     */
    async getCategoryCount() {
        return (await this.getAllCategories()).length;
    }
    /**
     * Gets the count of categories on browse flyout including reserved categories such as 'All', 'Favorites', 'Recents'.
     *
     * @returns A promise wrapping the count of categories on browse flyout
     */
    async getCategoryWithReservedCategoryCount() {
        return (await this.getAllCategoriesWithReservedCategories()).length;
    }
    /**
     * Gets the string array of categories on browse flyout including reserved categories such as 'All', 'Favorites', 'Recents'.
     */
    async getAllCategoriesWithReservedCategories() {
        const allCategories = [];
        const categories = await this.all(By_1.default.className(this.categoryItemClass));
        for (const category of categories) {
            allCategories.push(await category.getText());
        }
        return allCategories;
    }
    /**
     * Gets the string array of categories on browse flyout. This doesn't include reserved categories such as 'All', 'Favorites', 'Recents'.
     *
     * @returns A promise wrapping the string array of categories on browse flyout
     */
    async getAllCategories() {
        const allCategories = [];
        const categories = await this.all(By_1.default.className(this.sideBarCategoryClass));
        for (const category of categories) {
            if (!(await category.hasClass(this.sideBarHiddenClassName))) {
                const elements = await category.all(By_1.default.className(this.sideBarCategoryLabelClass));
                for (const element of elements) {
                    if (!(await element.hasClass(this.sideBarHiddenClassName))) {
                        allCategories.push(await element.getText());
                    }
                }
            }
        }
        return allCategories;
    }
    /**
     * Gets the service list class name based on the active category.
     */
    async getServiceListClassName() {
        const activeCategory = this.element(By_1.default.css(this.activeCategorySelector));
        const activeCategoryId = await activeCategory
            .element(By_1.default.className("fxs-sidebarflyout-category-button"))
            .getAttribute("data-category");
        return this.reservedCategoriesLC.includes(activeCategoryId.toLowerCase())
            ? this.allCategoryListClassName
            : this.specificCategoryListClassName;
    }
    /**
     * Gets all the item names in the flyout.
     *
     * @returns A array of strings for the item names.
     */
    async getAllItems() {
        const serviceListClassName = await this.getServiceListClassName();
        const container = this.element(By_1.default.className(serviceListClassName));
        const visibleItems = container.all(By_1.default.className(this.sideBarItemClass)).filter((item) => {
            const promise = this.isVisible(item);
            return promise;
        });
        return visibleItems.map((item) => {
            return item.all(By_1.default.className(this.sideBarLabelClass)).first().getText();
        });
    }
    /**
     * Gets all the detail view card names in the flyout.
     *
     * @returns A array of strings for the card names.
     */
    async getAllCards() {
        const serviceListClassName = await this.getServiceListClassName();
        const container = this.element(By_1.default.className(serviceListClassName));
        const visibleItems = container.all(By_1.default.className(this.sideBarCardClass)).filter((item) => {
            const promise = this.isVisible(item);
            return promise;
        });
        return visibleItems.map((item) => {
            return item.all(By_1.default.className(this.sideBarCardLabelClass)).first().getText();
        });
    }
    /**
     * Checks if the no result view is visible in all services flyout.
     *
     * @returns Promise that resolves to a boolean. True means no result view is visible, false means it is not visible.
     */
    async hasNoResult() {
        const visibleItems = this.all(By_1.default.className(this.sideBarNoResultClass)).filter((item) => {
            const promise = this.isVisible(item);
            return promise;
        });
        return (await visibleItems.count()) > 0;
    }
    async isVisible(item) {
        return (!(await item.hasClass(this.sideBarHiddenClassName)) && !(await item.hasClass(this.portalHiddenClassName)));
    }
    /**
     * Gets the count of items on browse flyout
     *
     * @returns A promise wrapping the count of items on browse flyout
     */
    async getItemCount() {
        return (await this.getAllItems()).length;
    }
    /**
     * Gets the count of detail view cards on browse flyout
     *
     * @returns A promise wrapping the count of cards on browse flyout
     */
    async getCardCount() {
        return (await this.getAllCards()).length;
    }
    /**
     * Gets the category portal element having the specified text
     *
     * @param categoryText Specified text to find
     * @returns A promise wrapping the category portal element having the specified text
     */
    async getCategory(categoryText) {
        return await this.tryGetCategory(categoryText);
    }
    /**
     * Tries to gets the category portal element having the specified text. Throws error if element not found.
     *
     * @param categoryText Specified text to find
     * @returns A promise wrapping the category portal element having the specified text
     */
    async tryGetCategory(categoryText) {
        const categories = await this.all(By_1.default.className(this.sideBarCategoryClass));
        for (const category of categories) {
            if (!(await category.hasClass(this.sideBarHiddenClassName))) {
                const elements = await category.all(By_1.default.className(this.sideBarCategoryLabelClass));
                for (const element of elements) {
                    if (!(await element.hasClass(this.sideBarHiddenClassName))) {
                        const categoryLabel = await element.getText();
                        if (String.startsWith(categoryLabel.toLowerCase(), categoryText.toLowerCase())) {
                            return category;
                        }
                    }
                }
            }
        }
        throw new Error(`Category '${categoryText}' not found.`);
    }
    /**
     * Gets the item matches text for the given item text.
     * Returns an empty string on error
     *
     * @param categoryText The item text to find
     * @returns The matches text for the given item.
     */
    async getItemMatchesString(itemText) {
        const item = await this.getBrowseFlyoutItem(itemText);
        const matchesElement = item.element(By_1.default.className(this.sideBarItemMatchesClass));
        try {
            return matchesElement !== null ? await matchesElement.getText() : "";
        }
        catch (e) {
            return "";
        }
    }
}
exports.default = SideBarBrowseFlyout;
//# sourceMappingURL=SideBarBrowseFlyout.js.map