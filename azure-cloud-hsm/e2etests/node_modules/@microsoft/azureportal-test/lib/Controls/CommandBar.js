"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const By_1 = require("../Locators/By");
const CommandBarItem_1 = require("../Commands/CommandBarItem");
const String = require("../Utils/String");
const CommandBarMenuButton_1 = require("./CommandBarMenuButton");
const BrowserAutomation_1 = require("../BrowserAutomation");
const MessageBox_1 = require("./Dialogs/MessageBox");
const Array_1 = require("../Utils/Array");
const Logger_1 = require("../Logger");
/**
 * Represents a command bar.
 */
class CommandBar extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.rootClassName = "fxs-commandBar";
        this.expandListClassName = "fxs-commandBar-item-expandList";
        this.dropMenuContentClassName = "fxs-dropmenu-content";
        this.dropMenuDisplayedClassName = "fxs-dropmenu-is-open";
        this.overflowClassName = "azc-toolbar-item-overflow";
        this.overflowPopupClassName = "azc-toolbarButton-overflowPopup";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.rootClassName);
    }
    /**
     * Gets the collection of command bar items, excluding the overflow button.
     * If there are overflow commands, the overflow button will be clicked and overflow commands will also be returned.
     *
     * @returns Promise returning an array of CommandBarItem.
     */
    async getItems() {
        const list = await this.all(CommandBarItem_1.default);
        const excludedClass = this.expandListClassName;
        const results = await Promise.all(list.map((commandBarItem) => {
            return commandBarItem.hasClass(excludedClass).then((hasClass) => {
                if (hasClass) {
                    // Check if the overflow command is displayed. If its displayed expand it by clicking the button.
                    return commandBarItem.isDisplayed().then((displayed) => {
                        if (displayed) {
                            return commandBarItem
                                .element(By_1.default.className(this.dropMenuContentClassName))
                                .hasClass(this.dropMenuDisplayedClassName)
                                .then((dropMenuOpen) => {
                                if (dropMenuOpen) {
                                    return !hasClass && commandBarItem;
                                }
                                else {
                                    return commandBarItem.click().then(() => !hasClass && commandBarItem);
                                }
                            });
                        }
                        return !hasClass && commandBarItem;
                    });
                }
                return !hasClass && commandBarItem;
            });
        }));
        return await (0, Array_1.filterAsync)(results, (commandBarItem) => !!commandBarItem);
    }
    /**
     * Gets the command bar item for the given command name.
     * If there are overflow commands, the overflow button will be clicked and overflow command matching the command name will be returned.
     *
     * @param commandText Name of the command.
     * @returns Promise returning the CommandBarItem matching the given command name.
     */
    async getItem(commandText) {
        const commandBarItems = await this.getItems();
        const promises = [];
        commandBarItems.forEach((commandBarItem) => {
            promises.push(commandBarItem.getText());
        });
        const commandNames = await Promise.all(promises);
        let commandItem = null;
        commandNames.forEach((name, index) => {
            if (name === commandText) {
                commandItem = commandBarItems[index];
                return;
            }
        });
        if (commandItem) {
            return commandItem;
        }
        else {
            Logger_1.default.warning(String.format("Command item for command text = {0} is not present", commandText));
            return undefined;
        }
    }
    /**
     * Finds the commandBar menu button with the specified command label.
     *
     * @param {string} commandLabel Text of the command to click.
     */
    async findCommandBarMenuButton(commandLabel) {
        await this.expandOverflow();
        const items = this.all(CommandBarMenuButton_1.default);
        const commandBarMenuButton = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const filteredCommandBarMenuButtons = items.filter((button) => {
                const promise = checkCommandBarMenuButtonHasExpectedText(button, commandLabel);
                return promise;
            });
            const filteredCommandBarMenuButtonsAsPortalElements = await filteredCommandBarMenuButtons.asPortalElements();
            if (filteredCommandBarMenuButtonsAsPortalElements.length === 1) {
                return filteredCommandBarMenuButtonsAsPortalElements[0];
            }
            if (filteredCommandBarMenuButtonsAsPortalElements.length === 0) {
                return null;
            }
            if (filteredCommandBarMenuButtonsAsPortalElements.length > 1) {
                throw new Error("More than one buttons found.");
            }
            async function checkCommandBarMenuButtonHasExpectedText(button, commandLabel) {
                return (await button.getText()).toLowerCase() === commandLabel.toLowerCase();
            }
        }, null, `Could not find the ${commandLabel} item in the toolbar`);
        return commandBarMenuButton;
    }
    /**
     * Finds the command with the specified command text.
     *
     * @param {string} commandText Text of the command to find.
     */
    async findCommandBarItem(commandText) {
        await this.expandOverflow();
        const command = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const items = this.all(CommandBarItem_1.default).filter((commandBarItem) => {
                const promise = checkCommandBarItemHasNotSpecificClass(commandBarItem, this.overflowClassName);
                return promise;
            });
            const filteredCommandBarItem = items.filter((commandBarItem) => {
                const promise = checkCommandBarItemHasExpectedText(commandBarItem, commandText);
                return promise;
            });
            const filteredCommandBarItemArray = await filteredCommandBarItem.asPortalElements();
            if (filteredCommandBarItemArray.length === 1) {
                return filteredCommandBarItemArray[0];
            }
            if (filteredCommandBarItemArray.length === 0) {
                return null;
            }
            if (filteredCommandBarItemArray.length > 1) {
                throw new Error("More than one CommandBarItems found.");
            }
            async function checkCommandBarItemHasExpectedText(commandBarItem, commandText) {
                return (await commandBarItem.getText()).toLowerCase() === commandText.toLowerCase();
            }
            async function checkCommandBarItemHasNotSpecificClass(commandBarItem, expectedClass) {
                return !(await commandBarItem.hasClass(expectedClass));
            }
        }, null, `Could not find the ${commandText} command in the command bar.`);
        return command;
    }
    /**
     * Clicks the command with the specified command text and optionally handles a message box after the command is clicked.
     *
     * @param commandText Text of the command to find.
     * @param messageBoxTitle The title of the message box to handle.  If empty, then any message box will be found.  Optional
     * @param messageBoxButtonToClick The text of the button to click in the message box that is expected to appear.  If empty, then will not handle a message box.  Optional
     */
    async clickCommandBarItem(commandText, messageBoxTitle = "", messageBoxButtonToClick = "") {
        const command = await this.findCommandBarItem(commandText);
        await command.click();
        // Handle a message box that pops up on click if given.
        if (!isNullOrWhiteSpace(messageBoxButtonToClick)) {
            let messageBox;
            if (isNullOrWhiteSpace(messageBoxTitle)) {
                messageBox = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    return this.element(MessageBox_1.default);
                }, null, `Could not find a Message Box to handle.`);
            }
            else {
                messageBox = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    const allButtons = this.all(MessageBox_1.default);
                    const filteredMessageBox = allButtons.filter((messageBox) => {
                        const promise = checkMessageBoxHasExpectedText(messageBox, messageBoxTitle);
                        return promise;
                    });
                    const filteredfilteredMessageBoxAsPortalElements = await filteredMessageBox.asPortalElements();
                    if (filteredfilteredMessageBoxAsPortalElements.length === 1) {
                        return filteredfilteredMessageBoxAsPortalElements[0];
                    }
                    if (filteredfilteredMessageBoxAsPortalElements.length === 0) {
                        return null;
                    }
                    if (filteredfilteredMessageBoxAsPortalElements.length > 1) {
                        throw new Error("More than one MessageBox found.");
                    }
                }, null, `Could not find a Message Box with the '${messageBoxTitle}' title to handle.`);
            }
            await messageBox.clickButton(messageBoxButtonToClick);
        }
        return command;
        async function checkMessageBoxHasExpectedText(messageBox, messageBoxTitle) {
            return (await messageBox.getText()).toLowerCase() === messageBoxTitle.toLowerCase();
        }
        function isNullOrWhiteSpace(input) {
            return !input || input.trim().length < 1;
        }
    }
    /**
     *  Expands the command bar overflow list if its present
     */
    async expandOverflow() {
        // The overflow button isn't displayed if the the blade is large enough
        const overflowButton = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return this.element(By_1.default.className(this.overflowClassName));
        }, null, `Expected expand button to be inside header.`);
        // In weavetoolbar mode, the overflow button won't exist before it's needed
        // In Ko code, the overflow button always present in DOM (though could be invisible)
        if ((await overflowButton.isPresent()) && (await overflowButton.isDisplayed())) {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                // Make sure the popup is visible.
                const overflowPopup = overflowButton.tryFindElement(By_1.default.className(this.overflowPopupClassName));
                if (!(await overflowPopup.isPresent()) || !(await overflowPopup.isDisplayed())) {
                    await overflowButton.click();
                    return false;
                }
                else {
                    return true;
                }
            }, null, "Expand overflow popup");
        }
    }
}
exports.default = CommandBar;
//# sourceMappingURL=CommandBar.js.map