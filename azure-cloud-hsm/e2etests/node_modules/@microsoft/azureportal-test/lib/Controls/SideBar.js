"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("../Locators/By");
const Menu_1 = require("../Controls/Menu");
const PortalElement_1 = require("../PortalElement");
const SideBarBrowseFlyout_1 = require("./SideBarBrowseFlyout");
const TopBar_1 = require("../TopBar/TopBar");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const BrowserAutomation_1 = require("../BrowserAutomation");
const PortalShell_1 = require("../PortalShell");
const Logger_1 = require("../Logger");
/**
 * Represents the SideBar.
 */
class SideBar extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.browseFlyoutButtonClass = "fxs-sidebar-browse";
        this.sideBarCollapsedClass = "fxs-sidebar-is-collapsed";
        this.sideBarMenuClass = "fxs-sidebar-menu";
        this.sideBarMenuIsDisplayedClass = "fxs-sidebar-menu-activated";
        this.sideBarMenuToggleButtonClass = "fxs-sidebar-menu-toggle-link";
        this.sideBarCollapseHamburgerButtonClass = "fxs-sidebar-hamburger";
        this.sideBarCollapseButtonClass = "fxs-sidebar-collapse-button";
        this.sideBarFlyoutClass = "fxs-sidebar-hamburger-mode";
        this.sideBarFavoritesClass = "fxs-sidebar-favorites";
        this.sideBarLabelClass = "fxs-sidebar-label";
        this.sideBarItemClass = "fxs-sidebar-item";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("fxs-sidebar");
    }
    /**
     * Indicator if the sidebar is collapsed.
     */
    async isCollapsed() {
        return await this.hasClass(this.sideBarCollapsedClass);
    }
    /**
     * Gets the browse flyout for the sidebar.
     */
    get browseFlyout() {
        return PortalShell_1.default.getPortalShell().element(SideBarBrowseFlyout_1.default);
    }
    /**
     * Checks if blade menu is hosted on sidebar.
     */
    async isBladeMenuHostedOnSideBar() {
        return await this.hasClass(this.sideBarMenuClass);
    }
    /**
     * Checks if the blade menu on sidebar is displayed.
     */
    async isBladeMenuDisplayed() {
        return await this.hasClass(this.sideBarMenuIsDisplayedClass);
    }
    /**
     * Gets the blade menu toggle button.
     */
    get getBladeMenuToggleButton() {
        return this.element(By_1.default.className(this.sideBarMenuToggleButtonClass));
    }
    /**
     * Opens the browse flyout.
     */
    async openBrowseFlyout() {
        await this.open();
        const browseFlyoutButton = this.element(By_1.default.className(this.browseFlyoutButtonClass));
        await browseFlyoutButton.click();
    }
    /**
     * Opens the sidebar. For use in sidebar flyout mode.
     */
    async open() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (await this.isCollapsed()) {
                await this.toggleCollapse();
            }
            return !(await this.isCollapsed());
        });
    }
    /**
     * Toggles the collapse state of sidebar.
     */
    async toggleCollapse() {
        const topbar = ElementArrayFinder_1.default.element(TopBar_1.default);
        const toggleButton = await topbar.getSideBarToggleButton();
        if (await toggleButton.isDisplayed()) {
            // Flyout mode
            const hamburgerButton = this.tryFindElement(By_1.default.className(this.sideBarCollapseHamburgerButtonClass));
            if (hamburgerButton && (await hamburgerButton.isDisplayed())) {
                // Expanded mode
                await hamburgerButton.click();
            }
            else {
                // Collapsed mode, not rendered yet
                await toggleButton.click();
            }
        }
        else {
            // Docked mode
            const collapseButton = this.element(By_1.default.className(this.sideBarCollapseButtonClass));
            await collapseButton.click();
        }
    }
    /**
     * Gets the blade menu.
     */
    async getBladeMenu() {
        if (await this.isBladeMenuHostedOnSideBar()) {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                await this.open();
                if (await this.isBladeMenuDisplayed()) {
                    return true;
                }
                else {
                    return false;
                }
            });
        }
        return this.element(Menu_1.default);
    }
    /**
     * Indicates if the sidebar is docked.
     * There are two display modes for SideBar:
     * flyout: SideBar will be hidden into a hamburger button on topbar and flyout when clicking on it.
     * docked: SideBar will be docked to the window left.
     */
    async inDockedMode() {
        const portal = ElementArrayFinder_1.default.element(By_1.default.className("fxs-portal"));
        return !(await portal.hasClass(this.sideBarFlyoutClass));
    }
    /**
     * Gets a favorite item by the asset type name.
     *
     * @param assetTypeName Favorite item's asset type name.
     * @returns A promise wrapping the favorite item.
     * @throws Will throw an error if the specified fragment is not found.
     */
    async getFavorite(assetTypeName) {
        Logger_1.default.diagnostics(`Searching for favorite item in side bar ${assetTypeName}`);
        await this.open();
        const favorites = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.element(By_1.default.className(this.sideBarFavoritesClass));
        }, null, `Could not find the favorites panel with the class ${this.sideBarFavoritesClass} on the side bar.`);
        const favoriteItem = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const favoriteItems = favorites.all(By_1.default.className(this.sideBarItemClass));
            Logger_1.default.diagnostics(`Searching ${await favoriteItems.count()} items with class label ${this.sideBarItemClass}...`);
            const matchingItems = await favoriteItems
                .filter(async (item) => {
                const itemLabel = item.element(By_1.default.className(this.sideBarLabelClass));
                const itemText = await itemLabel.getText();
                if (itemText.startsWith(assetTypeName)) {
                    Logger_1.default.diagnostics(`Found '${itemText}' favorite item in side bar which matches '${assetTypeName}'`);
                    return true;
                }
                Logger_1.default.diagnostics(`Item ${itemText} does not match'${assetTypeName}'`);
                return false;
            })
                .asPortalElements();
            if (matchingItems.length === 1) {
                return matchingItems[0];
            }
            else if (matchingItems.length > 1) {
                throw new Error(`More than one favorite item found that matches the name '${assetTypeName}'.`);
            }
            return null;
        }, null, `Expected element with label ${assetTypeName} to exist in the side bar favorites.`);
        Logger_1.default.diagnostics(`Exiting getFavorites for asset ${assetTypeName}`);
        return favoriteItem;
    }
}
exports.default = SideBar;
//# sourceMappingURL=SideBar.js.map