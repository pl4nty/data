"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.portal = void 0;
const PortalElement_1 = require("./PortalElement");
const Blade_1 = require("./Blades/Blade");
const BrowseResourceBlade_1 = require("./Blades/BrowseResourceBlade");
const CreateBlade_1 = require("./Blades/CreateBlade");
const jwt = require("jsonwebtoken");
const MenuBlade_1 = require("./Blades/MenuBlade");
const MoveResourcesBlade_1 = require("./Blades/MoveResourcesBlade");
const ListCommandPopup_1 = require("./Commands/ListCommandPopup");
const Constants = require("./Constants");
const ElementArrayFinder_1 = require("./ElementArrayFinder");
const By_1 = require("./Locators/By");
const queryStringNames = require("./PortalFxQueryStringNames");
const PortalFxResources = require("./PortalFxResources");
const SearchMenu_1 = require("./Search/SearchMenu");
const SplashScreen_1 = require("./SplashScreen");
const StartBoard_1 = require("./StartBoard");
const errorHandling = require("./Utils/ErrorHandling");
const String = require("./Utils/String");
const uriBuilder = require("./Utils/UriBuilder");
const SideBar_1 = require("./Controls/SideBar");
const SideBarBrowseFlyout_1 = require("./Controls/SideBarBrowseFlyout");
const Utils = require("./Utils");
const NotificationsPane_1 = require("./Notifications/NotificationsPane");
const NotificationsPane_2 = require("./Notifications/NotificationsPane");
const NotificationsMenu_1 = require("./Notifications/NotificationsMenu");
const AvatarMenu_1 = require("./AvatarMenu/AvatarMenu");
const Part_1 = require("./Parts/Part");
const PortalShell_1 = require("./PortalShell");
const TopBar_1 = require("./TopBar/TopBar");
const Logger_1 = require("./Logger");
const ContextPane_1 = require("./ContextPane/ContextPane");
const CtrlAltDOperations_1 = require("./CtrlAltDOperations");
const DebugFlyout_1 = require("./ContextPane/DebugFlyout");
const Settings_1 = require("./Settings");
const SettingsFlyout_1 = require("./Settings/SettingsFlyout");
const ModalDialog_1 = require("./Controls/Dialogs/ModalDialog");
const Grid_1 = require("./Controls/Grid");
const MessageBox_1 = require("./Controls/Dialogs/MessageBox");
const Toolbar_1 = require("./Controls/Toolbars/Toolbar");
const BrowserAutomation_1 = require("./BrowserAutomation");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const RunScripts_1 = require("./Utils/RunScripts");
const ActionsMenu_1 = require("./TopBar/ActionsMenu");
const tokenRefreshBufferInMs = 10 * 60 * 1000;
var AuthMode;
(function (AuthMode) {
    AuthMode[AuthMode["WIA"] = 1] = "WIA";
    AuthMode[AuthMode["Corp"] = 2] = "Corp";
    AuthMode[AuthMode["LiveOrOrgId"] = 3] = "LiveOrOrgId";
    AuthMode[AuthMode["None"] = 4] = "None";
    AuthMode[AuthMode["CBA"] = 5] = "CBA";
})(AuthMode || (AuthMode = {}));
/**
 * Extracts domain from given url
 *
 * @param {string} url The url to extract domain from.
 * @returns extracted domain.
 */
const extractDomain = (url) => url.replace(/^(?:http|https):\/\//, "").split("/")[0];
/**
 * Format resourceType slashes to HTML unicode %2f
 *
 * @param {string} resourceType The resource type.
 * @returns formatted string.
 */
const formatResourceType = (resourceType) => resourceType.replace(/\//g, "%2f");
/**
 * Represents an object that provides multiple operations to interact with the Portal.
 */
class Portal {
    /**
     * Creates a new instance of this class.
     */
    constructor() {
        this.canModifyExtensionsFeature = "feature.canmodifyextensions";
        this.redirectDivId = "redirect_dots_animation";
        this.usernameErrorId = "usernameError";
        this.passwordErrorId = "passwordError";
        this.corpEmailTextBoxCssSelector = "#userNameInput";
        this.corpPasswordTextBoxCssSelector = "#passwordInput";
        this.corpSignInUrl = "https://msft.sts.microsoft.com";
        this.corpSubmitButtonCssSelector = "#submitButton";
        this.liveIdEmailTextBoxCssSelector = "#i0116";
        this.liveIdPasswordTextBoxCssSelector = "#i0118";
        this.liveIdSubmitButtonCssSelector = "#idSIButton9";
        this.orgIdEmailTextBoxCssSelector = "#cred_userid_inputtext";
        this.orgIdPasswordTextBoxCssSelector = "#cred_password_inputtext";
        this.orgIdSubmitButtonCssSelector = "#cred_sign_in_button";
        this.keepMeSignedInPageId = "KmsiInterrupt"; // PPE
        this.keepMeSignedInPageIdAlternate = "i5245"; // Prod
        this.keepMeSignedInDeclineIdSelector1 = "declineButton";
        this.keepMeSignedInDeclineIdSelector2 = "idBtn_Back";
        this.workAccountTileId = "aadTile";
        this.defaultCloudName = "testDefaultCloud";
        this.testingCloudName = "cloud1";
        this.useMultiCloud = false;
        this.useMultiCloudInitialized = false;
        this.portalWebDriverInitialized = false;
        this.signInUrls = [
            "https://login.microsoftonline.com", // Prod
            "https://login.windows-ppe.net", // Dogfood/PPE
            "https://login.partner.microsoftonline.cn", // Mooncake
            "https://login.microsoftonline.us", // Fairfax
        ];
        /**
         * Gets the Debug Pane.
         *
         * @returns DebugFlyout.
         */
        this.getDebugFlyout = (0, PortalElement_1.retry)(DebugFlyout_1.default, async () => {
            await CtrlAltDOperations_1.default.openDebugHub();
            const debugFlyoutElement = this.element(DebugFlyout_1.default);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await debugFlyoutElement.isDisplayed(), null, "Could not find debug flyout", "Looking for debug flyout");
            return debugFlyoutElement;
        }, "DebugFlyout");
        // Set the portal context to read from the global PortalConfiguration class
        this.portalContext = PortalConfigurationManager_1.default.portalContext;
        // Add the custom sign in url if its not already known
        if (!String.isNullOrEmptyOrUndefined(this.portalContext.signInUrl)) {
            if (!this.signInUrls.some((u) => String.equalsIgnoringCase(u, this.portalContext.signInUrl))) {
                Logger_1.default.diagnostics(`Adding custom url '${this.portalContext.signInUrl}' to list of sign in urls`);
                this.signInUrls.push(this.portalContext.signInUrl);
            }
        }
    }
    /**
     * Gets Searchmenu.
     *
     * @returns an instance of SearchMenu Class.
     */
    async getSearchMenu() {
        return await Promise.resolve(this.element(SearchMenu_1.default));
    }
    /**
     * Gets Dashboard.
     *
     * @returns an instance of StartBoard Class.
     */
    async getDashboard() {
        return await Promise.resolve(this.element(StartBoard_1.default));
    }
    /**
     * Gets the ContextPane.
     *
     * @returns an instance of ContextPane Class.
     */
    async getContextPane() {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allContextPane = this.all(ContextPane_1.default);
            const filteredContextPane = allContextPane.filter((contextPane) => {
                const promise = contextPane.hasContextPaneRightClass();
                return promise;
            });
            const filteredContextPaneAsPortalElements = await filteredContextPane.asPortalElements();
            if (filteredContextPaneAsPortalElements.length > 0) {
                return filteredContextPaneAsPortalElements[0];
            }
            return null;
        }, null, "Could not find ContextPane.", "Looking for ContextPane.");
    }
    /**
     * Optionally, sets sessionId. This is for tests to call, if a unique session is needed.
     *
     * @param {string} suffix optional suffix in sessionId. Generally, it could be some combination of test suite/test case names.
     */
    setSessionIdInPortalContext(suffix) {
        this.portalContext.sessionId = "TestTraffic_" + Utils.Guid.newGuid() + suffix;
    }
    /**
     * Gets SideBar.
     *
     * @returns an instance of SideBar Class.
     */
    async getSideBar() {
        const sideBar = this.element(SideBar_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await sideBar.isPresent(), null, "SideBar was not present", "Looking for SideBar to be present");
        return sideBar;
    }
    /**
     * Opens the gallery create blade for the specified gallery package. This function is only supported for
     * gallery packages deployed to the gallery service. When the package only exists locally use function openGalleryCreateBladeFromLocalPackage.
     *
     * @param {string} galleryPackageName The name of the gallery package.
     * @param {string} bladeTitle The title of the blade that is expected to open.
     * @param {number} timeout The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
     * @returns A promise that resolves with the gallery create blade.
     */
    async openGalleryCreateBlade(galleryPackageName, bladeTitle, timeout, waitForBladeLoadedOnly) {
        Logger_1.default.information(String.format("Opening the Create blade for {0}...", galleryPackageName));
        const computedTimeout = timeout || this.portalContext.timeouts.extraLongTimeout;
        await this.navigateToUriFragment("create/" + galleryPackageName);
        const extensionCreateBlade = this.blade({ title: bladeTitle, bladeType: CreateBlade_1.default });
        await this.getBladeLoadPromise(extensionCreateBlade, waitForBladeLoadedOnly, computedTimeout);
        return extensionCreateBlade;
    }
    /**
     * Opens the create blade from gallery package that is sideloaded from localhost.
     *
     * @param {string} galleryItemTitle The title of the gallery item in marketplace
     * @param {string} bladeTitle The title of the extensions create blade that is expected to open after clicking on the gallery item.
     * @param {number} [timeout] Optional time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @param {boolean} [waitForBladeLoadedOnly] If true waits for the blade only to load, but not all of its tiles, before resolving
     * @returns A promise that resolves with the gallery CreateBlade.
     */
    async openGalleryCreateBladeFromLocalPackage(galleryItemTitle, bladeTitle, timeout, waitForBladeLoadedOnly) {
        const localDevelopmentBlade = this.blade({ title: PortalFxResources.marketplace, bladeType: Blade_1.default });
        const extensionCreateBlade = this.blade({ title: bladeTitle, bladeType: CreateBlade_1.default });
        const computedTimeout = timeout || this.portalContext.timeouts.extraLongTimeout;
        Logger_1.default.information("Opening Local Development blade from Gallery");
        await this.navigateToUriFragment("blade/Microsoft_Azure_Marketplace/GalleryMenuBlade/selectedMenuItemId/local", computedTimeout);
        await localDevelopmentBlade.waitUntilBladeAndAllTilesLoaded(computedTimeout);
        await localDevelopmentBlade
            .element(By_1.default.classAndDescendentText("ext-tile-container", galleryItemTitle))
            .element(By_1.default.classAndDescendentText("azc-toolbar-item", "Create"))
            .click();
        await localDevelopmentBlade
            .element(By_1.default.classAndDescendentText("azc-toolbarButton-groupPopup", galleryItemTitle))
            .click();
        await this.getBladeLoadPromise(extensionCreateBlade, waitForBladeLoadedOnly, computedTimeout);
        return extensionCreateBlade;
    }
    /**
     * Opens the browse blade for the given resource provider and resource type.
     *
     * @param {string} resourceProvider The resource provider.
     * @param {string} resourceType The resource type.
     * @param {string} bladeTitle The title of the blade that is expected to open.
     * @param {number} [timeout] The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
     * @returns A promise that resolves with the browse blade.
     */
    async openBrowseBlade(resourceProvider, resourceType, bladeTitle, timeout, waitForBladeLoadedOnly) {
        const browseGrid2 = this.portalContext.features &&
            this.portalContext.features.some((feature) => {
                return (feature.name &&
                    feature.name.toLowerCase() === "feature.browsegrid2" &&
                    feature.value &&
                    feature.value.toLowerCase() === "true");
            });
        resourceType = formatResourceType(resourceType);
        const deepLink = browseGrid2
            ? String.format("blade/HubsExtension/Resources/resourceType/{0}%2f{1}", resourceProvider, resourceType)
            : String.format("blade/HubsExtension/BrowseResourceBlade/resourceType/{0}%2f{1}", resourceProvider, resourceType);
        Logger_1.default.information(String.format("Opening the Browse blade for the {0}/{1} resource type...", resourceProvider, resourceType));
        return this.openBlade(deepLink, bladeTitle, BrowseResourceBlade_1.default, timeout, waitForBladeLoadedOnly);
    }
    /**
     * Opens the ARG browse resource groups blade.
     *
     * @param {number} [timeout] Optional time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
     * @returns A promise that resolves with the browse resource groups blade.
     */
    async openArgBrowseResourceGroupsBlade(timeout, waitForBladeLoadedOnly) {
        Logger_1.default.information("Opening ARG browse resource groups blade");
        return this.openBlade("blade/HubsExtension/BrowseResourceGroups", PortalFxResources.resourceGroups, BrowseResourceBlade_1.default, timeout, waitForBladeLoadedOnly);
    }
    /**
     * Opens the resource/summary blade associated to the specified resource id.
     *
     * @param {string} resourceId The resource id.
     * @param {string} bladeTitle The title of the blade that is expected to open.
     * @param {number} timeout The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
     * @returns A promise that resolves with the resource blade.
     */
    async openResourceBlade(resourceId, bladeTitle, timeout, waitForBladeLoadedOnly) {
        Logger_1.default.information(String.format("Opening the resource blade for {0}...", resourceId));
        return this.openBlade("resource" + resourceId, bladeTitle, MenuBlade_1.default, timeout, waitForBladeLoadedOnly);
    }
    /**
     * Opens the blade associated to the specified URI fragment.
     *
     * @param {string} uriFragment The uri fragment of the blade to navigate to.
     * @param {string} bladeTitle The title of the blade that is expected to open.
     * @param {string} bladeType The type of the blade that is expected to open.
     * @param {number} timeout The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
     * @returns A promise that resolves with the blade.
     */
    async openBlade(uriFragment, bladeTitle, bladeType, timeout, waitForBladeLoadedOnly) {
        if (!bladeTitle && !bladeType) {
            throw new Error("Please provide the title or type of the blade.");
        }
        const blade = this.blade({ title: bladeTitle, bladeType: bladeType });
        const computedTimeout = timeout || this.portalContext.timeouts.extraLongTimeout;
        Logger_1.default.information(String.format("Opening the blade for {0}...", uriFragment));
        await this.navigateToUriFragment(uriFragment, computedTimeout);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await blade.isPresent(), computedTimeout, String.format("Blade with title '{0}' was not found within the allotted timeout of {1} ms.  Please verify that the portal loaded and the blade was present.", bladeTitle, computedTimeout));
        await this.getBladeLoadPromise(blade, waitForBladeLoadedOnly, computedTimeout);
        return blade;
    }
    /**
     * Opens the view associated to the specified URI fragment.
     *
     * @param {string} uriFragment The uri fragment of the view to navigate to.
     * @param {string} viewTitle The title of the view that is expected to open.
     * @param {string} viewType The type of the view that is expected to open.
     * @param {number} timeout The time to wait, in milliseconds, for the view to show up. Defaults to DefaultTimeouts.extraLongTimeout.
     * @returns A promise that resolves with the view.
     */
    async openView(uriFragment, viewTitle, viewType, timeout) {
        const view = this.view({ title: viewTitle, viewType });
        const computedTimeout = timeout || this.portalContext.timeouts.extraLongTimeout;
        Logger_1.default.information(`Opening the view for ${uriFragment}...`);
        await this.navigateToUriFragment(uriFragment, computedTimeout);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await view.isPresent(), computedTimeout, `View with title '${viewTitle}' was not found within the allotted timeout of ${computedTimeout} seconds. Please verify that the portal loaded and the view was present.`);
        await view.waitUntilLoaded(computedTimeout);
        return view;
    }
    /**
     * Searches for the specified text in the portal top bar and returns search results.
     *
     * @param text The text to search for.
     * @returns A promise that resolves when there are search results.
     */
    async search(text) {
        if (!text) {
            throw new Error("Please provide a non empty search text.");
        }
        return this.element(SearchMenu_1.default).search(text);
    }
    /**
     * Starts a move operation using the specified options.
     *
     * @param options The options used to populate the blade.
     * @returns A promise that resolves when the move operation has started.
     */
    async startMoveResource(options) {
        if (!options.resourceId || options.resourceId === "") {
            throw new Error("Please provide the resource id.");
        }
        Logger_1.default.information(String.format("Opening the resource blade for {0}...", options.resourceId));
        const moveResourcesBlade = this.blade({ bladeType: MoveResourcesBlade_1.default });
        await this.navigateToUriFragment("resource" + options.resourceId, options.timeout);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.element(Blade_1.default).isPresent(), options.timeout);
        const blade = this.all(Blade_1.default).get(0);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await blade.hasCommand(PortalFxResources.move), options.timeout);
        await blade.clickCommand(PortalFxResources.move);
        try {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await moveResourcesBlade.isDisplayed());
            await moveResourcesBlade.waitUntilLoaded();
        }
        catch {
            const listPopup = this.element(ListCommandPopup_1.default).asType(ListCommandPopup_1.default);
            const optionText = options.listOptionText ? options.listOptionText : "Move to another resource group";
            await listPopup.selectItemByText(optionText);
            await moveResourcesBlade.waitUntilLoaded();
        }
        const resourceIdParts = options.resourceId.split("/");
        let resourceGroup;
        for (let i = 0; i < resourceIdParts.length; i++) {
            if (resourceIdParts[i] === "resourceGroups") {
                resourceGroup = resourceIdParts[i + 1];
                break;
            }
        }
        return await moveResourcesBlade.startMove({
            currentResourceGroup: resourceGroup,
            targetResourceGroup: options.targetResourceGroup,
            createNewGroup: options.createNewGroup,
            subscriptionName: options.subscriptionName,
            relatedResources: options.relatedResources,
            timeout: options.timeout,
        });
    }
    /**
     * Resets the current dashboard to its default state.
     *
     * @deprecated Use `StartBoard.reset` instead.
     */
    async resetDashboard() {
        await this.element(StartBoard_1.default).reset();
    }
    /**
     * Navigates to the home page.
     *
     * @param {number} timeout The time to wait, in milliseconds, for pages to load.
     * @param {boolean} waitForDashboardTilesToLoad whether to wait for all tiles on dashboard to load
     */
    async goHome(timeout, waitForDashboardTilesToLoad) {
        const currentUrl = await this.getCurrentUrl();
        let url = this.buildHomeUrl(currentUrl);
        // Append the hash if not present to ensure that we don't go to a saved journey
        url += !url.includes("#") ? "#" : "";
        await this.navigateTo(url, timeout);
        if (waitForDashboardTilesToLoad) {
            const startBoard = await this.getDashboard();
            await startBoard.waitForAllTilesLoaded();
        }
    }
    /**
     * Navigates to the specified uri fragment. In most cases, use this.openBlade(...) instead.
     *
     * @param {string} fragment The uri fragment to navigate to.
     * @param {number} timeout The time to wait for pages to load.
     * @throws Will throw an error if the specified fragment is a falsy value.
     */
    async navigateToUriFragment(fragment, timeout) {
        if (!fragment) {
            throw new Error("Please specify a valid uri fragment.");
        }
        let url;
        const { portalWebDriverInitialized } = this;
        if (!portalWebDriverInitialized) {
            const currentUrl = await this.getCurrentUrl();
            url = this.buildHomeUrl(currentUrl);
        }
        else {
            url = await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
        }
        const partsDelimitedByHash = url.split("#");
        let newfragment;
        if (partsDelimitedByHash.length > 1) {
            const partsDelimitedByQuestionMark = partsDelimitedByHash[1].split("?");
            if (partsDelimitedByQuestionMark.length > 1) {
                //has extensions and/or patch info
                const extensionsAndPatchPart = partsDelimitedByQuestionMark[1];
                //preserving extensions and patch string
                newfragment = fragment + "?" + extensionsAndPatchPart;
            }
            else {
                //does not have extensions and/or patch part.
                newfragment = fragment;
            }
        }
        else {
            //no hash. has only url part
            newfragment = fragment;
        }
        if (portalWebDriverInitialized) {
            await (0, RunScripts_1.waitUntilScriptsCanExecute)();
            const ret = await (0, RunScripts_1.runScript)(`window.location.hash = "${newfragment}"`);
            await (0, RunScripts_1.waitUntilScriptsCanExecute)();
            return ret;
        }
        const fullLink = partsDelimitedByHash[0] + "#" + newfragment;
        await this.navigateTo(fullLink, timeout);
        await (0, RunScripts_1.waitUntilScriptsCanExecute)();
    }
    /**
     * Gets a Blade object that represents the blade that matches the specified options.
     *
     * @param options The options used to find the blade.
     * @param bladeType The type of blade to return.
     * @returns A Blade object that represents the blade that matches the specified options.
     */
    blade(options) {
        return PortalShell_1.default.blade(options);
    }
    /**
     * Gets a View object that represents the view that matches the specified options.
     *
     * @param options The options used to find the view.
     * @returns A View object that represents the view that matches the specified options.
     */
    view(options) {
        const locator = new options.viewType().buildLocator(options);
        return ElementArrayFinder_1.default.element(locator).asType(options.viewType);
    }
    /**
     * Gets a PortalElement that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns A PortalElement that matches the specified sub locator or element type.
     */
    element(subLocatorOrElementType) {
        return ElementArrayFinder_1.default.element(subLocatorOrElementType);
    }
    /**
     * Gets a PortalElement that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns A PortalElement that matches the specified sub locator or element type if found, or null.
     */
    async elementOrDefaultAsync(subLocatorOrElementType) {
        const element = new ElementArrayFinder_1.default().all(subLocatorOrElementType).toPortalElement();
        if (await element.isPresent()) {
            return element;
        }
        else {
            return null;
        }
    }
    /**
     * Gets an ElementArrayFinder that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns An ElementArrayFinder that matches the specified sub locator or element type.
     */
    all(subLocatorOrElementType) {
        return ElementArrayFinder_1.default.all(subLocatorOrElementType);
    }
    /**
     * Schedules a command to wait for a condition to hold. The condition may be
     * specified by a promise or a custom function.
     *
     * For a function, the wait will repeatedly evaluate the condition until it returns a truthy value. If any errors occur
     * while evaluating the condition, they will be allowed to propagate. In the event a condition returns a promise, the
     * polling loop will wait for it to be resolved and use the resolved value for whether the condition has been satisified.
     *
     * @param condition The condition to wait on, defined as a promise or a function to evaluate as a condition.
     * @param {number} timeout How long to wait for the condition to be true.
     * @param {string | function} opt_messageOrTimeoutErrorFunction An optional message to use if the wait times out or an optional function that returns an error message.
     * @param name name to pass to the webdriver wait function
     * @returns A promise that will be fulfilled with the first truthy value returned by the condition function, or
     *     rejected if the condition times out.
     */
    async wait(condition, timeout, opt_messageOrTimeoutErrorFunction, name) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(condition, timeout, opt_messageOrTimeoutErrorFunction, name);
    }
    /**
     * Delays execution for the specified amount of time.
     *
     * @param ms The amount of time to delay, in milliseconds. Defaults to delayTimeout.
     * @returns A promise that will be resolved after the specified amount of time has passed.
     */
    async delay(ms) {
        return await (0, PortalElement_1.delay)(ms);
    }
    /**
     * Schedule a command to take a screenshot. The driver makes a best effort to return a screenshot of the following, in order of preference:
     * <ol>
     *   <li>Entire page
     *   <li>Current window
     *   <li>Visible portion of the current frame
     *   <li>The screenshot of the entire display containing the browser
     * </ol>
     *
     * @param {string} filePrefix The prefix used for the generated screenshot file.
     * @returns A promise that will be resolved to the path of the screenshot file.
     * @tutorial tutorial-screenshot
     */
    async takeScreenshot(filePrefix) {
        return await (0, BrowserAutomation_1.getBrowser)().takeScreenshot(filePrefix);
    }
    /**
     * Accepts an alert if one is present
     *
     * @returns a promise when the alert has been accepted
     */
    async acceptAlert() {
        return await (0, BrowserAutomation_1.getBrowser)().acceptAlert();
    }
    /**
     * dismiss an alert if one is present
     *
     * @returns a promise when the alert has been dismissed
     */
    async dismissAlert() {
        return await (0, BrowserAutomation_1.getBrowser)().dismissAlert();
    }
    /**
     * Gets the text from an alert if one is present
     *
     * @returns a promise that will be resolved with the text of the alert.
     */
    async getAlertText() {
        return await (0, BrowserAutomation_1.getBrowser)().getAlertText();
    }
    /**
     * Gets the browser logs for the specified level.
     *
     * @param {LogLevel} level The level of logs to get.
     * @returns A promise that resolves to the array of logs.
     */
    async getBrowserLogs(level) {
        return await (0, BrowserAutomation_1.getBrowser)().getBrowserLogs(level);
    }
    /**
     * Schedules a command to execute JavaScript in the context of the currently
     * selected frame or window. The script fragment will be executed as the body
     * of an anonymous function. If the script is provided as a function object,
     * that function will be converted to a string for injection into the target
     * window.
     *
     * @param {string} script The script to execute.
     * @param {...*} var_args The arguments to pass to the script.
     * @returns A promise that will resolve to the scripts return value.
     */
    async executeScript(script, ...var_args) {
        return await (0, BrowserAutomation_1.getBrowser)().executeScript(script, ...var_args);
    }
    /**
     * Schedules a command to execute asynchronous JavaScript in the context of the
     * currently selected frame or window. The script fragment will be executed as
     * the body of an anonymous function. If the script is provided as a function
     * object, that function will be converted to a string for injection into the
     * target window.
     *
     * Any arguments provided in addition to the script will be included as script
     * arguments and may be referenced using the {@code arguments} object.
     * Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
     * Arrays and objects may also be used as script arguments as long as each item
     * adheres to the types previously mentioned.
     *
     * Unlike executing synchronous JavaScript with {@link #executeScript},
     * scripts executed with this function must explicitly signal they are finished
     * by invoking the provided callback. This callback will always be injected
     * into the executed function as the last argument, and thus may be referenced
     * with {@code arguments[arguments.length - 1]}. The following steps will be
     * taken for resolving this functions return value against the first argument
     * to the script's callback function:
     *
     * - For a HTML element, the value will resolve to a
     *     {@link IBrowserElement}
     * - Null and undefined return values will resolve to null
     * - Booleans, numbers, and strings will resolve as is
     * - Functions will resolve to their string representation
     * - For arrays and objects, each member item will be converted according to
     *     the rules above
     *
     * __Example #1:__ Performing a sleep that is synchronized with the currently
     * selected window:
     *
     *     var start = new Date().getTime();
     *     driver.executeAsyncScript(
     *         'window.setTimeout(arguments[arguments.length - 1], 500);').
     *         then(function() {
     *           Log.information(
     *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
     *         });
     *
     * __Example #2:__ Synchronizing a test with an AJAX application:
     *
     *     var button = driver.findElement(By.id('compose-button'));
     *     button.click();
     *     driver.executeAsyncScript(
     *         'var callback = arguments[arguments.length - 1];' +
     *         'mailClient.getComposeWindowWidget().onload(callback);');
     *     driver.switchTo().frame('composeWidget');
     *     driver.findElement(By.id('to')).sendKeys('dog@example.com');
     *
     * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
     * this example, the inject script is specified with a function literal. When
     * using this format, the function is converted to a string for injection, so it
     * should not reference any symbols not defined in the scope of the page under
     * test.
     *
     *     driver.executeAsyncScript(function() {
     *       var callback = arguments[arguments.length - 1];
     *       var xhr = new XMLHttpRequest();
     *       xhr.open("GET", "/resource/data.json", true);
     *       xhr.onreadystatechange = function() {
     *         if (xhr.readyState == 4) {
     *           callback(xhr.responseText);
     *         }
     *       }
     *       xhr.send('');
     *     }).then(function(str) {
     *       Log.information(JSON.parse(str)['food']);
     *     });
     *
     * @param {!(string|Function)} script The script to execute.
     * @param {...*} var_args The arguments to pass to the script.
     * @returns {Promise<T>} A promise that will resolve to the
     *    scripts return value.
     * @template T
     */
    async executeAsyncScript(script, ...var_args) {
        return await (0, BrowserAutomation_1.getBrowser)().executeAsyncScript(script, ...var_args);
    }
    /**
     * Schedules a command to retrieve the URL of the current page.
     *
     * @returns A promise that will be resolved with the current URL.
     */
    async getCurrentUrl() {
        if (this.hasBrowser()) {
            return await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
        }
        return "";
    }
    /**
     * Schedules a command to close the window (tab) at the specified index.
     *
     * @param {number} index Index of the window (tab) to close.
     * @returns A promise that resolves when the window (tab) has been closed.
     */
    async closeWindow(index) {
        return await (0, BrowserAutomation_1.getBrowser)().closeWindow(index);
    }
    /**
     * Schedules a command to resize the window to the specified width and height.
     *
     * @param {number} width New width to be set, defaults to current width.
     * @param {number} height New height to be set, defaults to current height.
     * @returns A promise that resolves when the window has been resized.
     */
    async resizeWindow(width, height) {
        return await (0, BrowserAutomation_1.getBrowser)().resizeWindow(width, height);
    }
    /**
     * Schedules a command to quit the current session. After calling quit, this
     * instance will be invalidated and may no longer be used to issue commands
     * against the browser.
     *
     * @param closeAlert When true will close any active alerts.
     * @param gracefullyClose When true will close the browser gracefully. When false will close the browser immediately.
     * @returns A promise that will be resolved when the command has completed.
     */
    async quit(closeAlert, gracefullyClose) {
        this.portalWebDriverInitialized = null;
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.quit(closeAlert), async (pw) => {
            if (gracefullyClose === null || gracefullyClose === undefined) {
                if (this.portalContext.playwright.options.channel) {
                    Logger_1.default.warning("Channel option was defined in Playwright options but 'gracefullyClose' was not passed to the testFx.portal.quit() function. Setting 'gracefullyClose' to 'false' by default to avoid the possible hang when closing the browser.");
                    gracefullyClose = false;
                }
                else {
                    gracefullyClose = true;
                }
            }
            await pw.quit(closeAlert, gracefullyClose);
        });
    }
    /**
     * Gets the internal BrowserAutomation instance used by this Portal object.
     *
     * @returns The BrowserAutomation instance.
     */
    getBrowser() {
        return (0, BrowserAutomation_1.getBrowser)();
    }
    /**
     * Returns a boolean indicating whether the internal BrowserAutomation instance has been created.
     */
    hasBrowser() {
        return (0, BrowserAutomation_1.getBrowser)().hasBrowser();
    }
    /**
     * Returns a promise that resolves after the blade loading.
     *
     * @param {Blade} blade The blade object to open.
     * @param {boolean} waitForBladeLoadedOnly if true waits for the blade only to load, but not all of its tiles, before resolving.
     * @param {number} timeout The time to wait, in milliseconds, for the blade to show up.
     * @returns A promise that resolves with the loaded blade.
     */
    async getBladeLoadPromise(blade, waitForBladeLoadedOnly, timeout) {
        if (waitForBladeLoadedOnly) {
            return await blade.waitUntilLoaded(timeout);
        }
        else {
            return await blade.waitUntilBladeAndAllTilesLoaded(timeout);
        }
    }
    /**
     * Enters the organize mode.
     *
     * @deprecated Use Startboard.enterOrganizeMode
     *  * @returns a promise when the portal enters in OrganizeMode.
     */
    async enterOrganizeMode() {
        await this.element(StartBoard_1.default).enterOrganizeMode();
    }
    /**
     * Exits the organize mode.
     *
     * @deprecated Use Startboard.exitOrganizeMode
     *  * @returns a promise when the portal enters in OrganizeMode.
     */
    async exitOrganizeMode() {
        if ((await this.waitForMode()) !== 1 /* PortalMode.Organize */) {
            throw new Error("Portal cannot exit organize mode if it is not in organize mode.");
        }
        const startboard = this.element(StartBoard_1.default);
        await startboard.exitOrganizeMode();
        // Exiting Organize Mode automatically saves user settings. However, the caller could refresh the browser
        // as soon as it exits this method, placing a racing condition on saving settings. Let's give it some time
        // so settings can be saved
        await this.delay(2000);
    }
    /**
     * Returns the current PortalMode.
     */
    async waitForMode() {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (await this.isInDefaultMode()) {
                return 0 /* PortalMode.Default */;
            }
            else if (await this.isInOrganizeMode()) {
                return 1 /* PortalMode.Organize */;
            }
            return null;
        }, null, "Portal failed to be in any mode.", "Determining Portal mode.");
    }
    /**
     * Checks whether portal is in OrganizeMode or not
     *
     * @returns A promise that will be resolved when the portal is in OrganizeMode.
     */
    async isInOrganizeMode() {
        return PortalShell_1.default.getPortalShell().isInOrganizeMode();
    }
    /**
     * Checks whether portal is in DefaultMode or not
     *
     * @returns A promise that will be resolved when the portal is in DefaultMode.
     */
    async isInDefaultMode() {
        return !(await this.isInOrganizeMode());
    }
    /**
     * Get resource deeplink.
     *
     * @param {string} resourceId resource id.
     * @param {string} cloudName cloud name. Only used in framework tests.
     */
    async getResourceDeepLink(resourceId, cloudName = null) {
        cloudName = this.normalizeTestingCloudName(cloudName);
        if (!String.startsWith(resourceId, "/")) {
            resourceId = "/" + resourceId;
        }
        if (!(await this.checkIfMultiCloud()) ||
            cloudName.toLocaleLowerCase().localeCompare(this.defaultCloudName.toLocaleLowerCase()) === 0) {
            return "resource" + resourceId;
        }
        return "resource/cloudname/" + cloudName + resourceId;
    }
    /**
     * Wait for the portal to be ready to run scripts.
     *
     * @param timeout time to wait for scripts to run. Default is 10 seconds.
     * @param waitForBootstrap whether to wait for bootstrap to complete. Default is false.
     * @returns a promise that resolves when scripts can run.
     */
    async waitUntilScriptsCanExecute({ timeout = this.portalContext.timeouts.timeout, waitForBootstrap = false, } = {}) {
        return await (0, RunScripts_1.waitUntilScriptsCanExecute)(timeout, waitForBootstrap);
    }
    /**
     * Returns whether active journey exist or not.
     */
    async hasActiveJourney() {
        return (await this.all(Blade_1.default).count()) > 0;
    }
    /**
     * Get Blade deeplink.
     *
     * @param {string} extensionName extension name. eg.:- "HubsExtension", "InternalSamplesExtension","SamplesExtension" etc.
     * @param {string} bladeName blade name. e.g. :- "Resources","BrowseAllResourcesBlade" etc.
     * @param {string} cloudName cloud name. Only used in framework tests.
     * @param {string} parametersWithLeadingSlash parameters with leading slash. e.g.:- `/resourceType/Microsoft.Test%2Fdesktops` etc.
     * @returns {Promise<string>} A promise that will be resolved with the Blade's deeplink. e.g.:- 'blade/HubsExtension/Resources/resourceType/Microsoft.Test%2Fdesktops'
     */
    async getBladeDeepLink(extensionName, bladeName, cloudName, parametersWithLeadingSlash) {
        cloudName = this.normalizeTestingCloudName(cloudName);
        parametersWithLeadingSlash = parametersWithLeadingSlash || "";
        if (!(await this.checkIfMultiCloud()) ||
            cloudName.toLowerCase().localeCompare(this.defaultCloudName.toLowerCase()) === 0) {
            return "view/" + extensionName + "/" + bladeName + parametersWithLeadingSlash;
        }
        return "view/cloudname/" + cloudName + "/" + extensionName + "/" + bladeName + parametersWithLeadingSlash;
    }
    /**
     * Get Asset deeplink.
     *
     * @param {string} extensionName extension name.
     * @param {string} assetId asset id.
     * @param {string} cloudName cloud name. Only used in framework tests.
     */
    async getAssetDeepLink(extensionName, assetId, cloudName = null) {
        cloudName = this.normalizeTestingCloudName(cloudName);
        if (!assetId.startsWith("/")) {
            assetId = "/" + assetId;
        }
        if (!(await this.checkIfMultiCloud()) ||
            cloudName.toLocaleLowerCase().localeCompare(this.defaultCloudName.toLocaleLowerCase()) === 0) {
            return "asset/" + extensionName + assetId;
        }
        return "asset/cloudname/" + cloudName + "/" + extensionName + assetId;
    }
    /**
     * check if it is MultiCloud
     */
    async checkIfMultiCloud() {
        if (!this.useMultiCloudInitialized) {
            this.useMultiCloud = await (0, RunScripts_1.runScript)("return fx.environment.features.multicloud");
            this.useMultiCloudInitialized = true;
        }
        this.useMultiCloud === null ? false : this.useMultiCloud;
        return this.useMultiCloud;
    }
    /**
     * Browse to specified asset type.
     *
     * @param {string} assetTypePluralName asset type plural name.
     * @param {number} bladeLoadTimeout optional - the amount of time to wait for the blade to load
     */
    async browseToAssetType(assetTypePluralName, bladeLoadTimeout) {
        const allBlades = this.all(Blade_1.default);
        const filteredAssetType = allBlades.filter(async (blade) => {
            return await satisfiesAssetTypeTitle(blade, assetTypePluralName);
        });
        if ((await filteredAssetType.count()) === 0) {
            await this.openAssetTypeBladeFromAllServicesOnSideBar(assetTypePluralName, null, bladeLoadTimeout);
        }
        async function satisfiesAssetTypeTitle(blade, assetTypePluralName) {
            return (await blade.titleAsync()).toLowerCase() === assetTypePluralName.toLowerCase();
        }
    }
    /**
     * Adds the specified part to the start board.
     *
     * @param {string} extensionName The name of the extension that contains the part type.
     * @param {string} partTypeName The part type to add.
     * @param {string} modelJson The JSON of the container model for the part.
     * @param {string} cloudName The cloud name of the part. Only used in framework tests.
     */
    async addPart(extensionName, partTypeName, modelJson, cloudName) {
        cloudName = this.normalizeTestingCloudName(cloudName);
        if (extensionName === PortalFxResources.hubsExtension.extensionName.name) {
            if (!modelJson) {
                modelJson = "{}";
            }
            let resultModel = JSON.parse(modelJson);
            if (await this.checkIfMultiCloud()) {
                resultModel = resultModel._msPortalFxCloudName = "cloudName";
            }
            modelJson = JSON.stringify(resultModel);
        }
        const debugFlyout = await this.getDebugFlyout();
        await debugFlyout.addPart((await this.checkIfMultiCloud()) ? cloudName + "/" + extensionName : extensionName, partTypeName, modelJson);
        try {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => !((await this.all(DebugFlyout_1.default)).length > 0), 1000, "Debug flyout should close automatically after opening a blade", "Waiting for debug flyout to close");
        }
        catch (error) {
            // if we still have the debug-flyout, that means it's running against an old version of portal
            // before the PR that close context pane when opening blade
            await debugFlyout.close();
        }
    }
    async refreshExtensions() {
        await this.registerNonLocalExtensions([]);
    }
    hasValidTestExtensionKeys(key) {
        const keysLowerCase = key.toLowerCase();
        return keysLowerCase === "name" || keysLowerCase === "uri";
    }
    // Checks if the given extension settings are ok to use for the query string method of side loading an extension.
    // The criteria for query string side loading is that there are only 2 properties and they are "name" and "uri".
    useQueryStringTestExtension(extension) {
        const keys = Object.keys(extension);
        return keys.length === 2 && keys.every(this.hasValidTestExtensionKeys) && this.isLocalExtension(extension);
    }
    /**
     * Builds various parts of the home url
     *
     * @param currentUrl the current url of the selenium driver
     * @returns The home url
     */
    buildHomeUrl(currentUrl) {
        if (!PortalConfigurationManager_1.default.configJsonPath) {
            throw new Error("No proper config json file was given!\nBy default, the config.json should be in the same folder as the test. The path to config.json can be overriden by using '--configJson' argument, 'configJson' environment variable or by using PortalConfigurationManager.setConfigJson() function before navigating to portal.");
        }
        const currentBuilder = new uriBuilder.UriBuilder(currentUrl);
        let url = this.portalContext.portalUrl;
        const tenantId = this.portalContext.tenantId;
        if (tenantId) {
            const portalUrlArray = url.replace(/^(?:http|https):\/\//, "").split("/");
            const tenantRegex = /[a-z1-9]+-[a-z1-9]+-[a-z1-9]+-[a-z1-9]+-[a-z1-9]+/;
            if (portalUrlArray[1] && tenantRegex.test(portalUrlArray[1].split("?")[0])) {
                Logger_1.default.diagnostics("Replacing tenant id in the portal url with tenant id provided in portal configuration.");
                url = url.replace(tenantRegex, tenantId);
            }
            else {
                const portalDomainUrl = portalUrlArray[0];
                url = url
                    .replace(`${portalDomainUrl}/`, portalDomainUrl)
                    .replace(portalDomainUrl, `${portalDomainUrl}/${tenantId}`);
            }
        }
        const builder = new uriBuilder.UriBuilder(url);
        Object.keys(currentBuilder.query.getParameters()).forEach((key) => {
            const value = currentBuilder.query.getParameter(key);
            builder.query.setParameter(key, value);
        });
        if (this.portalContext.sessionId) {
            builder.query.setParameter(queryStringNames.clientSessionIdName, this.portalContext.sessionId);
        }
        builder.query.setParameter(queryStringNames.testframework, "msportalfx-test");
        if (!String.isNullOrEmptyOrUndefined(this.portalContext.fakeUser)) {
            builder.query.setParameter(queryStringNames.fakeUser, this.portalContext.fakeUser);
        }
        let traceValue = "debugLog";
        const existingTraceValue = builder.query.getParameter("trace");
        if (!String.isNullOrEmptyOrUndefined(existingTraceValue) &&
            !existingTraceValue.split(",").includes(traceValue)) {
            traceValue = existingTraceValue + "," + traceValue;
        }
        builder.query.setParameter("trace", traceValue);
        builder.query.setParameter("enableAnimations", "false");
        // Build the extension string if necessary
        let extensionsString = "";
        if (this.portalContext.testExtensions) {
            this.portalContext.testExtensions.forEach((extension) => {
                // Portal doesn't accept the side loading extensions via query string that have more than 2 settings called "name" and "uri"
                if (this.useQueryStringTestExtension(extension)) {
                    extensionsString += `"${extension.name}":"${extension.uri}",`;
                }
            });
            if (extensionsString) {
                // Remove the comma at the end
                extensionsString = extensionsString.slice(0, -1);
                extensionsString = `testExtensions={${extensionsString}}`;
            }
            else {
                extensionsString = "";
            }
        }
        // Build the patch string
        let patchString = this.portalContext.patches ? JSON.stringify(this.portalContext.patches) : "";
        patchString = (patchString && `patch=${patchString}`) || "";
        // Combine the extension and patch strings together
        if (extensionsString || patchString) {
            builder.fragment = "?" + extensionsString + (extensionsString && patchString && "&") + patchString;
        }
        // Check if we need to add canModifyExtensions because we are side loading an extension or using a patch
        if (this.portalContext.testExtensions || this.portalContext.patches) {
            // Add the canmodifyextensions feature if it was not specified
            if (!this.portalContext.features) {
                this.portalContext.features = [{ name: this.canModifyExtensionsFeature, value: "true" }];
            }
            else if (!this.portalContext.features.some((feature) => {
                return feature.name === this.canModifyExtensionsFeature;
            })) {
                this.portalContext.features.push({ name: this.canModifyExtensionsFeature, value: "true" });
            }
        }
        else {
            // Remove the canmodifyextensions if it was specified
            if (this.portalContext.features) {
                for (let i = this.portalContext.features.length - 1; i >= 0; i--) {
                    if (this.portalContext.features[i].name === this.canModifyExtensionsFeature) {
                        this.portalContext.features.splice(i, 1);
                    }
                }
            }
        }
        if (this.portalContext.features) {
            this.portalContext.features.forEach((feature) => {
                builder.query.setParameter(feature.name, feature.value);
            });
        }
        const areClientOptimizationsOff = this.portalContext.features?.some((feature) => feature.name === "clientOptimizations" && feature.value === "false");
        if (areClientOptimizationsOff && this.portalContext.useSilentAuthLogin) {
            Logger_1.default.warning("Client optimizations were explicitly turned off and silent authentication was turned on. This can result in very long Portal load times during silent authentication and may time out the test. Use with caution.");
        }
        if (this.portalContext.codeCoverage) {
            builder.query.setParameter("ccCollection", "true");
            !areClientOptimizationsOff &&
                Logger_1.default.warning("Code coverage was turned on but client optimizations were not explicitly turned off. Code coverage might not get collected.");
        }
        if (this.portalContext.useSilentAuthLogin) {
            Logger_1.default.diagnostics("The portal context config 'useSilentAuthLogin' was set to 'true'. Disabling 'feature.msaljs'.");
            builder.query.setParameter("feature.msaljs", "false");
        }
        if (!this.portalContext.partnerTeamEmail) {
            throw new Error("No partner team email has been provided! The email can be specified as '--partnerTeamEmail' argument, 'partnerTeamEmail' environment variable or 'partnerTeamEmail' field in config.json. For details see http://aka.ms/portalfx/e2e-testing#partner-team-email");
        }
        builder.query.setParameter("partnerTeamEmail", this.portalContext.partnerTeamEmail);
        builder.query.setParameter("browserAutomation", this.portalContext.browserAutomation);
        return builder.toString();
    }
    async acceptUnsafeParameters() {
        if (this.portalContext["skipDismissUnsafeParametersDialog"]) {
            return;
        }
        try {
            const messageBox = await this.findMessageBox(PortalFxResources.unsafeURLParamsDialogTitle);
            await messageBox.clickButton(PortalFxResources.unsafeURLParamsDialogContinue);
        }
        catch (error) {
            Logger_1.default.information(`Could not find Dialog box which alerts that Portal was opened with query parameters. This is because either the experiment flag 'showUnsafeURLCustomizationWarning' is switched off or the test environment is 'azure-test.net', 'localhost' or 'onestb.cloudapp.net'`);
        }
        return;
    }
    async navigateTo(url, timeout) {
        const newDriver = !this.portalWebDriverInitialized;
        const navigateTimeout = timeout || this.portalContext.timeouts.extraLongTimeout;
        Logger_1.default.information(`Creating new driver: ${newDriver}`);
        const skipSignIn = PortalConfigurationManager_1.default.get("skipSignin");
        if (skipSignIn) {
            if (newDriver) {
                this.portalWebDriverInitialized = this.hasBrowser() ? true : await this.openBrowser();
                await PortalConfigurationManager_1.default.get("onOpenBrowser")?.();
            }
        }
        if (newDriver && !skipSignIn) {
            this.portalWebDriverInitialized = this.hasBrowser() ? true : await this.openBrowser();
            Logger_1.default.information(`Navigating to ${url}`);
            // boolean indicating if the silent auth succeeded
            let silentAuthComplete = false;
            if (this.portalContext.useSilentAuthLogin) {
                try {
                    // Navigate to the token URL and check if silent auth succeeds before performSignIn below
                    const token = this.portalContext.silentAuthConfig?.portalAuthUrl
                        ? this.getToken(this.portalContext.silentAuthConfig?.portalAuthUrl)
                        : "";
                    if (!String.isNullOrEmptyOrUndefined(token)) {
                        // Check the token expiry
                        const decoded = jwt.decode(token, { complete: true });
                        let payloadExpTime;
                        if (typeof decoded?.payload === "object") {
                            payloadExpTime = decoded.payload?.exp * 1000;
                        }
                        const currentTime = new Date().getTime();
                        if (currentTime >= payloadExpTime) {
                            Logger_1.default.information(`Auth token has expired. Logging in using user name and password`);
                            silentAuthComplete = false;
                        }
                        else {
                            // Token has not expired yet. Authenticating using the token
                            // Set the portal Id cookie before navigating
                            Logger_1.default.information("Performing silent auth sign in...");
                            // remove the query string and fragments from portal url to get the domain name
                            const cookieDomainName = "." + extractDomain(this.portalContext.portalUrl);
                            const cookie = {
                                name: "portalId",
                                value: this.portalContext.silentAuthConfig.portalId,
                                domain: cookieDomainName,
                                path: "/",
                            };
                            await (0, BrowserAutomation_1.runAutomation)(async (wd) => {
                                await wd.goto(url); // SELENIUM-ONLY: When adding domain-specific cookie, we need to navigate to that domain first.
                                await wd.driver.manage().addCookie(cookie);
                            }, async (pw) => await pw.context.addCookies([cookie]));
                            Logger_1.default.information(`PortalId cookie added to domain '${cookieDomainName}' added successfully`);
                            await (0, BrowserAutomation_1.getBrowser)().goto(this.portalContext.silentAuthConfig.portalAuthUrl);
                            const currentUrl = await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
                            const element = await (0, BrowserAutomation_1.getBrowser)().findElement(By_1.default.className("fxs-portal-shield-modaldialog"));
                            if (element) {
                                Logger_1.default.information("Failed to login using silent auth");
                                Logger_1.default.information("Session expired. Quitting portal and re-opening");
                                await this.quit(true);
                                this.portalWebDriverInitialized = await (0, BrowserAutomation_1.getBrowser)().create(this.portalContext);
                            }
                            else {
                                if (currentUrl &&
                                    currentUrl.includes(`${cookieDomainName.slice(1)}/?feature.msaljs=false`)) {
                                    Logger_1.default.information("Successfully signed in using silent auth...");
                                    silentAuthComplete = true;
                                    // Remove the tenantId from URL if present
                                    const tenantRegex = new RegExp('"tenantId":"' + "(.*)" + '","emailAddress"');
                                    const tenantId = tenantRegex.exec(this.portalContext.silentAuthConfig.portalAuthUrl);
                                    url = url.replace(tenantId[1], "");
                                    if (payloadExpTime - currentTime <= tokenRefreshBufferInMs) {
                                        Logger_1.default.diagnostics(`Auth token to expire in next 10 minutes. Need to force refresh the token`);
                                        await this.setNewAuthToken(false);
                                        Logger_1.default.information("Successfully saved the new auth token and portal Id cookie");
                                    }
                                }
                            }
                        }
                    }
                }
                catch (error) {
                    Logger_1.default.information(`Exception in silent auth '${error}'...`);
                }
            }
            await (0, BrowserAutomation_1.getBrowser)().goto(url, timeout);
            const currentUrl = await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
            if (this.signInUrls.some((u) => String.startsWith(currentUrl, u))) {
                Logger_1.default.information("Starting to perform sign in...");
                const { manualSignInTimeout } = this.portalContext;
                if (manualSignInTimeout) {
                    Logger_1.default.warning("************MANUAL SIGNIN!!!!!***************");
                    Logger_1.default.warning(`************Waiting up to ${manualSignInTimeout / 1000} seconds for manual sign in***************`);
                    if (this.portalContext.manualSignInEmail) {
                        const emailElement = this.element(By_1.default.css(this.liveIdEmailTextBoxCssSelector +
                            "," +
                            this.orgIdEmailTextBoxCssSelector +
                            "," +
                            this.corpEmailTextBoxCssSelector));
                        await (0, RunScripts_1.waitUntilScriptsCanExecute)();
                        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await emailElement.isDisplayed(), timeout, "Failed to detect email element", "Waiting for email element to be present");
                        await emailElement.sendKeys(this.portalContext.manualSignInEmail + "\n");
                    }
                    await this.waitForSplash(true, manualSignInTimeout);
                }
                else {
                    await this.performSignIn(timeout);
                }
                Logger_1.default.information("Successfully signed in");
                if (this.portalContext.useSilentAuthLogin && !silentAuthComplete) {
                    // run the script to get the token and save it
                    // set the portal auth url and portal id guid
                    await this.setNewAuthToken();
                }
            }
            if (!this.portalContext.testExtensions && (this.portalContext.patches || []).length === 0) {
                // We are done after sign in flow is complete and we found the Portal
                Logger_1.default.information("Already signed in, proceeding with test...");
                await this.acceptUnsafeParameters();
                return this.waitForSplashWithRetries(url, navigateTimeout);
            }
            await this.waitForPageToSettle();
            await this.acceptUnsafeParameters();
            const registeredExtensions = await this.getRegisteredExtensions(timeout);
            const dialogToTrustPromises = [];
            if (registeredExtensions.length > 0) {
                // We'll get the trusted extensions dialog. Accept it.
                dialogToTrustPromises.push(this.acceptTrustedExtensionsDialog());
            }
            else if ((this.portalContext.patches || []).length > 0) {
                // We'll get the trust untrusted patch dialog if we introduce external patches, accept it
                dialogToTrustPromises.push(this.acceptTrustedPatchDialog());
            }
            await Promise.all(dialogToTrustPromises);
            await this.waitForSplashWithRetries(url, navigateTimeout);
            const newExtensionRequested = await this.registerNonLocalExtensions(registeredExtensions);
            if (newExtensionRequested) {
                await (0, BrowserAutomation_1.getBrowser)().goto(url);
                // We expect the trusted extensions dialog only if we have no preregistered extensions
                if (registeredExtensions.length === 0) {
                    await this.acceptTrustedExtensionsDialog();
                }
                return this.waitForSplashWithRetries(url, navigateTimeout);
            }
            // If we get here, we are done
            return null;
        }
        else {
            if (!this.portalContext.testExtensions) {
                Logger_1.default.information(`Navigating to ${url}`);
                await (0, RunScripts_1.runScript)(`window.location='${url}'`);
                // We are done after the splash is gone
                return await this.waitForSplashWithRetries(url, navigateTimeout);
            }
            const currentUrl = await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
            const builder = new uriBuilder.UriBuilder(currentUrl);
            const canModifyExtensionsFeatureFound = builder.query.getParameter(this.canModifyExtensionsFeature);
            await this.waitForPageToSettle();
            const registeredExtensions = await this.getRegisteredExtensions(timeout);
            const newExtensionRequested = await this.registerNonLocalExtensions(registeredExtensions);
            if (newExtensionRequested || !canModifyExtensionsFeatureFound) {
                // Reload
                Logger_1.default.information("New extensions registered, refreshing...");
                await (0, BrowserAutomation_1.getBrowser)().goto(url);
                await (0, BrowserAutomation_1.getBrowser)().reload();
                if (!canModifyExtensionsFeatureFound) {
                    // We'll get the trusted extensions dialog. Accept it.
                    return await this.acceptTrustedExtensionsDialog();
                }
            }
            else {
                // Just update the url
                Logger_1.default.information(`Updating URL to ${url}`);
                await (0, RunScripts_1.runScript)(`window.location='${url}'`);
                try {
                    await this.acceptTrustedExtensionsDialog();
                }
                catch {
                    Logger_1.default.diagnostics(`No "${PortalFxResources.untrustedExtension}" dialog, skipping it...`);
                }
            }
            // We are done after the Portal is found and splash is gone
            await this.waitForSplashWithRetries(url, navigateTimeout);
        }
    }
    getToken(url) {
        const token = /"token":"(.*?)",/.exec(url);
        return token?.[1] ?? "";
    }
    async setNewAuthToken(tokencaching = true) {
        Logger_1.default.diagnostics(`Saving the new auth token and the portal Id cookie`);
        await this.waitForSplash(true, this.portalContext.timeouts.timeout);
        const url = await (0, RunScripts_1.runAsyncScript)(`
        var callback = arguments[arguments.length - 1];
        var uriValue = ${tokencaching} ? "/api/DelegationToken" : "/api/DelegationToken/?feature.tokencaching=false";
        MsPortalEarly.authBootstrapStatePromise.then((val) => {
            const emailAddress = val.user.emailAddress;
            const tenantId = val.user.tenantId;
            MsPortalFx.Base.Net2.postJSON({
            uri: uriValue,
            type: "POST"
            }, {
            extensionName: "HubsExtension",
            resourceName: "",
            tenant: val.user.tenantId,
            portalAuthorization: val.refreshToken,
            altPortalAuthorization: val.altRefreshToken,
            }).then((oAuthToken) => {
            var authToken = oAuthToken.value.authHeader.substring("7");
            var tokenUrl = \`domainname/signin/token?feature.msaljs=false#{"token":"\${authToken}","refresh":"\${oAuthToken.portalAuthorization}","altRefresh":"\${oAuthToken.altPortalAuthorization}","tenantId":"\${tenantId}","emailAddress":"\${emailAddress}"}\`;
            callback(tokenUrl);
            }).then((tokenUrl) => {
                return tokenUrl;
            }).catch((err) => console.error(JSON.stringify(err)));
            });
        `);
        this.portalContext.silentAuthConfig = {
            portalAuthUrl: "",
            portalId: "",
        };
        const protocolRegex = /^(?:http|https):\/\//;
        const protocol = (protocolRegex.test(this.portalContext.portalUrl) && protocolRegex.exec(this.portalContext.portalUrl)[0]) ||
            "";
        this.portalContext.silentAuthConfig.portalAuthUrl = url.replace(/domainname/, protocol + extractDomain(this.portalContext.portalUrl));
        // Save the portal Id for the user id
        this.portalContext.silentAuthConfig.portalId = (await (0, BrowserAutomation_1.runAutomation)(async (wd) => {
            const cookieVal = await wd.driver.manage().getCookie("portalId");
            return cookieVal;
        }, async (pw) => {
            const cookies = await pw.context.cookies();
            return cookies?.find((a) => a.name === "portalId");
        }))?.value?.toString();
        Logger_1.default.information("Successfully saved the new auth token and portal Id cookie");
    }
    async getRegisteredExtensions(timeout) {
        Logger_1.default.information("Getting list of registered extensions");
        let lastError = "";
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                return await (0, RunScripts_1.runAsyncScript)("var callback = arguments[arguments.length - 1]; MsPortalImpl.Extension.listTestExtensions().then((testExtensions) => { callback(testExtensions);});");
            }
            catch (err) {
                if (lastError.toString() !== err.toString()) {
                    Logger_1.default.diagnostics(`getRegisteredExtensions failed.  Error was ${err}`);
                    lastError = err;
                }
                return null;
            }
        }, timeout, "Timed out trying to get the list of registered extensions.");
    }
    async registerNonLocalExtensions(registeredExtensions) {
        let newExtensionRequested = false;
        const registrationPromises = [];
        if (!this.portalContext.testExtensions || !this.portalContext.testExtensions.length) {
            return Promise.resolve(newExtensionRequested);
        }
        const registerExtensionAsync = async (testExtension) => {
            const registrationResult = (0, RunScripts_1.runScript)(String.format("MsPortalImpl.Extension.registerTestExtension({0});", JSON.stringify(testExtension)));
            await (0, RunScripts_1.runAsyncScript)(`
                var callback = arguments[arguments.length - 1];
                await new Promise((res,rej)=>{
                    const interval = setInterval(()=>{
                        if(!!require){
                            clearInterval(interval);
                            clearTimeout(timeout);
                            res();
                        }
                    },100);
                    const timeout = setTimeout(()=>{
                        clearInterval(interval);
                        rej();
                    },${this.portalContext.timeouts.timeout});
                });
                require(["Fx/DependencyInjection","MsPortalImpl/Services/Services.Settings"],(di,sm)=>{
                    di.container.get(sm.SettingsManager).flushSettings().then(() => { return callback() });
                })`);
            return registrationResult;
        };
        this.portalContext.testExtensions.forEach((testExtension) => {
            if (!registeredExtensions?.some((preRegExtension) => {
                // Eventually we should make this do a deep equals rather than check every property manually
                const alreadyRegistered = preRegExtension.name === testExtension.name &&
                    preRegExtension.uri === testExtension.uri &&
                    preRegExtension.obsoleteBundlesBitmask === testExtension.obsoleteBundlesBitmask;
                Logger_1.default.diagnostics(`${testExtension.name} already registered? ${alreadyRegistered}`);
                return alreadyRegistered;
            })) {
                newExtensionRequested = true;
                Logger_1.default.information(`Registering non-localhost extension '${testExtension.name}'...`);
                // Register the extension if its either not a localhost extension or if its not valid to register it via query string
                if (!this.useQueryStringTestExtension(testExtension)) {
                    registrationPromises.push(registerExtensionAsync(testExtension));
                }
            }
        });
        await Promise.all(registrationPromises);
        return newExtensionRequested;
    }
    async performSignIn(timeout) {
        const getUrl = async () => await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
        Logger_1.default.information("Performing SignIn...");
        if (String.isNullOrEmptyOrUndefined(this.portalContext.signInEmail)) {
            Logger_1.default.warning("The portalContext.signInEmail is empty!");
            throw new Error("The portalContext.signInEmail must be provided!");
        }
        if (String.isNullOrEmptyOrUndefined(this.portalContext.signInPassword) && !this.portalContext.certBasedAuth) {
            Logger_1.default.warning("The portalContext.signInPassword is empty!");
            throw new Error("The portalContext.signInPassword must be provided!");
        }
        const signinDiagnostics = Logger_1.default.diagnostics.extend("signin");
        // Handle all the different login pages we have
        const emailElement = this.element(By_1.default.css(this.liveIdEmailTextBoxCssSelector +
            "," +
            this.orgIdEmailTextBoxCssSelector +
            "," +
            this.corpEmailTextBoxCssSelector));
        const passwordElement = this.element(By_1.default.css(this.liveIdPasswordTextBoxCssSelector +
            "," +
            this.orgIdPasswordTextBoxCssSelector +
            "," +
            this.corpPasswordTextBoxCssSelector));
        const submitElement = this.element(By_1.default.css(this.liveIdSubmitButtonCssSelector +
            "," +
            this.orgIdSubmitButtonCssSelector +
            "," +
            this.corpSubmitButtonCssSelector));
        const redirectElement = this.element(By_1.default.id(this.redirectDivId));
        const workAccountElement = this.element(By_1.default.id(this.workAccountTileId));
        const usernameErrorElement = this.element(By_1.default.id(this.usernameErrorId));
        const passwordErrorElement = this.element(By_1.default.id(this.passwordErrorId));
        const signInWithPassword = this.element(By_1.default.text(PortalFxResources.signInWithPassword));
        const declineButton = this.element(By_1.default.id(this.keepMeSignedInDeclineIdSelector1));
        const declineButton2 = this.element(By_1.default.id(this.keepMeSignedInDeclineIdSelector2));
        try {
            await (0, RunScripts_1.waitUntilScriptsCanExecute)();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await emailElement.isDisplayed(), timeout, "Failed to detect email element", "Waiting for email element to be present");
            Logger_1.default.information(`Entering email: ${this.portalContext.signInEmail}.`);
            await emailElement.sendKeys(this.portalContext.signInEmail + "\n");
            await (0, RunScripts_1.waitUntilScriptsCanExecute)();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                // Wait until the dots are gone
                const isPresent = await redirectElement.isPresent();
                signinDiagnostics(`Redirect/dots element isPresent=${isPresent}`);
                if (isPresent) {
                    try {
                        return await redirectElement.isNotDisplayed();
                    }
                    catch (err) {
                        // We failed to tell if the dots are displayed. So we should be done redirecting if it was going to happen.
                        return true;
                    }
                }
                // Dots are not in the dom anymore. So we should be done redirecting if it was going to happen.
                return true;
            }, 
            // Add a few more seconds to the default timeout here since the call to isNotDisplayed above will use the default timeout
            // and we want to give isNotDisplayed the chance reach the timeout before this wait() timeout is reached.
            (timeout ?? this.portalContext.timeouts.timeout) + 2000, "Redirect did not happen after entering email", "Waiting for the redirect element to be gone");
            signinDiagnostics("Checking if work account element is present");
            const isPresent = await workAccountElement.isPresent();
            if (isPresent) {
                signinDiagnostics("Found work account element, triggering click");
                await workAccountElement.click();
            }
            await (0, RunScripts_1.waitUntilScriptsCanExecute)(this.portalContext.timeouts.urlSettledTimeout);
            const foundPasswordElement = this.portalContext.certBasedAuth === true ||
                (await (0, BrowserAutomation_1.getBrowser)()
                    .wait(async () => await passwordElement.isPresent(), this.portalContext.timeouts.urlSettledTimeout, null, "Searching for password element")
                    .catch(() => false));
            let url = await getUrl();
            Logger_1.default.information("Determining authMode");
            let authMode;
            if (this.portalContext.certBasedAuth === true) {
                authMode = AuthMode.CBA;
            }
            else if (foundPasswordElement) {
                authMode = AuthMode.LiveOrOrgId;
            }
            else if (url.includes("/adfs/ls/wia")) {
                authMode = AuthMode.WIA;
            }
            else if (url.startsWith(this.corpSignInUrl)) {
                authMode = AuthMode.Corp;
            }
            else {
                throw new Error("Failed to determine authMode");
            }
            Logger_1.default.information(`Found authMode: ${AuthMode[authMode]}`);
            if (authMode === AuthMode.WIA) {
                // CORP Sign In on intranet. Multi-factor authentication is not supported.
                let currentUrl = url;
                do {
                    Logger_1.default.information(`Navigating to ${currentUrl} with auth query.`);
                    const urlWithAuth = new URL(currentUrl);
                    urlWithAuth.username = this.portalContext.signInEmail;
                    urlWithAuth.password = this.portalContext.signInPassword;
                    await (0, RunScripts_1.waitUntilScriptsCanExecute)();
                    await (0, BrowserAutomation_1.getBrowser)().goto(urlWithAuth.toString());
                    currentUrl = await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl();
                } while (currentUrl.includes("/adfs/ls"));
                url = currentUrl;
            }
            else if (authMode === AuthMode.Corp) {
                // Corpnet Sign In
                signinDiagnostics("Handling password prompt in Corpnet sign in flow.");
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    if ((await signInWithPassword.isPresent()) &&
                        (await signInWithPassword.isDisplayed().catch(() => false))) {
                        signinDiagnostics("Clicking the password button for authentication options prompt...");
                        await signInWithPassword.click();
                    }
                    return await passwordElement.isDisplayed();
                }, this.portalContext.timeouts.urlSettledTimeout, "Unable to handle password prompt in Corpnet sign-in flow.");
                await passwordElement.sendKeys(this.portalContext.signInPassword);
                await submitElement.click();
            }
            else if (authMode === AuthMode.LiveOrOrgId) {
                // Live/OrgID Sign In
                signinDiagnostics("Handling password prompt in Live/OrgId sign in flow.");
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    if ((await signInWithPassword.isPresent()) &&
                        (await signInWithPassword.isDisplayed().catch(() => false))) {
                        signinDiagnostics("Clicking the password button for authentication options prompt...");
                        await signInWithPassword.click();
                    }
                    return await passwordElement.isDisplayed();
                }, this.portalContext.timeouts.urlSettledTimeout, "Unable to find password prompt in Live/OrgId sign in flow.");
                await passwordElement.sendKeys(this.portalContext.signInPassword);
                await submitElement.click();
            }
            await (0, RunScripts_1.waitUntilScriptsCanExecute)(this.portalContext.timeouts.urlSettledTimeout);
            url = await getUrl();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                // Check for failed signin messages
                const errorElements = [usernameErrorElement, passwordErrorElement];
                const errorsPresentArray = await Promise.all(errorElements.map((element) => element.isPresent()));
                if (errorsPresentArray.some((isPresent) => isPresent === true)) {
                    const [userErrorPresent, passwordErrorPresent] = errorsPresentArray;
                    let errorMessage = `Failed to sign-in for email ${this.portalContext.signInEmail}`;
                    if (userErrorPresent) {
                        errorMessage += `\nUsername error found: ${await usernameErrorElement.getTextContent()}`;
                    }
                    if (passwordErrorPresent) {
                        errorMessage += `\nPassword error found for ${this.portalContext.signInEmail}: ${await passwordErrorElement.getTextContent()}`;
                    }
                    throw errorMessage;
                }
                return true;
            }, null, "Found some sign-in errors", "Checking for sign-in errors");
            const loginPage = this.element(By_1.default.css("meta[name = 'PageID']"));
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                if (await loginPage.isNotPresent()) {
                    return true;
                }
                const content = await loginPage.getAttribute("content");
                if (content.startsWith(this.keepMeSignedInPageId) ||
                    content.startsWith(this.keepMeSignedInPageIdAlternate)) {
                    // Chose no at the keep me signed in page
                    signinDiagnostics("Handling KMSI page.");
                    if (await declineButton.isPresent()) {
                        await declineButton.click();
                    }
                    if (await declineButton2.isPresent()) {
                        await declineButton2.click();
                    }
                    url = await this.waitForPageToSettle(url);
                    signinDiagnostics("KMSI page handled successfully.");
                    return true;
                }
                return false;
            }, this.portalContext.timeouts.longTimeout, "Couldn't handle KMSI page", "Handling KMSI page");
            url = await getUrl();
            if (this.signInUrls.some((u) => String.startsWith(url, u))) {
                throw `Browser did not redirect from STS post signin: ${decodeURI(url)}`;
            }
            if (url.toLocaleLowerCase().includes("/error/signinfailed")) {
                throw `Redirected to /error/signinfailed: ${decodeURI(url)}`;
            }
        }
        catch (reason) {
            const err = String.format("Could not Sign In to the Portal.\n{0}", errorHandling.readError(reason));
            Logger_1.default.warning(err);
            throw new Error(err);
        }
    }
    async waitForSplashGone(timeout = this.portalContext.timeouts.longTimeout) {
        Logger_1.default.information(`Waiting ${timeout} ms for the splash screen to go away...`);
        const gone = await this.waitForSplash(false, timeout);
        if (gone && this.portalContext.patchShell && this.portalContext.patches) {
            for (const patch of this.portalContext.patches) {
                Logger_1.default.information(`Executing patch URI "${patch}" script in shell...`);
                await (0, RunScripts_1.runScript)(`
                    var patch = document.createElement("script");
                    patch.src = "${patch}";
                    document.head.appendChild(patch);
                `);
            }
        }
        Logger_1.default.information(`Splash screen is gone.`);
        return gone;
    }
    async waitForSplashWithRetries(url, timeout = this.portalContext.timeouts.longTimeout) {
        let retries = 2;
        do {
            try {
                return await this.waitForSplashGone(timeout);
            }
            catch (e) {
                if (retries-- > 0 && e.message === "PageLoadTimeout") {
                    await (0, BrowserAutomation_1.getBrowser)().goto(url);
                    continue;
                }
                throw e;
            }
        } while (retries > 0);
    }
    async waitForSplash(waitForAppearence, timeout) {
        try {
            await (0, RunScripts_1.waitUntilScriptsCanExecute)();
            return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const splashScreen = this.element(SplashScreen_1.default);
                const isSplashScreenPresent = await splashScreen.isPresent();
                if (waitForAppearence) {
                    return isSplashScreenPresent;
                }
                return isSplashScreenPresent && (await splashScreen.isNotDisplayed());
            }, timeout, `Splash screen did not ${waitForAppearence ? "appear" : "go away"} after ${timeout} ms.`);
        }
        catch (e) {
            if ((await (0, BrowserAutomation_1.getBrowser)().getCurrentUrl()).includes("/Error/PageLoadTimeout")) {
                Logger_1.default.information("Page load timeout, retrying...");
                const error = new Error(`${e}`);
                error.name = "PageLoadTimeout";
                throw error;
            }
            throw e;
        }
    }
    isLocalExtension(extension) {
        return (String.startsWith(extension.uri, "http://localhost") ||
            String.startsWith(extension.uri, "https://localhost"));
    }
    async acceptPopupDialog(dialogType, timeout) {
        const splash = this.element(SplashScreen_1.default);
        Logger_1.default.information("Waiting for the splash screen...");
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await splash.isPresent(), timeout);
        const result = await (0, RunScripts_1.runScript)("return (window.fx && window.fx.environment && window.fx.environment.isDevelopmentMode) || (MsPortalFx && MsPortalFx.isDevelopmentMode);");
        // only check for and click trusted extensions when not in dev mode. in dev mode e.g onestb this dialog is not shown.
        if (!result) {
            Logger_1.default.information(`Allowing trusted ${Constants.SplashScreenDialogType[dialogType]}...`);
            return splash.clickUntrustedDialogOkButton(dialogType);
        }
    }
    async acceptTrustedExtensionsDialog(timeout) {
        Logger_1.default.information("Checking for trusted extension dialog...");
        return await this.acceptPopupDialog(Constants.SplashScreenDialogType.extension, timeout);
    }
    async acceptTrustedPatchDialog(timeout) {
        Logger_1.default.information("Checking for trusted patch dialog...");
        return await this.acceptPopupDialog(Constants.SplashScreenDialogType.patch, timeout);
    }
    /**
     * Normalize testing cloud name
     *
     * @param {string} cloudName cloud name
     */
    normalizeTestingCloudName(cloudName) {
        return cloudName ?? this.testingCloudName;
    }
    /**
     * opens the dashboard.
     *
     * @param checkTiles flag to wait for tiles
     */
    async openDashboard(checkTiles = true) {
        const openDashboardDiagnostics = Logger_1.default.diagnostics.extend("openDashboard");
        await this.navigateToUriFragment("dashboard");
        openDashboardDiagnostics("Navigation to dashboard complete");
        const startboard = this.element(StartBoard_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await startboard.isDisplayed());
        openDashboardDiagnostics("Startboard is displayed");
        if (checkTiles) {
            openDashboardDiagnostics("Waiting for tiles to load");
            await startboard.waitForAllTilesLoaded();
            openDashboardDiagnostics("Finished waiting for tiles");
        }
        return startboard;
    }
    /**
     * Gets all the opened blades on the dashboard.
     */
    async getAllBlades() {
        return await this.all(Blade_1.default).asPortalElements();
    }
    //#region BrowseOperations
    /**
     * Go to specified asset type blade through All services button on Sidebar.
     *
     * @param {string} assetTypeName asset type name.
     * @param {string} bladeTitle optional - blade title, in case assetTypeName (item text on 'All Services' blade) and blade title are different.
     * @param {number} bladeLoadTimeout optional - the amount of time to wait for the blade to load
     */
    async openAssetTypeBladeFromAllServicesOnSideBar(assetTypeName, bladeTitle, bladeLoadTimeout) {
        const sidebar = await this.getSideBar();
        await sidebar.openBrowseFlyout();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.element(SideBarBrowseFlyout_1.default)
            .isDisplayed()
            .catch(() => false), this.portalContext.timeouts.timeout, "Browse flyout was not displayed");
        const sidebarBrowseFlyoutItem = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.element(SideBarBrowseFlyout_1.default).getBrowseFlyoutItem(assetTypeName);
        });
        await sidebarBrowseFlyoutItem.click();
        Logger_1.default.information(`Verify '${assetTypeName}' blade is opened`);
        const resultantBladeThatOpens = this.blade({ title: bladeTitle || assetTypeName });
        await resultantBladeThatOpens.waitUntilBladeAndAllTilesLoaded(bladeLoadTimeout);
    }
    /**
     * Check if asset type exist.
     *
     * @param {string} assetTypePluralName asset type plural name.
     */
    async checkIfAssetTypeExists(assetTypePluralName) {
        try {
            const sidebar = await this.getSideBar();
            await sidebar.openBrowseFlyout();
            const sideBarBrowseFlyout = this.element(SideBarBrowseFlyout_1.default);
            if (!(await sideBarBrowseFlyout.isDisplayed())) {
                throw new Error("Browse flyout is not displayed");
            }
            await sideBarBrowseFlyout.getBrowseFlyoutItem(assetTypePluralName);
            return true;
        }
        catch (WebDriverException) {
            return false;
        }
    }
    //#endregion BrowseOperations
    /**
     * Gets TopBar.
     *
     * @returns an instance of TopBar Class.
     */
    getTopBar() {
        return this.element(TopBar_1.default);
    }
    /**
     * Browse to resource type using deep link.
     *
     * @param resourceType Resource type name
     * @param cloudName Cloud name. Only used in framework tests.
     */
    async browseToResourceTypeUsingDeepLink(resourceType, cloudName = null) {
        const resourceTypeLink = `BrowseResourceBlade/resourceType/${encodeURIComponent(resourceType)}`;
        await this.navigateToUriFragment(this.getResourceTypeDeepLinkFragment(resourceTypeLink, cloudName));
    }
    /**
     * Browse to asset type using deep link.
     *
     * @param assetTypePluralName Asset type plural name.
     * @param cloudName Cloud name. Only used in framework tests.
     */
    async browseToAssetTypeUsingDeepLink(assetTypePluralName, cloudName = null) {
        let browseAllBlade;
        const browseAllBladeArray = (await this.getAllBlades()).filter((blade) => {
            const promise = checkIfBladeHasExpectedTitle(blade, "Browse");
            return promise;
        });
        if (browseAllBladeArray.length > 0) {
            browseAllBlade = browseAllBladeArray[0];
        }
        else {
            browseAllBlade = null;
        }
        if (!browseAllBlade) {
            await this.navigateToUriFragment(await this.getBladeDeepLink(PortalFxResources.hubsExtension.extensionName.name, "BrowseAllBlade", cloudName));
            browseAllBlade = this.blade({ title: "Browse" });
        }
        const browseEverythingGrid = browseAllBlade.element(Grid_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await browseEverythingGrid.isDisplayed();
        }, null, "Browse grid not found in everything blade.", "Looking for browse grid in everything blade.");
        await (await browseEverythingGrid.findRow({ text: assetTypePluralName })).click();
        async function checkIfBladeHasExpectedTitle(blade, bladeTitle) {
            return (await blade.titleAsync()).toLowerCase() === bladeTitle.toLowerCase();
        }
    }
    getResourceTypeDeepLinkFragment(resourceTypeLink, cloudName) {
        cloudName = this.normalizeTestingCloudName(cloudName);
        if (!this.useMultiCloud || cloudName.toLocaleUpperCase() === this.defaultCloudName.toLocaleUpperCase()) {
            return "blade/" + PortalFxResources.hubsExtension.extensionName.name + "/" + resourceTypeLink;
        }
        else {
            return ("blade/cloudname/" +
                cloudName +
                "/" +
                PortalFxResources.hubsExtension.extensionName.name +
                "/" +
                resourceTypeLink);
        }
    }
    async getNavigationStartTime() {
        let navStartTime = -1;
        const navStartTimeObject = await (0, RunScripts_1.runScript)("return performance.timing.navigationStart");
        // If performance.timing.navigationStart not supported or we can't parse it, return -1
        const navStartTimeObjectInt = parseInt(navStartTimeObject.toString());
        if (navStartTime && isNaN(navStartTimeObjectInt)) {
            navStartTime = -1;
        }
        else {
            navStartTime = navStartTimeObjectInt;
        }
        return navStartTime;
    }
    /**
     * Gets a value indicating whether there is a StartBoard in the Portal.
     */
    async hasStartBoard() {
        return (await this.all(StartBoard_1.default).count()) > 0;
    }
    /**
     * waits for the portal to reload.
     *
     * @param actionToTriggerReload condition function which triggers reload
     */
    async waitForPortalToReload(actionToTriggerReload) {
        // Get the navigation start time so we can use it later to know when the portal has initiated a reload after resetting desktop settings
        await this.waitForPageToReload(actionToTriggerReload);
        await this.findPortal(false);
    }
    /**
     * waits for the page to reload,other than portal.
     *
     * @param actionToTriggerReload condition function which triggers the reload.
     */
    async waitForPageToReload(actionToTriggerReload) {
        let navStartTime = await this.getNavigationStartTime();
        // If we get an unparsable value then set the start time to -2 so that we don't get stuck waiting later.
        if (navStartTime === -1) {
            navStartTime = -2;
        }
        await actionToTriggerReload();
        await (0, RunScripts_1.waitUntilScriptsCanExecute)();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await (0, RunScripts_1.runScript)("return document.readyState")) === "complete");
        // Wait for the navigation start time to change so that we know when the portal has refreshed
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => navStartTime !== (await this.getNavigationStartTime()), null, "Portal did not reload after resetting desktop state.");
    }
    /**
     * Finds the portal.
     *
     * @param checkIfPartsExist True if checking for existence of parts on start board is required.
     */
    async findPortal(checkIfPartsExist = true) {
        let predicate = null;
        await (0, RunScripts_1.waitUntilScriptsCanExecute)();
        if (checkIfPartsExist) {
            predicate = async () => (await this.waitForSplashGone()) && (await this.all(Part_1.default).count()) > 0;
        }
        else {
            predicate = async () => (await this.waitForSplashGone()) && ((await this.hasStartBoard()) || (await this.hasActiveJourney()));
        }
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await predicate(), null, "Either the Portal's splash screen is still there or there are no parts in the StartBoard after the default waiting timeout.");
    }
    /**
     * Gets AvatarMenu.
     *
     * @returns an instance of AvatarMenu Class.
     */
    getAvatarMenu() {
        return this.element(AvatarMenu_1.default);
    }
    /**
     * Opens the Notifications Pane.
     *
     * @param findCustomPane flag to search for the Custom Notifications Pane rather than the portal default.
     * @returns A promise that will resolve to Notifications Pane.
     */
    async openNotificationsPane(findCustomPane) {
        const notificationsButton = this.element(NotificationsMenu_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await notificationsButton.isDisplayed()) || (await this.element(ActionsMenu_1.ActionsMenu).isDisplayed()), this.portalContext.timeouts.timeout, "Expected notificationsButton to be displayed.");
        await notificationsButton.click();
        const notificationsPane = findCustomPane
            ? this.element(NotificationsPane_2.CustomNotificationsPane)
            : this.element(NotificationsPane_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await notificationsPane.isLoading()), this.portalContext.timeouts.timeout, "Expected notifications pane to finish loading.", "Waiting for notification pane to finish loading.");
        return notificationsPane;
    }
    /**
     * Enabled or disables animations in the portal.
     *
     * @param enabled enable or disable the animations.
     */
    async enableAnimations(enabled) {
        const disableAnimationsScript = "$.enableAnimations(" + enabled + ")";
        await (0, RunScripts_1.runScript)(disableAnimationsScript);
    }
    /**
     * Returns a value that indicates if the specified blade is closed.
     *
     * @param titleOfBladeToBeClosed Title of blade to be closed.
     * @param expectedCountAfterBladeClosure the number of expected blades after the blade is closed
     */
    async waitForBladeClosure(titleOfBladeToBeClosed, expectedCountAfterBladeClosure) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allBlades = await this.getAllBlades();
            const count = allBlades.length;
            if (count === expectedCountAfterBladeClosure) {
                return true;
            }
            return false;
        }, null, `Expected Blade Count of ${expectedCountAfterBladeClosure} is not reached`);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allBlades = await this.getAllBlades();
            for (const blade of allBlades) {
                if ((await blade.titleAsync()) === titleOfBladeToBeClosed) {
                    return false;
                }
            }
            return true;
        }, null, `Blade with title '${titleOfBladeToBeClosed}' is not closed yet.`, `Waiting for blade with title '${titleOfBladeToBeClosed}' to be closed.`);
    }
    /**
     * Resets all Portal user settings to the defaults.
     *
     * @param {boolean} clearAllUserSettings feature flag to clear all user settings.
     * @returns Promise which resolves when user settings are reset.
     */
    async restoreDefaultSettings(clearAllUserSettings = true) {
        if (clearAllUserSettings) {
            await (0, RunScripts_1.runScript)("fx.environment.features.clearallusersettings = 'true'");
        }
        const allSettings = await this.all(Settings_1.SettingsFlyout);
        let settingsFlyout;
        if (allSettings.length && (await allSettings[0].isDisplayed())) {
            settingsFlyout = allSettings[0];
        }
        else {
            await this.getTopBar().clickSettings();
            settingsFlyout = this.element(Settings_1.SettingsFlyout);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await settingsFlyout.isDisplayed(), null, "Could not locate portal settings", "Looking for portal settings");
        }
        let toolbars = await settingsFlyout.all(Toolbar_1.default);
        if (!toolbars.length || !(await toolbars[0].isDisplayed())) {
            await settingsFlyout.openSettingsView(SettingsFlyout_1.SettingsViews.MyInformation);
            settingsFlyout = this.element(Settings_1.SettingsFlyout);
            toolbars = await settingsFlyout.all(Toolbar_1.default);
            if (!toolbars.length) {
                throw new Error("Could not locate the toolbar in settings to reset user settings to default");
            }
        }
        const toolbarButtons = await toolbars[0].items();
        let restoreDefaultSettingsButton;
        let btnIndex = 0;
        const expectedLabel = PortalFxResources.settingsFlyout.resetStateLabel;
        while (!restoreDefaultSettingsButton && btnIndex < toolbarButtons.length) {
            const button = toolbarButtons[btnIndex++];
            if ((await button.getTextContent()) === expectedLabel) {
                restoreDefaultSettingsButton = button;
            }
        }
        if (!restoreDefaultSettingsButton) {
            throw new Error(`Could not locate the toolbar command labeled "${expectedLabel}" while resetting user settings to default`);
        }
        await restoreDefaultSettingsButton.click();
        return await this.waitForPortalToReload(async () => await settingsFlyout.element(MessageBox_1.default).clickButton(PortalFxResources.settingsFlyout.restore));
    }
    /**
     * Get the settings flyout.
     *
     * @returns Promise which resolves to settings flyout.
     */
    async getSettingsFlyout() {
        const topBar = this.getTopBar();
        await topBar.clickSettings();
        const settingsFlyout = this.element(Settings_1.SettingsFlyout);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await settingsFlyout.isLoading()), null, "Expected settings flyout to finish loading.");
        return settingsFlyout;
    }
    /**
     * Wait for Modal Dialog
     *
     * @param {string} title Title of modal dialog.
     * @returns Promise which resolves modal dialog.
     */
    async waitForModalDialog(title = "") {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const dialog = this.element(ModalDialog_1.default);
            if (String.isNullOrEmptyOrUndefined(title) || (await dialog.getTitle()).toLocaleLowerCase() === title) {
                return dialog;
            }
            return null;
        }, null, `Couldn't find a modal dialog with the title '${title}'.`);
    }
    /**
     * Share dashboard to session repository
     *
     * @param {string} dashboardTitle Title of dashboard to be shared.
     * @returns Promise which resolves when dashboard is shared to session repository.
     */
    async shareDashboadToSessionRepository(dashboardTitle) {
        const debugFlyout = await this.getDebugFlyout();
        await debugFlyout.shareDashboardToSessionRepository(dashboardTitle);
        await debugFlyout.close();
    }
    /**
     * Get names of loaded extensions.
     *
     * @returns Promise which resolves to names of loaded extensions.
     */
    async getLoadedExtensionNames() {
        let loadedExtensions;
        try {
            const debug = await this.getDebugFlyout();
            loadedExtensions = await debug.getLoadedExtensions();
            await debug.close();
        }
        catch (error) {
            const isStaleElemRefErr = (0, BrowserAutomation_1.runAutomationSync)((wd) => {
                return error instanceof wd.error.StaleElementReferenceError;
            }, () => {
                throw new Error("Portal.getLoadedExtensionNames().isStaleElemRefErr: Not Implemented.");
            });
            if (!isStaleElemRefErr) {
                throw error;
            }
            Logger_1.default.warning("StaleElementReferenceError caught at Portal.getLoadedExtensionNames.");
            // Ignore; DebugHub counters are dynamic and grid rows change frequently
            return [];
        }
        return loadedExtensions;
    }
    /**
     * Clear dashboards from session repository
     *
     * @returns Promise which resolves when dashboards are cleared from session repository.
     */
    async clearDashboardsFromSessionRepository() {
        const debugFlyout = await this.getDebugFlyout();
        await debugFlyout.clearDashboardsFromSessionRepository();
        await debugFlyout.close();
    }
    /**
     * Drag and drop a portal element to specified coordinates.
     *
     * @param {testFx.PortalElement} source Portal elment to be drag and dropped.
     * @param {number} x coordiate of drop location.
     * @param {number} y coordiate of drop location.
     * @returns Promise which resolves when portal element is drag and dropped to specified coordinates.
     */
    async dragAndDrop(source, x, y) {
        await source.scrollIntoView();
        // Selenium won't cooperate.
        await (0, RunScripts_1.runScript)(`window.fireMouseEvent = function (type, elem, centerX, centerY) {
            var evt = document.createEvent('MouseEvents');
            evt.initMouseEvent(type, true, true, window, 1, 1, 1, centerX, centerY, false, false, false, false, 0, elem);
            evt.dataTransfer = { setData: () => { } };
            evt.originalEvent = evt;
            elem.dispatchEvent(evt);
        };`, { timeout: this.portalContext.timeouts.internalWaitForElementLocatedTimeout });
        const check = await source.getWebElements();
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => {
            // Trigger the "mouseenter" code for partgallery
            const action = wd.driver.actions();
            await action
                .mouseMove(check[0].element)
                .mouseDown()
                .perform();
        }, async (pw) => {
            const { x, y } = await check[0].getLocation();
            const { width, height } = await check[0].getSize();
            await pw.mouse.move(x + width / 2, y + height / 2);
            await pw.mouse.down();
        });
        // Trigger the dragstart event for a thumbnail
        await (0, RunScripts_1.runScript)("window.fireMouseEvent('dragstart', document.elementFromPoint(" +
            (await source.getLocation()).x +
            ", " +
            (await source.getLocation()).y +
            "), 5, 5)", { timeout: this.portalContext.timeouts.internalWaitForElementLocatedTimeout });
        // Trigger the drop event
        await (0, RunScripts_1.runScript)("window.fireMouseEvent('drop', document.body, " + x + " + 150, " + y + " + 200)", {
            timeout: this.portalContext.timeouts.internalWaitForElementLocatedTimeout,
        });
    }
    /**
     * Finds a MessageBox within the Portal.
     *
     * @param title The title of the message box to find.
     * @returns the found MessageBox.
     */
    async findMessageBox(title) {
        if (!title) {
            return this.element(MessageBox_1.default);
        }
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const messageBoxes = await this.all(MessageBox_1.default);
            for (const mb of messageBoxes) {
                if ((await mb.getTitle()).toLowerCase() === title.toLowerCase()) {
                    return mb;
                }
            }
        }, null, `Could not find a Message Box with title '${title}' in Portal.`, `Looking for message box with title '${title}'.'`);
    }
    /**
     * Drag and drop a portal element to a target element.
     *
     * @param {testFx.PortalElement} source Portal elment to be dragged.
     * @param {testFx.PortalElement} target Portal elment on which to drop.
     * @returns Promise which resolves when portal element is drag and dropped to specified coordinates.
     */
    async dragAndDropByTargetElement(source, target) {
        const location = await target.getLocation();
        await this.dragAndDrop(source, location.x, location.y);
    }
    /**
     * Waits for the provided element to be present in the Portal.
     *
     * @param element The element to wait for
     * @param timeout optional, the amount of time to wait in milliseconds.
     */
    async waitForElementPresent(element, timeout) {
        const computedTimeout = timeout || this.portalContext.timeouts.timeout;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await element.isPresent(), computedTimeout, `Element with locator '${element.locator.toString()}' was not found within the allotted timeout of ${computedTimeout} ms.  Check if the element is visible in the screenshots, in the DOM, and that you have the correct locator.
                 Also check if there are multiple elements matching the locator that may be hidden.`);
    }
    /**
     * Opens a new browser instance on an empty page.
     * NOTE: set any browser properties in portal configuration manager before opening a new browser instance.
     *
     * @throws Will throw an error if an instance of a browser already exists.
     * @returns A thruthful boolean after succesfully creating a new browser instance.
     */
    async openBrowser() {
        if (this.hasBrowser()) {
            throw new Error("Can't create a new browser instance. Please, quit existing instance before opening a new one.");
        }
        const automation = this.portalContext.browserAutomation;
        (0, BrowserAutomation_1.getBrowser)().library !== automation && (await (0, BrowserAutomation_1.setAutomation)(automation));
        Logger_1.default.information(`Using browser automation: ${automation.charAt(0).toUpperCase() + automation.slice(1).toLowerCase()}`);
        return await (0, BrowserAutomation_1.getBrowser)().create(this.portalContext);
    }
    /**
     * Waits for url to settle and for the page to be ready.
     *
     * @param initialUrl Initial url that the page should navigate away from. Initial url should be retrieved before an action that redirects to a different url.
     * @param timeout Time to wait for url to settle before throwing a timeout error.
     * @returns {string} A url that has been settled.
     */
    async waitForPageToSettle(initialUrl, timeout) {
        const shouldDelay = !initialUrl;
        timeout = timeout || this.portalContext.timeouts.urlSettledTimeout;
        let url;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            url = await this.getCurrentUrl();
            shouldDelay && (await this.delay(500));
            await (0, RunScripts_1.waitUntilScriptsCanExecute)();
            const currentUrl = await this.getCurrentUrl();
            const isUrlSettled = url === currentUrl && initialUrl !== currentUrl;
            if (!isUrlSettled) {
                return false;
            }
            const isPageReady = await (0, BrowserAutomation_1.runAutomation)(async (wd) => (await wd.executeScript("return document.readyState")) === "complete", async (pw) => (await pw.page.waitForLoadState("domcontentloaded").catch(() => false)) === undefined);
            return isPageReady;
        }, timeout, "Url did not settle", "Url settled");
        return url;
    }
}
exports.default = Portal;
/**
 * The global Portal object.
 */
// eslint-disable-next-line prefer-const
exports.portal = new Portal();
//# sourceMappingURL=Portal.js.map