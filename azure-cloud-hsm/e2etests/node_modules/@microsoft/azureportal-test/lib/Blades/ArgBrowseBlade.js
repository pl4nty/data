"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowseFilterPill = void 0;
const Blade_1 = require("./Blade");
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
const Controls_1 = require("../Controls");
const BrowserAutomation_1 = require("../BrowserAutomation");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
/**
 * Represents the base ARG browse filter pill in the portal.
 */
class BrowseFilterPill extends Controls_1.Pill {
    /**
     * Gets the filter (column) text for the pill.
     *
     * @returns Promise which resolves to the text for the filter.
     */
    async getFilterText() {
        return (await this.findTextContent("fxc-pill-content-key" /* ClassNames.filterPillKey */))?.getText();
    }
    /**
     * Gets the operator text for the pill.
     *
     * @returns Promise which resolves to the text for the operator.
     */
    async getOperatorText() {
        return (await this.findTextContent("fxc-pill-content-operator" /* ClassNames.filterPillOperator */))?.getText();
    }
    /**
     * Gets the value text for the pill.
     *
     * @returns Promise which resolves to the text for the value.
     */
    async getValueText() {
        return (await this.findTextContent("fxc-pill-content-value" /* ClassNames.filterPillValue */))?.getText();
    }
    async findTextContent(className) {
        const textContent = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const text = this.element(By_1.default.className(className));
            if (await text?.isDisplayed()) {
                return text;
            }
            return null;
        }, null, "Could not find text context of filter pill");
        return textContent;
    }
}
exports.BrowseFilterPill = BrowseFilterPill;
/**
 * Represents the base ARG browse blade in the portal.
 */
class ArgBrowseBlade extends Blade_1.default {
    /**
     * Returns the Subscription Summary Link element.
     *
     * @returns An instance of the PortalElement class wrapped in a promise.
     */
    async getSubscriptionSummaryLink() {
        const subscriptionSummaryLink = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const link = this.element(By_1.default.className("fxc-resourcefilter-subscriptionsummary" /* ClassNames.subscriptionSummaryLink */));
            if (await link?.isPresent()) {
                return link;
            }
            return null;
        }, null, "Subscription summary link not found");
        if (subscriptionSummaryLink) {
            return subscriptionSummaryLink;
        }
        throw new Error("Subscription summary link not found");
    }
    /**
     * Waits for and returns the data grid on the blade.
     *
     * @returns An instance of DataGrid class wrapped in a promise.
     */
    async waitForDataGrid() {
        const dataGrid = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const grid = this.element(Controls_1.DataGrid);
            if (await grid?.isDisplayed()) {
                return grid;
            }
            return null;
        }, null, "Datagrid is not displayed yet");
        return dataGrid;
    }
    /**
     * Returns the data grid on the blade.
     *
     * @returns An instance of DataGrid class wrapped in a promise.
     */
    async getDataGrid() {
        const dataGrid = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const grid = this.element(Controls_1.DataGrid);
            if (await grid?.isPresent()) {
                return grid;
            }
            return null;
        }, null, "Resources data grid not found on the blade.");
        if (dataGrid) {
            return dataGrid;
        }
        throw new Error("Resources data grid not found on the blade.");
    }
    /**
     * Returns the text filter on the blade.
     *
     * @returns An instance of TextField class wrapped in a promise.
     */
    async getTextFilter() {
        const textFilter = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const text = this.element(Controls_1.TextField);
            if (await text?.isPresent()) {
                return text;
            }
            return null;
        }, null, "Text filter not found on the blade.");
        if (textFilter) {
            return textFilter;
        }
        throw new Error("Text filter not found on the blade.");
    }
    /**
     * Sets the text filter on the blade to the given filter.
     *
     * @param filter The given filter string.
     * @returns Promise which resolves when complete.
     */
    async setTextFilter(filter) {
        const textFilter = await this.getTextFilter();
        await textFilter.setText(filter);
    }
    /**
     * Sets the subscriptions filter to the given subscriptions. The subscriptions will be the subscriptionId from the
     * subscription resource (GUID).
     *
     * @param subscriptions The subscription IDs for the subscription filter.
     * @returns Promise which resolves when complete.
     */
    async setSubscriptionsFilter(subscriptions) {
        await this.setFilter("Subscription", subscriptions);
    }
    async getFilterGridOptions(valueGrid) {
        const script = (arg) => `var gridRows = ko.dataFor(${arg}).data._msPortalFxInternal.visibleRows();
                return gridRows.map(function(row) {
                    return { displayName: row.cells()[0].content().text, id: row.id}
                });`;
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`${script("arguments[0]")}`, valueGrid), async () => await (await valueGrid.getWebElements())[0].executeScript(`(htmlElem) => { ${script("htmlElem")} }`));
    }
    /**
     * Gets the browse filter pill by the filter name.
     *
     * @param filterName The filter name for the filter pill.
     * @param index Optional index for multiple cases of the filter.
     * @returns Promise which resolves to the browse filter pill.
     */
    async getFilterPill(filterName, index) {
        return (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allPills = await this.all(BrowseFilterPill).asPortalElements();
            let pillIndex = index || 0;
            for (let index = 0; index < allPills.length; index++) {
                const pill = allPills[index];
                if ((await pill.isPresent()) &&
                    (await pill.getFilterText()).toUpperCase() === filterName?.toUpperCase() &&
                    pillIndex-- === 0) {
                    return pill;
                }
            }
            return null;
        }, null, `Filter pill for ${filterName} not found`);
    }
    /**
     * Sets the custom filter to the given values.
     *
     * @param filterName The filter name. The must be the display name of the column which represents this filter.
     * @param values The location IDs for the location filter.
     * @returns Promise which resolves when complete.
     */
    async setFilter(filterName, values) {
        // Find the pill.
        const filterPill = await this.getFilterPill(filterName);
        if (filterPill) {
            // Click the pill to enter edit mode
            await filterPill.click();
            const dialogEditor = await (0, BrowserAutomation_1.getBrowser)().wait(() => ElementArrayFinder_1.default.element(By_1.default.className("azc-balloon-dialog" /* ClassNames.dialogBalloon */)), null, "Unable to find popup dialog of class " + "azc-balloon-dialog" /* ClassNames.dialogBalloon */);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await dialogEditor.hasClass("azc-balloon-hidden" /* ClassNames.dialogBalloonHidden */)) === false, null, "The dialog balloon is not visible.");
            const valueGrid = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const grid = dialogEditor.element(Controls_1.Grid);
                if (await grid?.isPresent()) {
                    return grid;
                }
                return null;
            }, null, `Value grid not found`);
            if (!valueGrid) {
                throw new Error(`Value grid not found`);
            }
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await valueGrid.hasRows(), null, "Unable to load data grid");
            const options = await this.getFilterGridOptions(valueGrid);
            const optionsByText = options
                .filter((option) => values.some((value) => option.id.toLowerCase() === value.toLowerCase()))
                .map((option) => option.displayName);
            // Apply the options.
            await valueGrid.selectRows({ texts: optionsByText });
            await (0, PortalElement_1.delay)();
            await dialogEditor.all(Controls_1.SimpleButton).first().click();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await dialogEditor.hasClass("azc-balloon-hidden" /* ClassNames.dialogBalloonHidden */)) === true, null, "Unable to close dialog");
        }
        else {
            throw new Error(`${filterName} filter pill was null`);
        }
    }
    /**
     * Adds a filter pill and sets the custom filter to the given values.
     *
     * @param filterName The filter prefix. The must be the display name of the column which represents this filter.
     * @param values The location IDs for the location filter.
     * @returns Promise which resolves when complete.
     */
    async addAndSetFilter(filterName, values) {
        // Find the add pill button.
        const addFilterButton = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const button = this.element(By_1.default.className("fxc-pill-collection-add-button" /* ClassNames.pillCollectionAddButton */));
            if (await button.isPresent()) {
                return button;
            }
            return null;
        }, null, "Add filter pill button could not be found");
        if (addFilterButton) {
            await addFilterButton.click();
            await (0, PortalElement_1.delay)();
            const dialogEditor = await (0, BrowserAutomation_1.getBrowser)().wait(() => ElementArrayFinder_1.default.element(By_1.default.className("azc-balloon-dialog" /* ClassNames.dialogBalloon */)), null, "Unable to find popup dialog of class " + "azc-balloon-dialog" /* ClassNames.dialogBalloon */);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await dialogEditor.hasClass("azc-balloon-hidden" /* ClassNames.dialogBalloonHidden */)) === false, null, "The dialog balloon is not visible.");
            const dropDowns = await dialogEditor.all(Controls_1.GroupDropDownField);
            if (dropDowns.length !== 3) {
                throw new Error(`Expected 3 drop downs, but ${dropDowns.length} drop downs found`);
            }
            await dropDowns[0].selectOptionByText(filterName);
            await (0, PortalElement_1.delay)();
            await dropDowns[2].openDropDown();
            await (0, PortalElement_1.delay)();
            const options = await dropDowns[2].getOptions();
            const optionTexRegEx = /(.*)\s\(\d*\)/;
            const optionsByText = options
                .filter((option) => values.some((value) => option.value.name.toLowerCase() === value.toLowerCase()))
                .map((option) => {
                const matches = optionTexRegEx.exec(option.text) || [];
                return matches[1] || option.text;
            });
            // Apply the options.
            await dropDowns[2].selectOptionsByText(optionsByText, true /*leaveOpen*/, true /*partial*/, undefined /*timeout*/, true /*clearFilter*/);
            await (0, PortalElement_1.delay)();
            await dropDowns[2].closeDropDown();
            await (0, PortalElement_1.delay)();
            await dialogEditor.all(Controls_1.SimpleButton).first().click();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await dialogEditor.hasClass("azc-balloon-hidden" /* ClassNames.dialogBalloonHidden */)) === true, null, "Unable to close dialog");
        }
        else {
            throw new Error("Add filter pill button could not be found");
        }
    }
}
exports.default = ArgBrowseBlade;
//# sourceMappingURL=ArgBrowseBlade.js.map