"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CommandBarItem_1 = require("../Commands/CommandBarItem");
const Constants = require("../Constants");
const CommandBar_1 = require("../Controls/CommandBar");
const ContextMenu_1 = require("../Commands/ContextMenu");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const By_1 = require("../Locators/By");
const Part_1 = require("../Parts/Part");
const Tile_1 = require("../Parts/Tile");
const PortalElement_1 = require("../PortalElement");
const String = require("../Utils/String");
const BladeDialog_1 = require("./BladeDialog");
const DefaultBladeContent_1 = require("./DefaultBladeContent");
const BrowserAutomation_1 = require("../BrowserAutomation");
const PortalFxResources = require("../PortalFxResources");
const PartContainer_1 = require("../Parts/PartContainer");
const Logger_1 = require("../Logger");
const MessageBox_1 = require("../Controls/MessageBox");
const PortalConfigurationManager_1 = require("../PortalConfigurationManager");
const ResourceSummary_1 = require("./ResourceSummary");
const diagnosticsLog = Logger_1.default.diagnostics.extend("blade");
/**
 * Represents a Blade.
 */
class Blade extends PartContainer_1.PartContainer {
    constructor() {
        super(...arguments);
        this.bladeClass = "fxs-blade";
        this.titleClass = "fxs-blade-title-titleText";
        this.bladeTitleClass = "fxs-blade-title";
        this.subtitleClass = "fxs-blade-title-subtitleText";
        this.subtitleTextClass = "fxs-blade-title-subtitle";
        this.titleContentClass = "fxs-blade-title-content";
        this.closeBladeClass = "fxs-blade-close";
        this.statusBarClass = "fxs-blade-status-text";
        this.maximizedClass = "fxs-blade-maximized";
        this.minimizedClass = "fxs-blade-minimized";
        this.restoreOrMaximizeBladeButtonClass = "fxs-blade-maximizeOrRestore";
        this.pinBladeClass = "fxs-blade-pin";
        this.pinToDashboardPaneButtonCssClass = "fxs-pintodashboardpane-pinbutton";
        this.noticeHeaderClass = "fxc-notice-header";
        this.shareItBladeClass = "fxs-blade-shareit";
        this.locatorTitle = "NotProvided";
        this.locatorSubTitle = "NotProvided";
        /**
         * Gets DefaultBladeContent.
         */
        this.defaultBladeContent = this.element(DefaultBladeContent_1.default);
    }
    // Locator information for debugging
    get debugLocatorInfo() {
        return `Locator: '${this.locator.toString()}' Title: '${this.locatorTitle}' SubTitle: '${this.locatorSubTitle}'`;
    }
    /**
     * The blade title element.
     */
    get title() {
        return this.element(By_1.default.className(this.titleClass));
    }
    /**
     * Gets the title element displayed text.
     *
     * @returns Blade title.
     */
    async titleAsync() {
        let bladeTitleElement;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            bladeTitleElement = this.element(By_1.default.className(this.titleClass));
            return await bladeTitleElement.isDisplayed();
        }, null, "Title element is not displayed");
        return await bladeTitleElement.getText();
    }
    /**
     * The blade subtitle element.
     */
    get subtitle() {
        return this.element(By_1.default.className(this.subtitleClass));
    }
    /**
     * Gets the subtitle element text.
     *
     * @returns Blade subtitle.
     */
    async subtitleAsync() {
        return await this.element(By_1.default.className(this.subtitleClass)).getText();
    }
    /**
     * Gets the title element for the blade.
     */
    get titleElement() {
        return this.element(By_1.default.className(this.titleContentClass));
    }
    /**
     * The blade status bar.
     */
    get statusBar() {
        return this.element(By_1.default.className(this.statusBarClass));
    }
    /**
     * The collection of tiles that belong to this blade.
     */
    get tiles() {
        return this.all(Tile_1.default);
    }
    /**
     * The collection of command bar items that belong to this blade.
     */
    get commandBarItems() {
        return this.all(CommandBarItem_1.default);
    }
    /**
     * Gets the subtitle element text.
     *
     * @returns Blade subtitle.
     */
    async commandBarItemsAsync() {
        return await this.element(CommandBar_1.default).getItems();
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.bladeClass);
    }
    /**
     * Builds a Blade locator using the specified options.
     *
     * @param options The options used to build the locator.
     * @returns A Locator instance.
     */
    buildLocator(options) {
        if ("title" in options) {
            this.locatorTitle = options.title;
            return By_1.default.content(By_1.default.className(this.bladeClass), By_1.default.classAndText(this.titleClass, options.title));
        }
        else if ("subTitle" in options) {
            this.locatorSubTitle = options.subTitle;
            return By_1.default.xpath(`//*[contains(@class, "${this.bladeClass}") and descendant::*[contains(@class, "${this.subtitleTextClass}") and descendant::*[translate(text(),'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')="${options.subTitle.toUpperCase()}"]]]`);
        }
        return this.locator;
        //*[contains(@class, 'fxs-blade-title-titleText') and ]
    }
    /**
     * Returns a value that indicates whether the Blade has a command with the specified text.
     *
     * @param {string} commandText The text of the command.
     * @returns A promise that resolves with a value that indicates whether the Blade has the specified command.
     */
    async hasCommand(commandText) {
        const element = this.element(By_1.default.content(new CommandBarItem_1.default().locator, By_1.default.text(commandText)));
        return await element.isPresent();
    }
    /**
     * Clicks the Blade command that has the specified text.
     *
     * @param {string} commandText The text of the command.
     * @param {number} timeout? The time, in milliseconds, to wait for the command to be enabled
     * @returns A promise that resolves with this same Blade instance.
     */
    async clickCommand(commandText, timeout) {
        Logger_1.default.information(String.format("clickCommand called for '{0}' command...", commandText));
        const commandItem = await this.element(CommandBar_1.default).getItem(commandText);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await commandItem.isEnabled();
        }, timeout, String.format("Command {0} was not clicked because it was not enabled within timeout {1}.", commandText, timeout));
        Logger_1.default.information(String.format("Clicking the '{0}' command...", commandText));
        await commandItem.click();
        return this;
    }
    /**
     * Clicks the close button on the blade.
     *
     * @returns A promise that results once the close button is clicked.
     */
    async clickClose(dialogCb) {
        Logger_1.default.information("Clicking close button on blade");
        await this.element(By_1.default.className(this.closeBladeClass)).click(undefined, dialogCb);
    }
    /**
     * Clicks the pin button on the blade.
     *
     * @returns A promise that results once the pin button is clicked.
     */
    async clickPin() {
        Logger_1.default.information("Clicking pin button on blade");
        const element = this.element(By_1.default.className(this.pinBladeClass));
        await element.click();
    }
    /**
     * Clicks the ShareIt button on the blade.
     *
     * @returns A promise that results once the button is clicked.
     */
    async clickShareIt() {
        Logger_1.default.information("Clicking ShareIt button on blade");
        const element = this.element(By_1.default.className(this.shareItBladeClass));
        await element.click();
    }
    /**
     * Pins the element to dashboard.
     */
    async pinToDashBoard() {
        await this.clickPin();
        let pinToDashboardButton;
        //Wait for pin to pin pane to open
        try {
            pinToDashboardButton = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const button = ElementArrayFinder_1.default.element(By_1.default.className(this.pinToDashboardPaneButtonCssClass));
                // make sure button is available, displayed and enabled
                if ((await button.isDisplayed()) && (await button.isElementEnabled())) {
                    return button;
                }
            }, null, "Couldn't find pin pane and enabled pin button");
        }
        catch (Exception) {
            Logger_1.default.information("Old Experience doesn't need pin to dashboard pane");
        }
        if (pinToDashboardButton) {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                if (await pinToDashboardButton.isPresent()) {
                    await pinToDashboardButton.click();
                }
                return await pinToDashboardButton.isNotPresent();
            }, null, "Couldn't click pin button or it was still present after the click");
        }
    }
    /**
     * Returns a value that indicates whether the blade has been revealed (blade may be "loading" additional data in the background)
     *
     * @returns A promise that resolves with a value that indicates whether the Blade has been revealed
     */
    async isRevealed() {
        const isPresent = await this.isPresent();
        if (!isPresent) {
            return false;
        }
        diagnosticsLog(`Blade ${this.debugLocatorInfo} is present`);
        const [bladeLoadingStatusIsDisplayed, bladeProgressIsDisplayed, bladeIsDisplayed] = [
            await this.areElementsDisplayed(By_1.default.className(Constants.CssClassNames.Blades.bladeLoadingStatus), true),
            await this.areElementsDisplayed(By_1.default.className(Constants.CssClassNames.Blades.bladeProgress), true),
            await this.isDisplayed(),
        ];
        return (0, Logger_1.logIfTrue)(diagnosticsLog, !bladeLoadingStatusIsDisplayed && !bladeProgressIsDisplayed && bladeIsDisplayed, `Blade ${this.debugLocatorInfo} is revealed.`);
    }
    /**
     * Returns a value that indicates whether the blade has finished loading.
     *
     * @returns A promise that resolves with a value that indicates whether the Blade has finished loading.
     */
    async isLoaded() {
        const isRevealed = await this.isRevealed();
        if (!isRevealed) {
            return false;
        }
        const [bladeProgressBarIsDisplayed, bladeContentProgressIsDisplayed] = [
            await this.areElementsDisplayed(By_1.default.className(Constants.CssClassNames.Blades.bladeProgressBar), true),
            await this.areElementsDisplayed(By_1.default.className(Constants.CssClassNames.Blades.bladeContentProgress), true),
        ];
        diagnosticsLog(`isLoaded state: bladeProgressBarIsDisplayed is '${bladeProgressBarIsDisplayed}', bladeContentProgressIsDisplayed is '${bladeContentProgressIsDisplayed}'`);
        return (0, Logger_1.logIfTrue)(diagnosticsLog, !bladeProgressBarIsDisplayed && !bladeContentProgressIsDisplayed, `Blade ${this.debugLocatorInfo} is loaded.`);
    }
    /**
     * Gets a dialog associated to this blade and that has matches the given options.
     *
     * @param options The options used to locate the dialog.
     * @returns A BladeDialog instance that matches the specified options.
     */
    dialog(options) {
        return this.element(new BladeDialog_1.default().buildLocator(options)).asType(BladeDialog_1.default);
    }
    /**
     * Gets a Part contained in this blade that matches the given options.
     *
     * @param options The options used to locate the part.
     * @returns A Part instance that matches the specified options.
     */
    part(options) {
        const partInstance = new Part_1.default();
        const locator = partInstance.buildLocator(options);
        return this.element(locator).asType(Part_1.default);
    }
    /**
     * Returns a boolean that indicates if there is an error message in this blade.
     * Typically this appears as a rain cloud
     *
     * @returns A promise that resolves to a boolean value that indicates if the error is present.
     */
    async hasError() {
        const isErrorPartPresent = await this.isElementPresent(By_1.default.className(Constants.CssClassNames.Parts.errorPart));
        if (isErrorPartPresent) {
            return await this.isElementPresent(By_1.default.className(Constants.CssClassNames.Parts.errorPartIcon));
        }
        return false;
    }
    /**
     * Gets the text of the error message of a blade where blade.hasError() returns true.
     * The text retrieved is directly below the rain cloud icon.
     *
     * @returns A promise which returns a string, or null if there is no error
     */
    async getErrorText() {
        try {
            return await this.element(By_1.default.className(Constants.CssClassNames.Parts.errorPartReason)).getText();
        }
        catch (e) {
            return null;
        }
    }
    /**
     * Gets a field contained in this blade that matches the given options.
     *
     * @param fieldType The type of field.
     * @param options The options used to locate the field.
     * @returns An instance of the field.
     */
    field(fieldType, options) {
        const fieldInstance = new fieldType();
        const locator = fieldInstance.buildLocator(options);
        return this.element(locator).asType(fieldType);
    }
    /**
     * Waits until the blade has been revealed (blade may be "loading" additional data in the background).
     *
     * @param {number} timeout?  The time, in milliseconds, to wait for the blade to load.
     * @returns A promise that resolves with this blade instance when it has been revealed.
     */
    async waitUntilRevealed(timeout) {
        timeout = timeout ?? PortalConfigurationManager_1.default.portalContext.timeouts.urlSettledTimeout;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                return await this.isRevealed();
            }
            catch (e) {
                return false;
            }
        }, timeout, "The blade did not finish revealing within the specified timeout.");
        return this;
    }
    /**
     * Waits until the blade has finished loading.
     *
     * @param timeout  The time, in milliseconds, to wait for the blade to load.
     * @returns A promise that resolves with this blade instance when it has finished loading.
     */
    async waitUntilLoaded(timeout) {
        timeout = timeout ?? PortalConfigurationManager_1.default.portalContext.timeouts.urlSettledTimeout;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                return await this.isLoaded();
            }
            catch {
                return false;
            }
        }, timeout, `The blade with locator ${this.debugLocatorInfo} did not finish loading within the specified timeout.`);
        return this;
    }
    /**
     * Waits until all blade tiles are loaded. If the tiles have not finished loading after the specified timeout is reached, an error is thrown.
     *
     * @param {number} timeout The time, in milliseconds, to wait for the tiles to load.
     * @returns A promise that resolves with this blade instance when all tiles are loaded.
     */
    async waitForAllTilesLoaded(timeout) {
        timeout = timeout ?? PortalConfigurationManager_1.default.portalContext.timeouts.urlSettledTimeout;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const count = await this.tiles.count();
            return (0, Logger_1.logIfTrue)(diagnosticsLog, count > 0, `Found ${count} tiles on the blade ${this.debugLocatorInfo}.`);
        }, timeout);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const tiles = await this.tiles.asPortalElements();
            const loadingTiles = await tiles.reduce(async (last, tile) => {
                diagnosticsLog(`Checking if tile is loaded.`);
                const isLoaded = await (async () => {
                    try {
                        return await tile.isLoaded();
                    }
                    catch (e) {
                        return false;
                    }
                })();
                const loadingTiles = await last;
                diagnosticsLog(`Tile is loaded state ${isLoaded}.`);
                return isLoaded ? loadingTiles.concat(tile) : loadingTiles;
            }, Promise.resolve([]));
            const { length: count } = loadingTiles;
            diagnosticsLog(`Found ${count} tiles in a loading state.`);
            return tiles.length - count === 0;
        }, timeout);
        diagnosticsLog(`All tiles on the blade ${this.debugLocatorInfo} are loaded.`);
        return this;
    }
    /**
     * Waits until both the blade and all its tiles have finished loading.
     *
     * @param {number} timeout? The time, in milliseconds, to wait for the blade and tiles to load.
     * @returns  A promise that resolves with this blade instance when the blade and all tiles are loaded.
     */
    async waitUntilBladeAndAllTilesLoaded(options) {
        const parsedOptions = typeof options === "number" ? { timeout: options } : options;
        await this.waitUntilLoaded(parsedOptions?.timeout);
        const blade = await this.waitForAllTilesLoaded(parsedOptions?.timeout);
        await (0, PortalElement_1.delay)(parsedOptions?.postWaitDelay || PortalConfigurationManager_1.default.portalContext.timeouts.bladePostWaitDelay);
        return blade;
    }
    /**
     * Gets the Tile by provided title Title.
     *
     * @returns A Tile.
     */
    async getTileByText(text) {
        const allTiles = this.all(Tile_1.default);
        let filteredTiles = null;
        await allTiles.each(async (tile) => {
            const partTitle = await tile.part.getPartTitle();
            if (partTitle.toLocaleUpperCase() === text.toLocaleUpperCase()) {
                filteredTiles = tile;
            }
        });
        return filteredTiles;
    }
    async _hasButtons(buttons, actionBar) {
        let haveButtons = false;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const [actionBarFound, buttonsFound] = [
                await this._foundActionBar(actionBar),
                await this._foundButtons(buttons),
            ];
            if (actionBarFound) {
                haveButtons = false;
            }
            if (buttonsFound) {
                haveButtons = true;
            }
            return [actionBarFound, buttonsFound].some((found) => found);
        });
        return haveButtons;
    }
    _getButton(button) {
        return this.element(By_1.default.xpath(`${By_1.default.currentNodeXPathPrefix()}*[(contains(@class, 'azc-button') or contains(@class, 'fxs-button')) and text()='${button}']`));
    }
    _foundActionBar(actionBar) {
        return this.isElementDisplayed(actionBar.locator);
    }
    async _foundButtons(buttons) {
        return (await buttons.reduce(async (last, button) => {
            const results = await last;
            results.push(await this.isElementDisplayed(By_1.default.xpath(`${By_1.default.currentNodeXPathPrefix()}*[(contains(@class, 'azc-button') or contains(@class, 'fxs-button')) and text()='${button}']`)));
            return results;
        }, Promise.resolve([]))).every((result) => result);
    }
    /**
     * Gets a value indicating whether the blade is maximized or not.
     */
    async isMaximized() {
        return (await this.getAttribute("class")).includes(this.maximizedClass);
    }
    /**
     * Gets a value indicating whether the blade is in normal state.
     */
    async isMinimized() {
        return (await this.getAttribute("class")).includes(this.minimizedClass);
    }
    /**
     * Maximizes the blade.
     */
    async maximize() {
        if (await this.isMaximized()) {
            return;
        }
        const maximizeLink = this.element(By_1.default.className(this.restoreOrMaximizeBladeButtonClass));
        await maximizeLink.click();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.isMaximized(), null, "Expected the blade to be maximized after clicking the Maximize button.");
    }
    /**
     * Restores the blade to its specified size using the context menu.
     */
    async restoreUsingContextMenu() {
        await ContextMenu_1.default.openContextMenuAndClickCommand(await this.getDefaultBladeContent(), PortalFxResources.shellCommands.bladeRestore);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await this.isMinimized()) && !(await this.isMaximized()), null, `Blade did not restore to default size.  Maximized: ${await this.isMaximized()}, Minimized: ${await this.isMinimized()}`);
    }
    /**
     * Restores the blade to its specified size.
     *
     * @returns a promise that resolves after the blade is restored.
     */
    async restore() {
        if (!(await this.isMaximized()) && !(await this.isMinimized())) {
            return;
        }
        if (await this.isMinimized()) {
            await this.restoreUsingContextMenu();
            return;
        }
        const restoreLink = this.element(By_1.default.className(this.restoreOrMaximizeBladeButtonClass));
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await restoreLink.isDisplayed(), null, "Expected restore button to be visible.");
        await restoreLink.click();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await this.isMaximized()) && !(await this.isMinimized()), null, "Expected the blade to not be either maximized nor minimized after clicking the Restore button.");
    }
    /**
     * Gets DefaultBladeContent.
     *
     * @returns a promise that resolves with DefaultBladeContent.
     */
    async getDefaultBladeContent() {
        await this.waitUntilBladeAndAllTilesLoaded();
        return this.element(DefaultBladeContent_1.default);
    }
    /**
     * Opens the command bar.
     */
    findCommandBar() {
        return this.element(CommandBar_1.default);
    }
    /**
     * Finds a MessageBox within the Command Bar of the blade.
     *
     * @param title The title of the message box to find.
     * @returns the found MessageBox.
     */
    async findMessageBox(title) {
        let messageBox = null;
        if (!title) {
            messageBox = await (0, BrowserAutomation_1.getBrowser)().wait(() => this.element(MessageBox_1.default), null, "Could not find a Message Box in the command bar.");
        }
        else {
            messageBox = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const messageBoxes = await this.all(MessageBox_1.default);
                for (const mb of messageBoxes) {
                    if ((await mb.getTitle()).toLowerCase() === title.toLowerCase()) {
                        return mb;
                    }
                }
            }, null, `Could not find a Message Box with the ${title} title in the command bar.`);
        }
        return messageBox;
    }
    /**
     * Gets the blade width.
     *
     * @returns enum object of blade width.
     */
    async width() {
        return await (await this.getDefaultBladeContent()).getWidth();
    }
    /**
     * Finds the blade notice header element.
     *
     * @returns the found element.
     */
    findNoticeHeader() {
        return this.element(By_1.default.className(this.noticeHeaderClass));
    }
    /**
     * Collapses the resource summary.
     *
     * @returns a promise that resolves when ResourceSUmmary is collapsed.
     */
    async collapseResourceSummary() {
        const resourceSummary = this.element(ResourceSummary_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await resourceSummary.isLoading()), null, "resource summary cannot finish loading");
        if (await resourceSummary.isCollapsed()) {
            return;
        }
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await resourceSummary.toggle();
            return await resourceSummary.isCollapsed();
        }, null, "resource summary cannot be collapsed after user clicks the toggle button.");
    }
    /**
     * Resets the layout of the blade
     *
     * @param confirmReset value to be selected by message box.
     */
    async resetLayout(confirmReset = true) {
        await ContextMenu_1.default.openContextMenuAndClickCommand(await this.getDefaultBladeContent(), PortalFxResources.dashboard.resetToDefaultState);
        const messageBox = this.element(MessageBox_1.default);
        await messageBox.clickButton(confirmReset ? PortalFxResources.yes : PortalFxResources.no);
    }
    /**
     * Waits until the blade has no progress indicator.
     *
     * @param timeout The time to wait for the blade to load.
     * @returns The blade.
     */
    async waitUntilBladeHasNoProgressIndicator(timeout) {
        timeout = timeout ?? PortalConfigurationManager_1.default.portalContext.timeouts.urlSettledTimeout;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return !(await this.areElementsDisplayed(By_1.default.className(Constants.CssClassNames.Blades.bladeProgressBar), true));
        }, timeout, `The blade still has a progress indicator after waiting ${timeout} seconds.`);
        return this;
    }
}
exports.default = Blade;
//# sourceMappingURL=Blade.js.map