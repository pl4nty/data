"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Locator_1 = require("./Locator");
/**
 * Represents a Locator composed of other locators. The findElements function returns the elements found by the
 * last locator provided in the constructor.
 */
class ChainedLocator extends Locator_1.default {
    /**
     * Creates a new instance of this class.
     *
     * @param {Locator[]} innerLocators The collection of locators used to find elements.
     */
    constructor(innerLocators) {
        super();
        this.locators = new Array();
        innerLocators.forEach((locator) => {
            this.locators.push(locator);
        });
    }
    /**
     * Schedules a command to search for multiple elements on the page.
     *
     * @param {IBrowserAutomation | IBrowserElement} context The object used as a starting point for the search.
     * @returns An array of the webdriver.WebElement objects that were found.
     */
    findElements(context, waitUntilLocated, timeout) {
        return this.findElementsInternal(context, 0, null, waitUntilLocated, timeout).then((elements) => {
            return elements;
        });
    }
    /**
     * Gets the string representation of this locator.
     *
     * @returns The string representation of this locator.
     */
    toString() {
        let locatorString;
        this.locators.forEach((locator) => {
            if (!locatorString) {
                locatorString = locator.toString();
            }
            else {
                locatorString += ", " + locator.toString();
            }
        });
        return `By.Chained(${locatorString})`;
    }
    async findElementsInternal(context, currentIndex, elements, waitUntilLocated, timeout) {
        if (!elements) {
            return this.locators[currentIndex].findElements(context).then((innerElements) => {
                if (currentIndex + 1 === this.locators.length) {
                    return Promise.resolve(innerElements);
                }
                else {
                    return this.findElementsInternal(context, currentIndex + 1, innerElements);
                }
            });
        }
        else {
            const innerPromises = new Array();
            const currentIndexLocator = this.locators[currentIndex];
            elements.forEach((element) => {
                const innerPromise = currentIndexLocator
                    .findElements(element, waitUntilLocated, timeout)
                    .then((elements) => {
                    if (elements && elements.length > 0) {
                        if (currentIndex + 1 === this.locators.length) {
                            return elements;
                        }
                        else {
                            return this.findElementsInternal(context, currentIndex + 1, elements);
                        }
                    }
                });
                innerPromises.push(innerPromise);
            });
            const elementArrays = await Promise.all(innerPromises);
            const returnedElements = new Array();
            elementArrays.forEach((innerElements) => {
                if (innerElements) {
                    innerElements.forEach((element) => {
                        returnedElements.push(element);
                    });
                }
            });
            return returnedElements;
        }
    }
}
exports.default = ChainedLocator;
//# sourceMappingURL=ChainedLocator.js.map