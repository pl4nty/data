"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const BrowserAutomation_1 = require("../BrowserAutomation");
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
const ContextMenu_1 = require("../Commands/ContextMenu");
const resources = require("../PortalFxResources");
const Part_1 = require("./Part");
const TileSize_1 = require("./TileSize");
const Logger_1 = require("../Logger");
/**
 * Represents a Tile.
 */
class Tile extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.tileSizeClassPrefix = "fxs-tilesize-";
        /**
         * The part that lives inside this tile.
         */
        this.part = this.element(Part_1.default);
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("fxs-tile");
    }
    /**
     * Get a value that indicates whether the tile is loaded.
     *
     * @returns A promise that resolves with a value that indicates whether the tile is loaded.
     */
    async isLoaded() {
        const progressElements = this.areElementsDisplayed(By_1.default.className("fxs-tile-progress"), true);
        const progressIndicatorElements = this.areElementsDisplayed(By_1.default.className("fxs-tile-progress-transparent"), true);
        const values = await Promise.all([progressElements, progressIndicatorElements, this.element(Part_1.default).isLoaded()]);
        const [progressIsDisplayed, progressIndicatorIsDisplayed, partIsLoaded] = values;
        return !progressIsDisplayed && !progressIndicatorIsDisplayed && partIsLoaded;
    }
    /**
     * Tries to pin the tile, if the Pin command is available.
     *
     * @returns A promise that resolves when Pin command has been clicked or when the Pin command has not been found.
     */
    async tryPin() {
        const contextMenu = new ElementArrayFinder_1.default().all(ContextMenu_1.default).toPortalElement();
        Logger_1.default.information("Trying to pin tile...");
        await this.rightClick();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await contextMenu.isActive());
        const hasItem = await contextMenu.hasItem(resources.pinToDashboard);
        if (hasItem) {
            await contextMenu.clickItem(resources.pinToDashboard);
        }
    }
    /**
     * Waits until the tile has been loaded. Throws an error if the tile is not loaded when it reaches the timeout.
     *
     * @param {number} timeout Time, in milliseconds, to wait for the tile to load.
     * @returns A promise that resolves to this Tile instance when the tile has been loaded.
     */
    async waitUntilLoaded(timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.isLoaded();
        }, timeout, "Tile did not finish loading after the specified timeout.");
        return this;
    }
    /**
     * @deprecated this resize is deprecated. Use resize method from Part.ts instead.
     * Resizes the part.
     * @returns void
     */
    async resize(size) {
        const commandName = this.mapPartSizeToCommandName(size);
        await this.moveMouseAndRightClick({ x: 1, y: 1 });
        const menu = new ContextMenu_1.default();
        await menu.clickItem(commandName);
        if ((await this.part.getSizeClass()).toLocaleLowerCase() !== this.part.mapPartSizeToClassName(size)) {
            throw new Error("Tile did not resize to the expected size.");
        }
    }
    /**
     * @deprecated this getSizeClass is deprecated. Use getSizeClass method from Part.ts instead.
     * Finds size class
     * @returns  A promise that resolves with size class of tile.
     */
    async getSizeClass() {
        const sizeClasses = await this.getAttribute("class");
        const sizeClass = sizeClasses
            .trim()
            .split(" ")
            .find((className) => className.startsWith(this.tileSizeClassPrefix));
        if (!sizeClass) {
            throw new Error("Unable to find size class with prefix '" +
                this.tileSizeClassPrefix +
                "' for part.  Classes found: " +
                sizeClasses);
        }
        return sizeClass;
    }
    /**
     * Returns the command name corresponding to the specified part size.
     *
     * @param size :The part size
     * @returns The command name.
     */
    mapPartSizeToCommandName(size) {
        let sizeText = null;
        switch (size) {
            case TileSize_1.TileSize.Mini:
                sizeText = "1 x 1";
                break;
            case TileSize_1.TileSize.Small:
                sizeText = "2 x 1";
                break;
            case TileSize_1.TileSize.Normal:
                sizeText = "2 x 2";
                break;
            case TileSize_1.TileSize.Wide:
                sizeText = "4 x 2";
                break;
            case TileSize_1.TileSize.Tall:
                sizeText = "2 x 4";
                break;
            case TileSize_1.TileSize.HeroWide:
                sizeText = "6 x 4";
                break;
            case TileSize_1.TileSize.HeroTall:
                sizeText = "4 x 6";
                break;
            case TileSize_1.TileSize.Hero:
                sizeText = "6 x 6";
                break;
        }
        return sizeText;
    }
    /**
     *  @deprecated this mapPartSizeToClassName is deprecated. Use mapPartSizeToClassName method from Part.ts instead.
     *  Returns the class name corresponding to the specified part.
     * @returns The command name.
     */
    mapPartSizeToClassName(size) {
        return this.tileSizeClassPrefix.toLowerCase() + TileSize_1.TileSize[size].toLowerCase();
    }
}
exports.default = Tile;
//# sourceMappingURL=Tile.js.map