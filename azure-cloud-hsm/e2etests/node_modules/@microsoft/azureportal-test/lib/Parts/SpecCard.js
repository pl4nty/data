"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
/**
 * Represents a spec card.
 */
class SpecCard extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.specCardClassName = "msportalfx-specpicker";
        this.specCodeClassName = "msportalfx-specpicker-header-specCode";
        this.footerContainerClassName = "msportalfx-specpicker-footer";
        this.costAmountClassName = "msportalfx-specpicker-footer-value";
        this.channelMessageClassName = "msportalfx-specpicker-footer-channelMessage";
        this.uiBlockingShieldClassName = "msportalfx-specpicker-disable-blockui-shield";
        this.recommendedIconClassName = "msportalfx-specpicker-star";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.specCardClassName);
    }
    /**
     * Gets a value of spec code.
     */
    async specCode() {
        return await this.element(By_1.default.className(this.specCodeClassName)).getText();
    }
    /**
     * Checks whether cost is loaded or not.
     */
    async IsCostLoaded() {
        const footer = this.element(By_1.default.className(this.footerContainerClassName));
        const firstDiv = footer.element(By_1.default.tagName("div"));
        return (await firstDiv.getCssValue("display")) === "none";
    }
    /**
     * Gets Cost amount.
     */
    async costAmount() {
        return await this.element(By_1.default.className(this.costAmountClassName)).getText();
    }
    /**
     * Gets Cost channel message.
     */
    async channelMessage() {
        return await this.element(By_1.default.className(this.channelMessageClassName)).getText();
    }
    /**
     * Gets a value indicating if this spec card is disabled.
     */
    isDisabled() {
        try {
            this.element(By_1.default.className(this.uiBlockingShieldClassName));
        }
        catch (Exception) {
            return false;
        }
        return true;
    }
    /**
     * Returns a value that indicates whether the Recommended Icon is present or not.
     */
    async hasRecommendedIcon() {
        return await this.element(By_1.default.className(this.recommendedIconClassName)).isDisplayed();
    }
}
exports.default = SpecCard;
//# sourceMappingURL=SpecCard.js.map