"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArmClient = void 0;
const String = require("./String");
const url = require("url");
const Logger_1 = require("../Logger");
const PortalConfigurationManager_1 = require("../PortalConfigurationManager");
const identity_1 = require("@azure/identity");
const arm_resources_1 = require("@azure/arm-resources");
const portalContext = PortalConfigurationManager_1.default.portalContext;
/**
 * ArmClient is simple abstraction around @azure/arm-resources and @azure/identity to provide simple crud operations against a resource group
 */
class ArmClient {
    /**
     * creates a new ArmClient that will use the supplied resourceManagerClient
     *
     * @param resourceManagerClient a resource management client created via @azure/arm-resources module
     */
    constructor(resourceManagerClient) {
        this.maxRetries = 3;
        this.retryDelay = 10;
        this.resourceManagerClient = resourceManagerClient;
    }
    /**
     * creates an ArmClient configured with the given options
     *
     * @param {IArmClientOptions} [options]
     * @returns {Promise<ArmClient>} promise that resolves with a {ArmClient}
     */
    static createClient(options) {
        options = options || {
            aadAuthorityUrl: portalContext.aadAuthorityUrl,
            aadClientId: portalContext.aadClientId,
            aadClientSecret: portalContext.AAD_CLIENTSECRET,
            armEndpoint: portalContext.armEndpoint,
            managementEndpoint: portalContext.managementEndpoint,
            subscriptionId: portalContext.subscriptionId,
        };
        let azureEnvironmentName = portalContext.AzureEnvironment; // One of the following Azure Environments 'AzurePublicCloud', 'AzureChina', 'AzureDogfood', 'AzureGermany', 'AzureGovernment'.
        let environment; // The @azure/identity package defaults to AzurePublicCloud environment if no environment is passed in
        // For backwards compatability, check if the armEndpoint or managementEndpoint was set to dogfood
        if (options.armEndpoint.toUpperCase() ===
            ArmClient.AzureDFEnvironment.resourceManagerEndpointUrl.toUpperCase() ||
            options.managementEndpoint.toUpperCase() ===
                ArmClient.AzureDFEnvironment.managementEndpointUrl.toUpperCase()) {
            azureEnvironmentName = ArmClient.AzureDFEnvironment.name;
        }
        if (azureEnvironmentName) {
            Logger_1.default.information(`Using specified Azure Environment: '${azureEnvironmentName}'`);
            // Check if the specified environment is our own custom dogfood environment
            if (azureEnvironmentName.toUpperCase() === ArmClient.AzureDFEnvironment.name.toUpperCase()) {
                environment = ArmClient.AzureDFEnvironment;
            }
            else if (azureEnvironmentName.toUpperCase() === ArmClient.AzureStackEnvironment.name.toUpperCase()) {
                environment = portalContext.AzureStackCustomEnvironment;
            }
            else {
                // Check through the list of default supported azure environments to find the one specified
                const supportedEnvs = identity_1.AzureAuthorityHosts;
                Object.keys(supportedEnvs).forEach((key, index) => {
                    if (azureEnvironmentName.toUpperCase() === (key || "").toUpperCase()) {
                        environment = {
                            name: key,
                            resourceManagerEndpointUrl: PortalConfigurationManager_1.default.get("managementEndpoint"),
                            activeDirectoryEndpointUrl: Object.values(supportedEnvs)[index],
                        };
                    }
                });
            }
            if (environment === null) {
                throw `Unknown Azure environment '${azureEnvironmentName}' specified!`;
            }
        }
        const creds = this.clientSecretCredential(options, environment);
        let resourceManagementClient;
        if (environment) {
            resourceManagementClient = new arm_resources_1.ResourceManagementClient(creds, options.subscriptionId, {
                baseUri: environment.resourceManagerEndpointUrl,
                $host: environment.resourceManagerEndpointUrl,
            });
        }
        else {
            resourceManagementClient = new arm_resources_1.ResourceManagementClient(creds, options.subscriptionId);
        }
        return new Promise((resolve) => {
            resolve(new ArmClient(resourceManagementClient));
        });
    }
    /**
     * Creates a resource group with the given name and location
     *
     * @param {string} name is the name of the resource group to create
     * @param {string} location is the location where the resource group should be created e.g centralus
     * @param {number} [maxRetries] the number of times the client will attempt to create the resource group after failure. The default is 3.
     * @returns {Promise<{ resourceGroup: ResourceGroup }>} returns a promise that resolves when the resource group is created
     */
    async createResourceGroup(name, location, maxRetries = this.maxRetries) {
        const newResourceGroup = await this.executeWithRetries(async () => {
            Logger_1.default.information(String.format("Creating resource group '{0}' via ARM...", name));
            return await this.resourceManagerClient.resourceGroups.createOrUpdate(name, { location: location });
        }, maxRetries);
        // Wrap the result in an object that contains the "resourceGroup" object for backwards compatibility
        const retValue = {
            resourceGroup: newResourceGroup,
        };
        // Make sure the resource group got created
        return await this.executeWithRetries(async () => {
            const allResourceGroups = await this.getResourceGroups();
            const rgsStringified = JSON.stringify(allResourceGroups);
            const hasNewResourceGroup = allResourceGroups.some((resourceGroup) => {
                return resourceGroup?.name === name;
            });
            if (hasNewResourceGroup) {
                return retValue;
            }
            throw `Arm.ts > createResourceGroup > Resource group '${name}' was not found!  Please verify it was created successfully in the subscriptions deployment activity logs.  Found groups: ${rgsStringified}`;
        }, 3);
    }
    /**
     * Deletes a resource group with the specified name
     *
     * @param {string} name is the name of the resource group to delete
     * @param {number} [maxRetries] the number of times the client will attempt to delete the resource group after failure. The default is 3.
     * @returns {Promise<any>} returns a promise that resolves when the resource group is delete
     */
    async deleteResourceGroup(name, maxRetries = this.maxRetries) {
        return await this.executeWithRetries(async () => {
            const exists = (await this.resourceManagerClient.resourceGroups.checkExistence(name))?.body;
            if (exists) {
                Logger_1.default.information(String.format("Deleting resource group '{0}' via ARM...", name));
                return await this.resourceManagerClient.resourceGroups.beginDeleteAndWait(name);
            }
        }, maxRetries);
    }
    /**
     * gets the resource group for the current subscription with given name
     *
     * @param {string} [name] the name of the resource group to be found.
     * @param {number} [maxRetries] the number of times the client will attempt to list the resource groups after failure. The default is 3.
     * @returns {Promise<ResourceGroup>} returns a promise that resolves with the list of resource groups returned
     */
    async getResourceGroup(name, maxRetries = this.maxRetries) {
        return await this.executeWithRetries(async () => {
            const resourceGroup = await this.resourceManagerClient.resourceGroups.get(name);
            if (resourceGroup?.name === name) {
                return resourceGroup;
            }
            throw `Resource group '${name}' was not found!  Please verify it was created successfully in the subscriptions deployment activity logs.`;
        }, maxRetries);
    }
    /**
     * gets an array of resource groups for the current subscription
     *
     * @param {number} [maxRetries] the number of times the client will attempt to list the resource groups after failure. The default is 3.
     * @returns {Promise<ResourceGroup[]>} returns a promise that resolves with the list of resource groups returned
     */
    async getResourceGroups(maxRetries = this.maxRetries) {
        return await this.executeWithRetries(async () => {
            Logger_1.default.information("Querying resource groups via ARM...");
            const resourceGroupsIterator = this.resourceManagerClient.resourceGroups.list();
            let isDone = false;
            const allTheResourceGroups = [];
            do {
                const resourceGroupIteration = await resourceGroupsIterator.next();
                isDone = resourceGroupIteration?.done;
                allTheResourceGroups.push(resourceGroupIteration?.value);
            } while (!isDone);
            return allTheResourceGroups;
        }, maxRetries);
    }
    /**
     * creates a resource with the specified options
     *
     * @param {IResourceOptions} options specifiying the resource you wish to create
     * @param {number} [maxRetries] the number of times the client will attempt to create the resource after failure. The default is 3.
     * @returns {Promise<string>} returns a promise that resolves when the resource is created, and the returned string is the created resource's id.
     */
    async createResource(options, maxRetries = this.maxRetries) {
        return await this.executeWithRetries(async () => {
            Logger_1.default.information(String.format("Creating resource '{0}' of type '{1}' via ARM...", options.name, options.resourceType));
            const poller = await this.resourceManagerClient.resources.beginCreateOrUpdate(options.resourceGroup, options.resourceProvider, options.parentResourcePath ? options.parentResourcePath : "", options.resourceType, options.name, options.resourceProviderApiVersion, {
                properties: options.properties,
                location: options.location,
            });
            const resourceResult = await poller.pollUntilDone();
            const resourceResultStringified = JSON.stringify(resourceResult);
            if (resourceResult?.id) {
                return resourceResult.id;
            }
            throw `Arm.ts > createResource > failed to successfully create a resource: ${resourceResultStringified}`;
        }, maxRetries);
    }
    async executeWithRetries(theFunction, retries) {
        try {
            return await theFunction();
        }
        catch (reason) {
            Logger_1.default.information(`ARM function call failed with '${reason}'.`);
            if (retries > 0) {
                Logger_1.default.information(`Waiting ${this.retryDelay} seconds and retrying ${retries} more times...`);
                return new Promise((resolve) => {
                    setTimeout((() => {
                        resolve(this.executeWithRetries(theFunction, retries - 1));
                    }).bind(this), this.retryDelay * 1000);
                });
            }
            Logger_1.default.information(`ARM function call failed and no more retries are available!  Response was: '${reason}'`);
            throw reason;
        }
    }
    static clientSecretCredential(options, environment) {
        let aadTenantId = options.aadAuthorityUrl;
        // Only take the tenantId part of the url
        if (aadTenantId.lastIndexOf("http", 0) === 0) {
            // eslint-disable-next-line deprecation/deprecation
            aadTenantId = url.parse(aadTenantId).pathname.replace("/", "");
        }
        const credential = new identity_1.ClientSecretCredential(aadTenantId, options.aadClientId, options.aadClientSecret, {
            authorityHost: environment?.activeDirectoryEndpointUrl,
        });
        return credential;
    }
}
exports.ArmClient = ArmClient;
ArmClient.AzureDFEnvironment = {
    name: "AzureDogfood",
    portalUrl: "http://go.microsoft.com/fwlink/?LinkId=254433",
    managementEndpointUrl: "https://management-preview.core.windows-int.net/",
    galleryEndpointUrl: "https://df.gallery.azure-test.net/",
    publishingProfileUrl: "https://windows.azure-test.net/publishsettings/index",
    resourceManagerEndpointUrl: "https://api-dogfood.resources.windows-int.net/",
    activeDirectoryEndpointUrl: "https://login.windows-ppe.net/",
    activeDirectoryResourceId: "https://management.core.windows.net/",
    activeDirectoryGraphResourceId: "https://graph.ppe.windows.net/",
    azureDataLakeStoreFileSystemEndpointSuffix: "caboaccountdogfood.net",
    azureDataLakeAnalyticsCatalogAndJobEndpointSuffix: "konaaccountdogfood.net",
};
ArmClient.AzureStackEnvironment = {
    name: "AzureStack",
    portalUrl: "N/A",
    publishingProfileUrl: "N/A",
    managementEndpointUrl: "N/A",
    resourceManagerEndpointUrl: "N/A",
    galleryEndpointUrl: "N/A",
    activeDirectoryEndpointUrl: "https://login.windows.net/",
    activeDirectoryResourceId: "N/A",
    activeDirectoryGraphResourceId: "https://graph.windows.net/",
    activeDirectoryGraphApiVersion: "2013-11-08",
    azureDataLakeStoreFileSystemEndpointSuffix: "N/A",
    azureDataLakeAnalyticsCatalogAndJobEndpointSuffix: "N/A",
};
//# sourceMappingURL=Arm.js.map