"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throws = exports.strictEqual = exports.rejects = exports.ok = exports.notStrictEqual = exports.notEqual = exports.notDeepStrictEqual = exports.notDeepEqual = exports.match = exports.ifError = exports.fail = exports.equal = exports.doesNotThrow = exports.doesNotReject = exports.doesNotMatch = exports.deepStrictEqual = exports.deepEqual = void 0;
const assert = require("assert");
const BrowserAutomation_1 = require("../BrowserAutomation");
const PortalConfigurationManager_1 = require("../PortalConfigurationManager");
const assertTimeout = PortalConfigurationManager_1.default.portalContext.timeouts.assertTimeout;
const failMessage = "Assertion failed in";
const valOrUndef = (val) => val ?? undefined;
var AssertionError = assert.AssertionError;
/**
 * Executes `assert.deepEqual` within a timeout. See {@link assert.deepEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {unknown} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function deepEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.deepEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.deepEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.deepEqual = deepEqual;
/**
 * Executes `assert.deepStrictEqual` within a timeout. See {@link assert.deepStrictEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {object} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function deepStrictEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.deepStrictEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.deepStrictEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.deepStrictEqual = deepStrictEqual;
/**
 * Executes `assert.doesNotMatch` within a timeout. See {@link assert.doesNotMatch} for more details.
 *
 * @param {function(): string | function(): Promise<string> | string} value A string or a callback that returns a string to be tested.
 * @param {RegExp} regExp A regular expression the value string is tested against.
 * @param {string | Error} [message = "The input matched the regular expression"] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function doesNotMatch(value, regExp, message = "The input matched the regular expression", timeout = assertTimeout) {
    const functionName = "assert.doesNotMatch()";
    let resolvedValue;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedValue = await Promise.resolve(typeof value === "function" ? value() : value);
            assert.doesNotMatch(resolvedValue, regExp, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            message: `${failMessage} ${functionName}: ${message ? message.toString() : ""}\n\tRegExp: ${regExp}\n\tInput: ${resolvedValue ? resolvedValue.toString() : "UNDEFINED"}`,
        });
    }
}
exports.doesNotMatch = doesNotMatch;
async function doesNotReject(...args) {
    const functionName = "assert.doesNotReject()";
    const block = args[0];
    let error = undefined;
    let message = undefined;
    let timeout = assertTimeout;
    switch (args.length) {
        case 2:
            if (typeof args[1] === "string") {
                message = args[1];
            }
            else {
                error = args[1];
            }
            break;
        case 3:
            if (typeof args[2] === "number") {
                message = args[1];
                timeout = args[2];
            }
            else {
                error = args[1];
                message = args[2];
            }
            break;
        case 4:
            error = args[1];
            message = args[2];
            timeout = args[3];
            break;
    }
    await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
        await assert.doesNotReject(block, error, message);
        return true;
    }, timeout, `${failMessage} ${functionName}`, functionName);
}
exports.doesNotReject = doesNotReject;
async function doesNotThrow(...args) {
    const functionName = "assert.doesNotThrow()";
    const block = args[0];
    let error = undefined;
    let message = undefined;
    let timeout = assertTimeout;
    switch (args.length) {
        case 2:
            if (typeof args[1] === "string") {
                message = args[1];
            }
            else {
                error = args[1];
            }
            break;
        case 3:
            if (typeof args[2] === "number") {
                message = args[1];
                timeout = args[2];
            }
            else {
                error = args[1];
                message = args[2];
            }
            break;
        case 4:
            error = args[1];
            message = args[2];
            timeout = args[3];
            break;
    }
    await (0, BrowserAutomation_1.getBrowser)().wait(() => {
        assert.doesNotThrow(block, error, message);
        return true;
    }, timeout, `${failMessage} ${functionName}`, functionName);
}
exports.doesNotThrow = doesNotThrow;
/**
 * Executes `assert.equal` within a timeout. See {@link assert.equal} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {unknown} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function equal(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.equal()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.equal(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.equal = equal;
/**
 * Executes non-deprecated `assert.fail`. See {@link assert.fail} for more details.
 *
 * @param {string | Error} [message] An optional message to throw in case of an error.
 */
function fail(message) {
    assert.fail(message);
}
exports.fail = fail;
/**
 * Executes `assert.ifError` within a timeout. See {@link assert.ifError} for more details.
 *
 * @param {unknown} value A value or a callback that returns a value to be tested.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function ifError(value, timeout = assertTimeout) {
    const functionName = "assert.ifError()";
    let resolvedValue;
    await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
        resolvedValue = await Promise.resolve(typeof value === "function" ? value() : value);
        assert.ifError(resolvedValue);
        return true;
    }, timeout, `${failMessage} ${functionName}`, functionName);
}
exports.ifError = ifError;
/**
 * Executes `assert.match` within a timeout. See {@link assert.match} for more details.
 *
 * @param {function():  string | function(): Promise<string> | string} value A string or a callback that returns a string to be tested.
 * @param {RegExp} regExp A regular expression the value string is tested against.
 * @param {string | Error} [message = "The input matched the regular expression"] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function match(value, regExp, message = "The input matched the regular expression", timeout = assertTimeout) {
    const functionName = "assert.match()";
    let resolvedValue;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedValue = await Promise.resolve(typeof value === "function" ? value() : value);
            assert.match(resolvedValue, regExp, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            message: `${failMessage} ${functionName}: ${message ? message.toString() : ""}\n\tRegExp: ${regExp}\n\tInput: ${resolvedValue ? resolvedValue.toString() : "UNDEFINED"}`,
        });
    }
}
exports.match = match;
/**
 * Executes `assert.notDeepEqual` within a timeout. See {@link assert.notDeepEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {unknown} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function notDeepEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.notDeepEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.notDeepEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.notDeepEqual = notDeepEqual;
/**
 * Executes `assert.notDeepStrictEqual` within a timeout. See {@link assert.notDeepStrictEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {unknown} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function notDeepStrictEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.notDeepStrictEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.notDeepStrictEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.notDeepStrictEqual = notDeepStrictEqual;
/**
 * Executes `assert.notEqual` within a timeout. See {@link assert.notEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {unknown} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function notEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.notEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.notEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.notEqual = notEqual;
/**
 * Executes `assert.notStrictEqual` within a timeout. See {@link assert.notStrictEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {unknown} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function notStrictEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.notStrictEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.notStrictEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.notStrictEqual = notStrictEqual;
/**
 * Executes `assert.ok` within a timeout. See {@link assert.ok} for more details.
 *
 * @param {unknown} value A value or a callback that returns a value to be tested.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function ok(value, message, timeout = assertTimeout) {
    const functionName = "assert.ok()";
    let resolvedValue;
    await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
        resolvedValue = await Promise.resolve(typeof value === "function" ? value() : value);
        assert.ok(resolvedValue, valOrUndef(message));
        return true;
    }, timeout, `${failMessage} ${functionName}`, functionName);
}
exports.ok = ok;
async function rejects(...args) {
    const functionName = "assert.rejects()";
    const block = args[0];
    let error = undefined;
    let message = undefined;
    let timeout = assertTimeout;
    switch (args.length) {
        case 2:
            if (typeof args[1] === "string") {
                message = args[1];
            }
            else {
                error = args[1];
            }
            break;
        case 3:
            if (typeof args[2] === "number") {
                message = args[1];
                timeout = args[2];
            }
            else {
                error = args[1];
                message = args[2];
            }
            break;
        case 4:
            error = args[1];
            message = args[2];
            timeout = args[3];
            break;
    }
    await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
        await assert.rejects(block, error, message);
        return true;
    }, timeout, `${failMessage} ${functionName}`, functionName);
}
exports.rejects = rejects;
/**
 * Executes `assert.strictEqual` within a timeout. See {@link assert.strictEqual} for more details.
 *
 * @param {unknown} actual A value or a callback that returns a value to be tested.
 * @param {object} expected An expected value the actual is tested against.
 * @param {string | Error} [message] An optional message to throw in case of an error.
 * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
 */
async function strictEqual(actual, expected, message, timeout = assertTimeout) {
    const functionName = "assert.strictEqual()";
    let resolvedActual;
    try {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            resolvedActual = await Promise.resolve(typeof actual === "function" ? actual() : actual);
            assert.strictEqual(resolvedActual, expected, valOrUndef(message));
            return true;
        }, timeout, `${failMessage} ${functionName}`, functionName);
    }
    catch {
        throw new AssertionError({
            message: `${failMessage} ${functionName}` + (message ? `\n\t${message.toString()}` : ""),
            actual: " " + (resolvedActual?.toString() ?? "UNDEFINED"),
            expected: ` ${expected?.toString()}`,
        });
    }
}
exports.strictEqual = strictEqual;
async function throws(...args) {
    const functionName = "assert.throws()";
    const block = args[0];
    let error = undefined;
    let message = undefined;
    let timeout = assertTimeout;
    switch (args.length) {
        case 2:
            if (typeof args[1] === "string") {
                message = args[1];
            }
            else {
                error = args[1];
            }
            break;
        case 3:
            if (typeof args[2] === "number") {
                message = args[1];
                timeout = args[2];
            }
            else {
                error = args[1];
                message = args[2];
            }
            break;
        case 4:
            error = args[1];
            message = args[2];
            timeout = args[3];
            break;
    }
    await (0, BrowserAutomation_1.getBrowser)().wait(() => {
        assert.throws(block, error, message);
        return true;
    }, timeout, `${failMessage} ${functionName}`, functionName);
}
exports.throws = throws;
//# sourceMappingURL=Assert.js.map