"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.canPinAllBladeParts = void 0;
const ExpectedConditions = require("../ExpectedConditions");
const By_1 = require("../Locators/By");
const Logger_1 = require("../Logger");
const Portal_1 = require("../Portal");
/**
 * Verifies that all the parts in the target blade can be pinned to the dashboard and that the pinned parts load and are not
 * in an error state.
 *
 * @param {string} targetBladeDeepLink Deep link to the blade under test.
 * @param {string} targetBladeTitle The title of the blade under test.
 * @param {number} timeout The time, in milliseconds, to wait for the blade and parts to load.
 * @returns A promise that resolves with a value that indicates whether the test passed.
 */
async function canPinAllBladeParts(targetBladeDeepLink, targetBladeTitle, timeout) {
    const startBoard = await Portal_1.portal.openDashboard();
    await startBoard.reset();
    //make sure tile gallery disappeared
    const rightPane = Portal_1.portal.element(By_1.default.className("fxs-portal-contextpane-right"));
    await Portal_1.portal.wait(ExpectedConditions.doesNotHaveAttributeValue(rightPane, "class", "fxs-contextpane-visible"), 3000);
    await Portal_1.portal.navigateToUriFragment(targetBladeDeepLink, timeout);
    const blade = Portal_1.portal.blade({ title: targetBladeTitle });
    await Portal_1.portal.wait(ExpectedConditions.isPresent(blade), timeout);
    Logger_1.default.information("Pinning tiles...");
    const values = await Promise.all(await blade.tiles.map((tile) => {
        return async () => {
            try {
                await tile.waitUntilLoaded(timeout);
                await tile.tryPin();
            }
            catch {
                Logger_1.default.information("Tile " + tile.getText() + " did not finish loading");
            }
        };
    }));
    let promise = values[0]();
    for (let i = 1; i < values.length; i++) {
        promise = promise.then(values[i]);
    }
    await promise;
    await Portal_1.portal.goHome();
    const values2 = await startBoard.tiles.map((tile) => {
        return tile.waitUntilLoaded(timeout).then(() => {
            return tile.part.hasError();
        });
    });
    const anyError = values2.some((value) => {
        return value;
    });
    return !anyError;
}
exports.canPinAllBladeParts = canPinAllBladeParts;
//# sourceMappingURL=Parts.js.map