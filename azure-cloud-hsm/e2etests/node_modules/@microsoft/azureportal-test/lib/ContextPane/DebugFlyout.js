"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("../Locators/By");
const ContextPane_1 = require("./ContextPane");
const BrowserAutomation_1 = require("../BrowserAutomation");
const TabList_1 = require("../Controls/TabList");
const PortalFxResources = require("../PortalFxResources");
const TextBox_1 = require("../Controls/TextBox");
const DataGrid_1 = require("../Controls/DataGrid");
/**
 * Represents a context pane.
 */
class DebugFlyout extends ContextPane_1.default {
    constructor() {
        super(...arguments);
        this.debugFlyoutClassName = "fxs-debug-context-pane";
        this.extensionNameClass = "msportalfx-debughub-addpartform-extensionname";
        this.partTypeNameClass = "msportalfx-debughub-addpartform-parttypename";
        this.modelJsonClass = "msportalfx-debughub-addpartform-modeljson";
        this.addPartButtonClass = "msportalfx-debughub-addpartbutton";
        this.dashboardTitleClassName = "msportalfx-debughub-dashboard-title";
        this.shareDashboardButtonClassName = "msportalfx-debughub-dashboard-sharebutton";
        this.gridRowTitleClassName = "msportalfx-debughub-extensionsgrid-extname";
        this.clearDashboardButtonClassName = "msportalfx-debughub-dashboard-clearbutton";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.content(By_1.default.className("fxs-contextpane"), By_1.default.className(this.debugFlyoutClassName));
    }
    /**
     * Adds the specified part to the start board.
     *
     * @param extensionName The name of the extension that contains the part type.
     * @param partTypeName The part type to add.
     * @param modelJson The JSON of the container model for the part.
     */
    async addPart(extensionName, partTypeName, modelJson) {
        await this.goToAddPartTab();
        await this.fillValueInTextBox(this.extensionNameClass, extensionName);
        await this.fillValueInTextBox(this.partTypeNameClass, partTypeName);
        await this.fillValueInTextBox(this.modelJsonClass, modelJson, "null");
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const addPartButton = this.element(By_1.default.className(this.addPartButtonClass));
            if (await addPartButton.isDisplayed()) {
                await addPartButton.click();
                return true;
            }
        }, null, `Couldn't find the ${this.addPartButtonClass} button.`);
    }
    async fillValueInTextBox(findByClassName, value, initialValue = "") {
        const formElement = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.element(By_1.default.className(findByClassName));
        }, null, `Couldn't find the container of the text box with class ${findByClassName}.`);
        const textBox = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return formElement.element(TextBox_1.default);
        }, null, `Couldn't find the text box with class ${findByClassName}.`);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await textBox.value()) === initialValue;
        }, null, `The text box doesn't have the specified initial value.`);
        // Hubs are swallowing CTRL+A.
        const inputElement = textBox.element(By_1.default.tagName("input"));
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        await inputElement.sendKeys(Key.HOME);
        await inputElement.sendKeys(Key.SHIFT, Key.END);
        await inputElement.sendKeys(Key.BACK_SPACE);
        await textBox.clear();
        await textBox.sendKeys(value);
    }
    async goToAddPartTab() {
        const tabSelector = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.element(TabList_1.default);
        }, null, `Unable to find the tab selector to open the ${PortalFxResources.debugHubResources.addPart.buttonText} tab in the debug hub.`);
        await tabSelector.switchToTab(PortalFxResources.debugHubResources.addPart.buttonText);
    }
    async goToDashboardTab() {
        const dashboardTabName = "Dashboard";
        const tabSelector = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.element(TabList_1.default);
        }, null, `Unable to find the tab selector to open the ${dashboardTabName} tab in the debug hub.`);
        await tabSelector.switchToTab(dashboardTabName);
    }
    async goToExtensionsTab() {
        const extensionsTabName = "Extensions";
        const tabSelector = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.element(TabList_1.default);
        }, null, `Unable to find the tab selector to open the ${extensionsTabName} tab in the debug hub.`);
        await tabSelector.switchToTab(extensionsTabName);
    }
    async getExtensionsGrid() {
        return await (0, BrowserAutomation_1.getBrowser)().wait(() => this.element(DataGrid_1.default), null, "Unable to find a grid in the Debug flyout.");
    }
    /**
     * Gets loaded Extensions.
     *
     * @returns Promise of array of extension names which are loaded.
     */
    async getLoadedExtensions() {
        await this.goToExtensionsTab();
        const grid = await this.getExtensionsGrid();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const rows = await grid.rows;
            return rows.length >= 1;
        }, null, "DebugHub Extension List did not get populated.");
        const rows = await grid.rows;
        const loadedExtensions = [];
        for (const row of rows) {
            // We only want to get rows for extensions that are initialized. And we want to filter out rows for extensions
            // whose manifests have been obtained, however are currently unloaded.
            const firstCell = (await row.cells)[0];
            const result = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return ko.dataFor(arguments[0]).item.extension.initialized.peek();`, firstCell), async () => await (await firstCell.getWebElements())[0].executeScript("(htmlElem) => ko.dataFor(htmlElem).item.extension.initialized.peek()"));
            if (result) {
                const extName = await row.element(By_1.default.className(this.gridRowTitleClassName)).getText();
                if (extName && extName.length) {
                    loadedExtensions.push(extName);
                }
            }
        }
        return loadedExtensions;
    }
    /**
     * Share dashboard to session repository.
     *
     * @param {string} dashboardTitle The title of dashboard to be shared.
     * @returns Promise which resolves when dashboard is shared to session repository.
     */
    async shareDashboardToSessionRepository(dashboardTitle) {
        await this.goToDashboardTab();
        await this.fillValueInTextBox(this.dashboardTitleClassName, dashboardTitle);
        const button = await (0, BrowserAutomation_1.getBrowser)().wait(() => this.element(By_1.default.className(this.shareDashboardButtonClassName)), null, "Cannot find the share dasboard button");
        await button.click();
    }
    /**
     * Clear dashboards from session repository.
     *
     * @returns Promise which resolves when dashboards are cleared from session repository.
     */
    async clearDashboardsFromSessionRepository() {
        await this.goToDashboardTab();
        const button = await (0, BrowserAutomation_1.getBrowser)().wait(() => this.element(By_1.default.className(this.clearDashboardButtonClassName)), null, "Cannot find the clear dasboard button");
        await button.click();
    }
}
exports.default = DebugFlyout;
//# sourceMappingURL=DebugFlyout.js.map