"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("./PortalElement");
const By_1 = require("./Locators/By");
const SideBar_1 = require("./Controls/SideBar");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const ElementArrayFinder_1 = require("./ElementArrayFinder");
const BrowserAutomation_1 = require("./BrowserAutomation");
const Constants = require("./Constants");
const RunScripts_1 = require("./Utils/RunScripts");
/**
 * Represents ctrl+alt+D operations.
 */
class CtrlAltDOperations {
    /**
     * Waits until the user settings saving operation is complete.
     *
     * @param delayUntilSaveMilliseconds time in milliseconds.
     */
    static async saveSettings(delayUntilSaveMilliseconds) {
        if (~[null, undefined].indexOf(delayUntilSaveMilliseconds)) {
            delayUntilSaveMilliseconds = PortalConfigurationManager_1.default.portalContext.timeouts.timeout;
        }
        await this.performSettingsOperation("save", delayUntilSaveMilliseconds);
    }
    /**
     * Waits until the user settings clearing operation is complete.
     *
     * @param delayUntilSaveMilliseconds time in milliseconds.
     * @returns A promise that resolves when the clear settings operation is done.
     */
    static async clearSettings(delayUntilSaveMilliseconds = 5000) {
        await this.performSettingsOperation("clear", delayUntilSaveMilliseconds);
    }
    static async performSettingsOperation(operationName, delayUntilSaveMilliseconds) {
        // Note: There is currently no way to synchronize when the last write arrives in the user settings buffer
        //       ready to be flushed to the server. Compositions write their their state to the buffer in reaction to events,
        //       this sleep is a work around to have the browser run through the script in a reasonable time.
        await (0, PortalElement_1.delay)(delayUntilSaveMilliseconds);
        await this.performBrowserOperation("fxsettings" + operationName);
    }
    /**
     * Performs browser operations. e.g. save,opendebughub
     *
     * @param {string} operation Operation to perform.
     */
    static async performBrowserOperation(operation) {
        const linkId = operation;
        const pendingId = linkId + "pending";
        const timeoutInSeconds = 20;
        // Open debug helper
        await CtrlAltDOperations.ctrlAltD();
        // Wait until debug helper is visible
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            // If debugBox open by previous CtrlAltD op, then skip and return.
            try {
                const debugBoxExist = ElementArrayFinder_1.default.element(By_1.default.className(Constants.CssClassNames.Debugbox.stickyDebugBox));
                if (await debugBoxExist.isDisplayed()) {
                    return true;
                }
            }
            catch {
                // If debugBox not found, do the further CtrlAltD op to make it visible.
            }
            // Open debug helper
            await CtrlAltDOperations.ctrlAltD();
            const debugBox = ElementArrayFinder_1.default.element(By_1.default.className(Constants.CssClassNames.Debugbox.stickyDebugBox));
            if (await debugBox.isDisplayed()) {
                return true;
            }
        }, null, "Debug box not found.");
        // Click the command
        const saveSettingsLink = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const saveSettingsLink = ElementArrayFinder_1.default.element(By_1.default.id(linkId));
            if (await saveSettingsLink.isDisplayed()) {
                return saveSettingsLink;
            }
            else {
                return false;
            }
        }, null, "SaveSettings link not found");
        await saveSettingsLink.click();
        // Wait until the command completes
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const getPendingId = ElementArrayFinder_1.default.all(By_1.default.id(pendingId));
            if ((await getPendingId.count()) === 0) {
                return true;
            }
        }, timeoutInSeconds * 1000, `Portal operation ${linkId} did not complete after ${timeoutInSeconds} seconds`);
        // Wait until debug helper is hidden
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            // Close debug helper
            await CtrlAltDOperations.ctrlAltD();
            const debugBox = ElementArrayFinder_1.default.all(By_1.default.className(Constants.CssClassNames.Debugbox.stickyDebugBox));
            return (await debugBox.count()) === 0;
        }, null, "Debug box not dismissed.");
    }
    static async ctrlAltD() {
        const sideBar = ElementArrayFinder_1.default.element(SideBar_1.default);
        if (await sideBar.inDockedMode()) {
            await (0, RunScripts_1.runScript)("document.querySelector('.fxs-sidebar-collapse-button').focus()");
        }
        else {
            await (0, RunScripts_1.runScript)("document.querySelector('.fxs-topbar-sidebar-collapse-button').focus()");
        }
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        await (0, BrowserAutomation_1.getBrowser)().sendKeys(Key.CONTROL, Key.ALT, "d", Key.NULL);
    }
    /**
     * Opens debug hub by performing browser operation
     */
    static async openDebugHub() {
        await CtrlAltDOperations.performBrowserOperation(Constants.BrowserOperations.openDebugHub);
    }
    /**
     * Close debug box using Ctrl+Alt+D
     *
     * @returns Promise when debug box is closed.
     */
    static async closeDebugBox() {
        // Wait until debug helper is hidden
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            // Close debug helper
            try {
                const debugBox = ElementArrayFinder_1.default.element(By_1.default.className(Constants.CssClassNames.Debugbox.stickyDebugBox));
                if (await debugBox.isDisplayed()) {
                    await CtrlAltDOperations.ctrlAltD();
                    const debugBoxes = ElementArrayFinder_1.default.all(By_1.default.className(Constants.CssClassNames.Debugbox.stickyDebugBox));
                    if ((await debugBoxes.count()) === 0) {
                        return true;
                    }
                }
            }
            catch {
                // If debugBox not found, this is no-op.
            }
            return true;
        }, null, "Debug box not dismissed.");
    }
}
exports.default = CtrlAltDOperations;
//# sourceMappingURL=CtrlAltDOperations.js.map