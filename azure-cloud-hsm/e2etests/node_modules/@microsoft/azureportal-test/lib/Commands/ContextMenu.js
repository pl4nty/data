"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("../Locators/By");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const PortalElement_1 = require("../PortalElement");
const ContextMenuItem_1 = require("./ContextMenuItem");
const BrowserAutomation_1 = require("../BrowserAutomation");
const ConfirmationAlertAction_1 = require("../ConfirmationAlertAction");
/**
 * Represents a context menu.
 */
class ContextMenu extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        /**
         * The collection of items that belong to this context menu.
         */
        this.items = this.all(ContextMenuItem_1.default);
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("fxs-commands-contextMenu");
    }
    /**
     * Returns a value that indicates whether the ContextMenu is in active state.
     *
     * @returns A promise that resolves with a value that indicates whether the Context Menu is in active state.
     */
    async isActive() {
        return await this.hasAttributeValue("class", "fxs-contextMenu-active");
    }
    /**
     * Returns the ContextMenuItem that corresponds to the specified text.
     *
     * @param {text?} options The options used to find the ContextMenuItem.
     * @returns The ContextMenuItem.
     */
    item(options) {
        const locator = new ContextMenuItem_1.default().buildLocator(options);
        return this.element(locator).asType(ContextMenuItem_1.default);
    }
    /**
     * Returns a value that specifies whether the specified item exists in this context menu.
     *
     * @param {string} text The item text.
     * @returns A promise that resolves with a value that specifies whether the specified item exists in this context menu.
     */
    async hasItem(text) {
        return await this.items.some((item) => {
            return item.getText().then((itemText) => {
                return itemText === text;
            });
        });
    }
    /**
     * Clicks the specified item.
     *
     * @param {string} text The text of the item to click.
     * @returns A promise that resolves when the item has been clicked.
     */
    async clickItem(text) {
        return await (0, BrowserAutomation_1.getBrowser)()
            .wait(async () => {
            const values = await Promise.all([this.isActive(), this.item({ text: text }).isEnabled()]);
            return values[0] && values[1];
        }, null, `Requested context menu item '${text}' was either not found or not enabled.`)
            .then(async () => {
            return await this.item({ text: text }).click();
        });
    }
    /**
     * Opens the ContextMenu and click Command.
     *
     * @param {PortalElement} portalElement on which context menu to be open.
     * @param {string} contextMenuItemText command text.
     * @param opt_offset optional, location to right click on a specific location
     * @param action action to perform when a confirmation alter is shown.
     */
    static async openContextMenuAndClickCommand(portalElement, contextMenuItemText, opt_offset, action = ConfirmationAlertAction_1.ConfirmationAlertAction.None) {
        const contextMenu = await this.openContextMenu(portalElement, opt_offset);
        await contextMenu.clickItem(contextMenuItemText);
        // Some commands e.g. unpin could cause the 'discard edits' popup to appear. The below code gracefully
        // handles the popup based on the expected behavior.
        if (action !== ConfirmationAlertAction_1.ConfirmationAlertAction.None) {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const alertMessage = await (0, BrowserAutomation_1.getBrowser)().getAlertText();
                if (alertMessage) {
                    if (action === ConfirmationAlertAction_1.ConfirmationAlertAction.Accept) {
                        await (0, BrowserAutomation_1.getBrowser)().acceptAlert();
                    }
                    else {
                        await (0, BrowserAutomation_1.getBrowser)().dismissAlert();
                    }
                }
                return alertMessage.length > 0;
            }, null, "alert text not loaded..!");
        }
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return !(await contextMenu.isActive());
        }, null, "The context menu never closed.");
    }
    /**
     * Opens the ContextMenu.
     *
     * @param {PortalElement} portalElement on which context menu to be open.
     * @param opt_offset optional, location to right click on a specific location
     * @returns Returns the contextMenu.
     */
    static async openContextMenu(portalElement, opt_offset) {
        let contextMenu;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await portalElement.scrollIntoView();
            await portalElement.moveMouseAndRightClick(opt_offset);
            contextMenu = ElementArrayFinder_1.default.element(ContextMenu);
            return await contextMenu.isActive();
        }, null, "Context menu not active yet");
        return contextMenu;
    }
    /**
     * Finds the context menu item by the full text. It is case insensitive.
     *
     * @param {string} itemText Item name to be searched in context menu.
     * @returns The ContextMenuItem.
     */
    async findContextMenuItemByText(itemText) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const contextMenuItem = this.items.filter((menuItem) => {
                const promise = menuItem.hasExpectedTextAndIsEnabled(itemText);
                return promise;
            });
            const contextMenuItemAsPortalElements = await contextMenuItem.asPortalElements();
            if (contextMenuItemAsPortalElements.length > 1) {
                throw new Error("More than one MenuItems found.");
            }
            if (contextMenuItemAsPortalElements.length === 1) {
                return contextMenuItemAsPortalElements[0];
            }
            if (contextMenuItemAsPortalElements.length === 0) {
                return null;
            }
        }, null, `Could not find the '${itemText}' context menu commmand or it is not enabled`);
    }
}
exports.default = ContextMenu;
//# sourceMappingURL=ContextMenu.js.map