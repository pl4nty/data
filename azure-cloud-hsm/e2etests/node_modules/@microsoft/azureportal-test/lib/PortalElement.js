"use strict";
/**
 * ------------------------------------------- START OF THIRD PARTY NOTICE -----------------------------------------
 * This file is based on or incorporates material from the projects listed below (Third Party IP).The original copyright notice and the license under which Microsoft received such Third Party IP, are set forth below.Such licenses and notices are provided for informational purposes only.Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.
 *
 * angular - protractor v3.0
 * Copyright(c) 2010- 2015 Google, Inc.
 *
 * Provided for Informational Purposes Only
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ----------------------------------------------- END OF THIRD PARTY NOTICE ------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.delay = exports.retry = void 0;
const Locators_1 = require("./Locators");
const Accessibility_1 = require("./Accessibility");
const ElementArrayFinder_1 = require("./ElementArrayFinder");
const Logger_1 = require("./Logger");
const ReactView_1 = require("./Utils/ReactView");
const String = require("./Utils/String");
const BrowserAutomation_1 = require("./BrowserAutomation");
const PlaywrightErrors_1 = require("./PlaywrightErrors");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const diagnosticsLog = Logger_1.default.diagnostics.extend("PortalElement");
const retryLog = Logger_1.default.diagnostics.extend("retry");
/**
 * Wrap a browser automation browser access call in a retry.
 *
 * @param webElem this to apply to the function
 * @param cb a function to wrap in a retry
 * @returns A function that will return a promise with a retry for a browser automation call
 */
const retry = (webElem, cb, fnName) => {
    const fnc = async (retry, ...args) => {
        try {
            const text = await cb.apply(webElem, args);
            return text;
        }
        catch (err) {
            if (retry <= 0) {
                throw err;
            }
            else {
                retryLog(`${fnName ? fnName + ": " : ""}Caught error on retry:\n    ${err}`);
                return await fnc(--retry, ...args);
            }
        }
    };
    return (...args) => fnc(3, ...args);
};
exports.retry = retry;
/**
 * Delays execution for the specified amount of time.
 *
 * @param ms The amount of time to delay, in milliseconds. Defaults to delayTimeout.
 * @returns A promise that will be resolved after the specified amount of time has passed.
 */
async function delay(ms) {
    const delayTimeout = ms ?? PortalConfigurationManager_1.default.portalContext.timeouts.delayTimeout;
    return await new Promise((resolve) => setTimeout(resolve, delayTimeout));
}
exports.delay = delay;
/**
 * Represents a single element of an ElementArrayFinder.
 */
class PortalElement {
    /**
     * Creates a PortalElement from the specified IBrowserElement.
     *
     * @param {IBrowserElement} webElem The IBrowserElement.
     * @param {Locator} locator Reference locator originaly used to find the IBrowserElement.
     * @param {elementArrayFinder} elementType The type of PortalElement from which the locator was extracted.
     * @param frameId The frame identifier to look search from.
     * @returns The PortalElement.
     */
    static fromWebElement(webElem, locator, elementType, frameId) {
        const getWebElements = () => {
            return Promise.resolve([webElem]);
        };
        return new ElementArrayFinder_1.default({ getWebElements, locator, elementType, frameId }).toPortalElement();
    }
    /**
     * Creates a new instance of this class.
     *
     * @param elementArrayFinder The ElementArrayFinder used to locate elements.
     */
    constructor(elementArrayFinder, frameId) {
        this.frameId = frameId;
        if (!elementArrayFinder) {
            elementArrayFinder = new ElementArrayFinder_1.default().all(this.locator);
        }
        this.parentElementArrayFinder = elementArrayFinder;
        const getWebElements = (wait = true) => {
            return Promise.resolve((async () => {
                const webElements = await elementArrayFinder.getWebElements(wait);
                if (webElements.length === 0) {
                    (0, BrowserAutomation_1.runAutomationSync)((wd) => {
                        throw new wd.error.NoSuchElementError(`No element found using locator: ${elementArrayFinder.locator?.toString()}`);
                    }, () => {
                        throw new PlaywrightErrors_1.PlaywrightNoSuchElementError(`No element found using locator: ${elementArrayFinder.locator?.toString()}`);
                    });
                }
                else {
                    if (webElements.length > 1) {
                        diagnosticsLog(`More than one element found for locator ${elementArrayFinder.locator?.toString()}, the first result will be used`);
                    }
                    this.webElement = webElements[0];
                    return [webElements[0]];
                }
            })());
        };
        this.elementArrayFinder = new ElementArrayFinder_1.default({
            getWebElements,
            locator: elementArrayFinder.locator,
            actionResults: elementArrayFinder.actionResults,
            frameId,
        });
    }
    /**
     * Gets the name of the class constructor (typescript, not html class).  May not work if javascript is minified
     *
     * @returns The name of the class constrcutor
     */
    get constructorName() {
        return this.constructor.name;
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return this.elementArrayFinder.locator;
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    buildLocator(_options) {
        throw new Error("PortalElement.buildLocator(): Not implemented.");
    }
    /**
     * Gets a PortalElement that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns A PortalElement that matches the specified sub locator or element type.
     */
    find(subLocatorOrElementType, locatorOptions) {
        return Promise.resolve(this.element(subLocatorOrElementType, locatorOptions));
    }
    /**
     * Gets PortalElements that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns An ElementArrayFinder that matches the specified sub locator or element type.
     */
    async findAll(subLocatorOrElementType, locatorOptions) {
        const elements = await this.all(subLocatorOrElementType, locatorOptions).asPortalElements();
        return elements;
    }
    /**
     * Gets a PortalElement that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns A PortalElement that matches the specified sub locator or element type.
     */
    element(subLocatorOrElementType, locatorOptions) {
        return this.all(subLocatorOrElementType, locatorOptions).toPortalElement();
    }
    /**
     * Gets a PortalElement that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns A PortalElement that matches the specified sub locator or element type if found, or null.
     */
    async elementOrDefaultAsync(subLocatorOrElementType) {
        const element = this.all(subLocatorOrElementType).toPortalElement();
        if (await element.isPresent()) {
            return element;
        }
        else {
            return null;
        }
    }
    /**
     * Gets an ElementArrayFinder that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns An ElementArrayFinder that matches the specified sub locator or element type.
     */
    all(subLocatorOrElementType, locatorOptions) {
        const eaf = this.elementArrayFinder.all(subLocatorOrElementType, locatorOptions);
        return eaf;
    }
    /**
     * Transforms this PortalElement instance into the specified type. A new object is created as opposed to only casting to the specified type.
     *
     * @param targetType The type into which the PortalElement will be transformed.
     * @returns A PortalElement of the specified type.
     */
    asType(targetType) {
        const eaf = new targetType(this.parentElementArrayFinder, this.frameId);
        return eaf;
    }
    /**
     * Invokes the click function on the underlying web element.
     *
     * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
     * @param dialogCb Optional callback that will be invoked if a dialog is encountered.
     *                 The callback will be passed the dialog and should return a promise
     *                 that resolves when the dialog has been handled.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async click(retryOptions, dialogCb) {
        if (retryOptions?.scriptClick) {
            Object.defineProperty(dialogCb, "clickScript", { value: retryOptions.scriptClick });
        }
        try {
            const values = await this.elementArrayFinder.click(dialogCb);
            return values[0];
        }
        catch (e) {
            retryOptions = retryOptions || { remainingAttempts: 3, delay: 500 };
            if (retryOptions.remainingAttempts === 0) {
                throw new Error(`Unable to click element with locator '${this.elementArrayFinder.locator?.toString()}'.  Error details: ${e}`);
            }
            await delay(retryOptions.delay);
            retryOptions.remainingAttempts = retryOptions.remainingAttempts - 1;
            return this.click(retryOptions, dialogCb);
        }
    }
    /**
     * Invokes a right click on the underlying web element.
     *
     * @returns A promise that resolves when the right click resolves.
     */
    async rightClick() {
        const values = await this.elementArrayFinder.rightClick();
        return values[0];
    }
    /**
     * Invokes the getAttribute function on the underlying web element.
     *
     * @param {string} attributeName The attribute to retrieve.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getAttribute(attributeName) {
        const values = await this.elementArrayFinder.getAttribute(attributeName);
        return values[0];
    }
    /**
     * Invokes the getCssValue function on the underlying web element.
     *
     * @param {string} propertyName The value to retrieve.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getCssValue(propertyName) {
        const values = await this.elementArrayFinder.getCssValue(propertyName);
        return values[0];
    }
    /**
     * Returns a value that indicates whether this element has the specified attribute and value.
     *
     * @param {string} attributeName The name of the attribute.
     * @param {string} attributeValue The value of the attribute.
     * @returns A promise that resolves with the result of the evaluation.
     */
    async hasAttributeValue(attributeName, attributeValue) {
        const values = await this.elementArrayFinder.getAttribute(attributeName);
        return values[0] && values[0].includes(attributeValue);
    }
    /**
     * Returns a value that indicates whether this element does not have the specified attribute and value.
     *
     * @param {string} attributeName The name of the attribute.
     * @param {string} attributeValue The value of the attribute.
     * @returns A promise that resolves with the result of the evaluation.
     */
    async doesNotHaveAttributeValue(attributeName, attributeValue) {
        const value = await this.hasAttributeValue(attributeName, attributeValue);
        return !value;
    }
    /**
     * Invokes the sendKeys function on the underlying web element.
     *
     * @param {string} var_args The text to send.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async sendKeys(...var_args) {
        // eslint-disable-next-line prefer-spread
        const values = await this.elementArrayFinder.sendKeys.apply(this.elementArrayFinder, var_args);
        return values[0];
    }
    /**
     * Schedules a command to clear the value of this element.
     *
     * @returns A promise that will be resolved when the element has been cleared.
     */
    async clear() {
        const values = await this.elementArrayFinder.clear.apply(this.elementArrayFinder);
        return values[0];
    }
    /**
     * Invokes the getText function on the underlying web element.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getText() {
        const values = await this.elementArrayFinder.getText();
        return values[0];
    }
    /**
     * Invokes the getSize function on the underlying web element.
     *
     * @returns {Promise<{ width: number, height: number }>} Size object wrapped in a promise.
     */
    async getSize() {
        const values = await this.elementArrayFinder.getSize();
        return values[0];
    }
    /**
     * Invokes the getLocation function on the underlying web element.
     *
     * @returns {Promise<{ x: number, y: number }>} Size object wrapped in a promise.
     */
    async getLocation() {
        const values = await this.elementArrayFinder.getLocation();
        return values[0];
    }
    /**
     * Invokes the isEnabled function on the underlying web element.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isElementEnabled() {
        const values = await this.elementArrayFinder.isEnabled();
        return values[0];
    }
    /**
     * Invokes the isDisplayed function on the underlying web element.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isDisplayed(checkFxsDisplayNoneClass = false) {
        const [isDisplayed] = await this.elementArrayFinder.isDisplayed();
        return isDisplayed && (!checkFxsDisplayNoneClass || !(await this.hasClass("fxs-display-none")));
    }
    /**
     * Opposite of isDisplayed.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isNotDisplayed(checkFxsDisplayNoneClass = false) {
        const value = await this.isDisplayed(checkFxsDisplayNoneClass);
        return !value;
    }
    /**
     * Determine whether the element is present on the Portal.
     *
     * @returns A promise that resolves with a value that indicates whether the element is present on the Portal.
     */
    async isPresent() {
        const isPresentImpl = async () => {
            return await this.parentElementArrayFinder.getWebElements(false).then((arr) => {
                if (arr.length === 0 || !arr[0]) {
                    return false;
                }
                return arr[0].isEnabled().then(() => {
                    return true;
                }, (error) => {
                    const isStaleElemRefErr = (0, BrowserAutomation_1.runAutomationSync)((wd) => {
                        return error instanceof wd.error.StaleElementReferenceError;
                    }, () => {
                        throw new Error(`PortalElement.isPresent().isStaleElemRefErr: Not Implemented. StaleElementReferenceError: ${error}`);
                    });
                    if (!isStaleElemRefErr) {
                        throw error;
                    }
                    Logger_1.default.warning("StaleElementReferenceError caught at PortalElement.isPresent.");
                    return false;
                });
            }, (error) => {
                const isNoSuchElemErr = (0, BrowserAutomation_1.runAutomationSync)((wd) => {
                    return error instanceof wd.error.NoSuchElementError;
                }, () => {
                    return error instanceof PlaywrightErrors_1.PlaywrightNoSuchElementError;
                });
                if (isNoSuchElemErr) {
                    return false;
                }
                throw error;
            });
        };
        return this.frameId ? (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.id(this.frameId), isPresentImpl) : isPresentImpl();
    }
    /**
     * Determine whether the element is not present on the Portal.
     *
     * @returns A promise that resolves with a value that indicates whether the element is not present on the Portal.
     */
    async isNotPresent() {
        const value = await this.isPresent();
        return !value;
    }
    /**
     * Same as PortalElement.isPresent(), except this checks whether the element identified by the subLocator
     * is present, rather than the current PortalElement.
     *
     * @param {Locator} subLocator Locator for element to look for.
     * @returns A promise that resolves with a value that indicates whether the element is present on the Portal.
     */
    async isElementPresent(subLocator) {
        return await this.element(subLocator).isPresent();
    }
    /**
     * Checks whether the element identified by the subLocator
     * is present and displayed, rather than the current PortalElement.
     *
     * @param {Locator} subLocator Locator for element to look for.
     * @returns A promise that resolves with a value that indicates whether the element is present and displayed on the Portal.
     */
    async isElementDisplayed(subLocator, checkFxsDisplayNoneClass = false) {
        const present = await this.element(subLocator).isPresent();
        if (present) {
            return this.element(subLocator).isDisplayed(checkFxsDisplayNoneClass);
        }
        else {
            // If its not present then its not displayed
            return false;
        }
    }
    /**
     * Checks whether the any of the multiple elements identified by the subLocator
     * are present and displayed, rather than the current PortalElement.
     *
     * @param {Locator} subLocator Locator for element to look for.
     * @returns A promise that resolves with a value that indicates whether the element is present and displayed on the Portal.
     */
    async areElementsDisplayed(subLocator, checkFxsDisplayNoneClass = false) {
        const elements = this.all(subLocator);
        const portalElements = await elements.asPortalElements();
        const elementsDisplayed = await Promise.all(portalElements.map(async (element) => {
            try {
                return await element.isDisplayed(checkFxsDisplayNoneClass);
            }
            catch (e) {
                return false;
            }
        }));
        return elementsDisplayed.some((_) => _);
    }
    /**
     * Checks whether the element identified by the subLocator
     * is not present or not displayed, rather than the current PortalElement.
     *
     * @param {Locator} subLocator Locator for element to look for.
     * @returns A promise that resolves with a value that indicates whether the element is not present or not displayed on the Portal.
     */
    async isElementNotDisplayed(subLocator) {
        const value = await this.isElementDisplayed(subLocator);
        return !value;
    }
    /**
     * Returns a value to specify whether or not the element has a given CSS class.
     *
     * @param {string} className The CSS class name.
     * @returns True if the element has the class; false otherwise.
     */
    async hasClass(className) {
        if (!className) {
            throw "Class name should be provided.";
        }
        const elementClasses = await this.getAttribute("class");
        if (typeof elementClasses !== "string") {
            return false;
        }
        return elementClasses.trim().split(" ").includes(className);
    }
    /**
     * Gets the text content from the element.
     */
    async getTextContent() {
        return await this.getAttribute("textContent");
    }
    /**
     * Attempts to find the first PortalElement using the given Locator.
     *
     * @param by Locator to use.
     * @returns element or null if not found.
     */
    tryFindElement(subLocatorOrElementType) {
        try {
            return this.element(subLocatorOrElementType);
        }
        catch {
            return null;
        }
    }
    /**
     * Returns the base webdriver WebElements for this element.
     *
     * @returns A promise that resolves with the webdriver WebElement
     */
    async getWebElements() {
        const getWebElementsImpl = () => this.elementArrayFinder.getWebElements(true);
        return this.frameId
            ? await (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.id(this.frameId), getWebElementsImpl)
            : await getWebElementsImpl();
    }
    async ensureAccessibilityIsAxeCoreClean(options) {
        return await (0, Accessibility_1.ensureAccessibilityIsAxeCoreClean)(this, options);
    }
    /**
     * Invokes a right click on the underlying web element.
     *
     * @returns A promise that resolves when the right click on specific location resolves.
     */
    async moveMouseAndRightClick(opt_offset) {
        const values = await this.elementArrayFinder.moveMouseAndRightClick(opt_offset);
        return values[0];
    }
    /**
     * Invokes a click on the underlying web element.
     *
     * @returns A promise that resolves when the right click on specific location resolves.
     */
    async moveMouseAndLeftClick(opt_offset) {
        const values = await this.elementArrayFinder.moveMouseAndLeftClick(opt_offset);
        return values[0];
    }
    /**
     * Clicks this element with the CONTROL key pressed down.
     */
    async clickWithCtrlKey() {
        await this.scrollIntoView();
        const ctrlKey = (0, BrowserAutomation_1.getBrowser)().Key.CONTROL;
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => {
            await wd.driver
                .actions()
                .keyDown(ctrlKey)
                .click(this.webElement.element)
                .keyUp(ctrlKey)
                .perform();
        }, async (pw) => {
            await pw.keyboard.down(ctrlKey);
            await this.webElement.click();
            await pw.keyboard.up(ctrlKey);
        });
    }
    /**
     * Invokes the getTagName function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getTagName() {
        const values = await this.elementArrayFinder.getTagName();
        return values[0];
    }
    /**
     * Walks up the ancestor tree of the element until the specified condition satisfies.  Returns null if the condition is never satisfied after reaching the top document level
     *
     * @param condition the condition to satisfy
     */
    async getAncestor(condition) {
        let result;
        try {
            result = await condition(this);
        }
        catch (error) {
            const invalidSelectorErrorMessage = `invalid selector: The result of the xpath expression ".." is: [object HTMLDocument]. It should be an element.`;
            if (error.message.includes(invalidSelectorErrorMessage)) {
                diagnosticsLog(`getAncestor() hit the top of the document and can't go any farther up the parent chain.  This may be intended.  Error was: ${error}`);
                return null;
            }
            throw error;
        }
        if (result) {
            return this;
        }
        else {
            return await this.getParent().getAncestor(condition);
        }
    }
    /**
     * Gets the immediate parent of the element.
     */
    getParent() {
        return this.element(Locators_1.By.xpath(".."));
    }
    /**
     * Invokes the isSelected function on the underlying web element.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isElementSelected() {
        const values = await this.elementArrayFinder.isSelected();
        return values[0];
    }
    /**
     * Scrolls the given element into view.This method should be run before using the
     * Actions API on any W3C spec compliant browser to ensure that the objects being
     * interacted with are in the viewport.
     */
    async scrollIntoView() {
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("arguments[0].scrollIntoView(true);", this), async () => await (await this.getWebElements())[0].element.scrollIntoViewIfNeeded());
    }
    /**
     * Gets the content.
     *
     * @param elementType element type.
     */
    async getContent(elementType) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const element = this.all(elementType).first();
            if (await element.isPresent()) {
                return element;
            }
            else {
                return null;
            }
        }, null, "Cannot find content in the PortalElement.");
    }
    /**
     * Gets the property name of the view model.
     */
    async getViewModelPropertyName() {
        // The view model property name is set by the extension author.
        // Inspecting the data-bind property to determine the view model property name in the form of "pcControlName: myControlViewModel".
        let viewModelName = null;
        for (
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let element = this; element !== null && String.isNullOrEmpty(viewModelName); element = element.getParent()) {
            // If the string is empty, it means we have no data-bind attribute on this div.  This means we are looking at a form field.
            // Walk up the tree to the form element and get the view model name from there.
            const dataBind = await element.getAttribute("data-bind");
            if (!String.isNullOrEmpty(dataBind)) {
                viewModelName = "$data";
                const databindSplit = dataBind.split(":");
                if (databindSplit.length >= 2) {
                    const bindingType = databindSplit[0].trim();
                    // If there are multiple databindings then need to trim out the additional entries.
                    const bindingValue = databindSplit[1].split(",")[0].trim();
                    if (/^pc|^azc|^formElement$|^with$/.test(bindingType)) {
                        viewModelName = bindingValue;
                    }
                }
            }
        }
        return viewModelName;
    }
    /**
     * Gets the data bound to the specified attribute.
     *
     * @param attribute The attribute name.
     * @returns The data bound to the attribute.
     */
    async getBoundData(attribute) {
        let boundValue = null;
        const viewModelPropertyName = await this.getViewModelPropertyName();
        // Context property binding ($data, $root, or other) or view model property binding
        const propertyBinding = viewModelPropertyName.startsWith("$") ? "contextFor" : "dataFor";
        boundValue = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return ko.unwrap(ko.unwrap(ko.unwrap(ko.${propertyBinding}(arguments[0])).${viewModelPropertyName}).${attribute})`, this.webElement.element), async () => await this.webElement.executeScript(`(htmlElem) => ko.unwrap(ko.unwrap(ko.unwrap(ko.${propertyBinding}(htmlElem)).${viewModelPropertyName}).${attribute})`));
        if (boundValue === null) {
            return null;
        }
        return boundValue;
    }
    /**
     * Gets the inner HTML from the element.
     */
    async getInnerHtml() {
        return await this.getAttribute("innerHTML");
    }
    /**
     * Gets the input value from the element.
     */
    async getInputValue() {
        const values = await this.elementArrayFinder.getInputValue();
        return values[0];
    }
}
exports.default = PortalElement;
//# sourceMappingURL=PortalElement.js.map