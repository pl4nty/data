"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testFx = require("../src/Index");
const TestSupport_1 = require("./TestSupport");
var DataGrid = testFx.Controls.DataGrid;
var assert = testFx.Utils.Assert;
describe("DataGrid Tests", function () {
    this.timeout(0);
    const testSupport = new TestSupport_1.default(this);
    const resourceGroups = new Array();
    before(() => {
        testSupport.initializePortalContext();
        return testSupport.initializeArmClient();
    });
    it("Can do sort operations", async () => {
        const gridBlade = testFx.portal.blade({ title: "DataGrid | Filtering" });
        const grid = gridBlade.element(DataGrid);
        await testFx.portal.navigateToUriFragment("blade/InternalSamplesExtension/DataGrid/Filtering", 70000);
        await gridBlade.waitUntilBladeAndAllTilesLoaded();
        await testFx.portal.wait(async () => {
            const groupRows = await grid.getGroupRows();
            return groupRows.length === 0;
        });
        const headers = await grid.all(DataGrid.ColumnHeader);
        const sortDirections = await Promise.all(headers.map((header) => header.sortDirection()));
        for (let index = 0; index < sortDirections.length; index++) {
            const sortDirection = sortDirections[index];
            if (index === 0) {
                await assert.strictEqual(sortDirection, DataGrid.SortDirection.Ascending, "sort direction");
            }
            else {
                await assert.strictEqual(sortDirection, DataGrid.SortDirection.Unsorted, "sort direction");
            }
        }
        await headers[0].click();
        await testFx.portal.wait(async () => {
            const state = await headers[0].sortDirection();
            return state === DataGrid.SortDirection.Descending;
        });
        await headers[0].click();
        await testFx.portal.wait(async () => {
            const state = await headers[0].sortDirection();
            return state === DataGrid.SortDirection.Ascending;
        });
    });
    it("Can do grouping", async () => {
        const gridBlade = testFx.portal.blade({ title: "DataGrid | Grouping" });
        const grid = gridBlade.element(DataGrid);
        await testFx.portal.navigateToUriFragment("blade/InternalSamplesExtension/DataGrid/Grouping", 70000);
        await gridBlade.waitUntilBladeAndAllTilesLoaded();
        await testFx.portal.wait(async () => {
            const groupRows = await grid.getGroupRows();
            return groupRows.length > 0;
        });
        const columnHeaders = await grid.all(DataGrid.ColumnHeader);
        const sortDirections = await Promise.all(columnHeaders.map((header) => header.sortDirection()));
        for (let index = 0; index < sortDirections.length; index++) {
            const sortDirection = sortDirections[index];
            await assert.strictEqual(sortDirection, DataGrid.SortDirection.Unsorted, "sort direction");
        }
    });
    afterEach(async function () {
        const currentTest = this.currentTest;
        testSupport.LogRetry(currentTest);
        if (currentTest.state === "failed") {
            await testSupport.GatherTestFailureDetails(currentTest, __filename);
        }
    });
    after(() => {
        const promises = resourceGroups.map((resourceGroup) => testSupport.armClient.deleteResourceGroup(resourceGroup).catch((error) => {
            const log = (error.reason || "").includes("NotFound") ? console.info : console.error;
            log(`Failed to delete resource group "${resourceGroup}" with error: ${JSON.stringify(error)}`);
        }));
        return testFx.portal.quit().finally(() => {
            return Promise.allSettled(promises);
        });
    });
});
//# sourceMappingURL=DataGridTests.js.map