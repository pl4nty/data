"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const https = require("https");
const url = require("url");
const path = require("path");
const testFx = require("../src/Index");
const errorHandling = require("../src/Utils/ErrorHandling");
const String = require("../src/Utils/String");
const WindowsCredentialManager_1 = require("../src/Utils/WindowsCredentialManager");
var LogLevel = testFx.LogLevel;
var ArmClient = testFx.Utils.Arm.ArmClient;
// Include the month and day in the resource name prefix to help cleanup of dangling test resources.
function getDateResourcePrefix() {
    const now = new Date();
    const monthStr = (now.getMonth() + 1 + "").padStart(2, "0");
    const dateStr = (now.getDate() + "").padStart(2, "0");
    return `${now.getFullYear()}${monthStr}${dateStr}`;
}
class TestSupport {
    get testResourcePrefix() {
        return `TestFx-${this.datePrefix}-`;
    }
    constructor(testContext) {
        this.config = testFx.PortalConfigurationManager.default.portalContext;
        this.datePrefix = getDateResourcePrefix();
        testFx.Logger.startLogCapture();
        if (this.config.allowUnauthorizedCert === "true") {
            process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = "0";
        }
        if (this.config.enableFiddler === "true") {
            // Allows Fiddler to capture calls to external services
            process.env["https_proxy"] = "http://127.0.0.1:8888";
            process.env["http_proxy"] = "http://127.0.0.1:8888";
            process.env["NODE_TLS_REJECT_UNAUTHORIZED"] = "0";
        }
        this.SECRET_PATH_PREFIX = this.config.SECRET_PATH_PREFIX;
        this.AAD_CLIENT_ID = this.config.aadClientId;
        const testRetries = Number(this.config.testRetries);
        if (testContext !== null && testRetries && !isNaN(testRetries)) {
            testContext.retries(testRetries);
        }
    }
    initializePortalContext() {
        this.config.signInEmail = this.config.USER_EMAIL_LIVE;
        this.config.signInPassword = WindowsCredentialManager_1.default.getWindowsCredentialSync(`${this.SECRET_PATH_PREFIX}${this.config.signInEmail}`).CredentialBlob;
        this.config.certBasedAuth = false;
        this.config["skipDismissUnsafeParametersDialog"] = true;
        this.config.features = [
            { name: "feature.rapidToasts", value: "true" },
            { name: "feature.ci", value: "true" },
            { name: "feature.WaitForPendingChanges", value: "false" },
            { name: "feature.resourcemenu", value: "false" },
            { name: "clientOptimizations", value: "bundle" },
        ];
        this.config.testExtensions = [
            { name: "SamplesExtension", uri: "https://onestb.cloudapp.net/Samples", obsoleteBundlesBitmask: 1 },
            {
                name: "InternalSamplesExtension",
                uri: "https://onestb.cloudapp.net/InternalSamples",
                obsoleteBundlesBitmask: 1,
            },
        ];
    }
    async initializeArmClient() {
        this.armClient = await ArmClient.createClient({
            aadAuthorityUrl: this.config.aadAuthorityUrl,
            aadClientId: this.AAD_CLIENT_ID,
            aadClientSecret: WindowsCredentialManager_1.default.getWindowsCredentialSync(`${this.SECRET_PATH_PREFIX}${this.AAD_CLIENT_ID}`).CredentialBlob,
            armEndpoint: this.config.armEndpoint,
            managementEndpoint: this.config.managementEndpoint,
            subscriptionId: this.config.subscriptionId,
        });
        return this.armClient;
    }
    async ensureExtensionIsAlive(extensionUrl) {
        return new Promise((resolve, reject) => {
            const parsedUrl = url.parse(extensionUrl);
            const options = {
                host: parsedUrl.hostname,
                port: parseInt(parsedUrl.port),
            };
            https
                .get(options, (res) => {
                if (res.statusCode === 200) {
                    resolve({});
                }
                else {
                    reject(new Error(String.format("Querying extension at {0} did not return a success status code. Actual code: {1}", extensionUrl, res.statusCode)));
                }
            })
                .on("error", (error) => {
                reject(new Error(String.format("Error while querying extension at {0}.\n{1}", extensionUrl, errorHandling.readError(error))));
            });
        });
    }
    async GatherTestFailureDetails(currentTest, testPath) {
        try {
            testPath = path.relative(`${process.cwd()}\\..\\..`, testPath).replace(/\.js$/, ".ts");
            const error = currentTest.err;
            testFx.Logger.flushLogs(currentTest.title, { testName: currentTest.parent.title, testCaseName: currentTest.title, testPath: testPath }, error.stack ?? error.toString());
            if (testFx.portal.hasBrowser()) {
                // Try to handle any alerts before getting test details
                const text = await testFx.portal.getAlertText();
                if (text !== "") {
                    console.log("Alert found during test clean.  Alert text:" + text);
                }
                await testFx.portal.acceptAlert();
                const logs = await testFx.portal.getBrowserLogs(LogLevel.All);
                console.log("Console browser logs:");
                logs.forEach((line) => {
                    // Filter out the application cache events
                    if (!line.includes("Application Cache")) {
                        console.log(line);
                    }
                });
                const url = await testFx.portal.getBrowser().getCurrentUrl();
                console.log("Driver url was: " + url);
                return await testFx.portal.takeScreenshot(currentTest.title);
            }
            else {
                console.log("No Portal browser automation instance was available.");
            }
        }
        catch (e) {
            console.warn(`Error caught gathering failure details: ${e}`);
        }
    }
    LogRetry(currentTest) {
        const numRetries = currentTest.retries();
        const isNotLastRetry = !currentTest.isPassed() &&
            !currentTest.isPending() &&
            numRetries !== -1 &&
            numRetries !== currentTest._currentRetry;
        isNotLastRetry && testFx.Logger.default.information("Test failed. Retrying...");
    }
}
exports.default = TestSupport;
//# sourceMappingURL=TestSupport.js.map