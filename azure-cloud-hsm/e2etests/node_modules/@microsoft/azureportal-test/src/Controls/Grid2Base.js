"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGrid = exports.View = exports.BaseRow = exports.BaseCell = exports.BaseColumnHeader = exports.SortDirection = void 0;
const By_1 = require("../Locators/By");
const GridCommon = require("./GridCommonBase");
const Toolbar_1 = require("./Toolbars/Toolbar");
/**
 * Represents a Grid2 column sort direction.
 */
exports.SortDirection = GridCommon.SortDirection;
/**
 * Base class representing a Grid2 column header.
 */
class BaseColumnHeader extends GridCommon.BaseColumnHeader {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".fxc-gc-columnheader");
    }
    async canSort() {
        const count = await this.all(By_1.default.css(".fxc-gc-sorting-sortImage")).count();
        return count > 0;
    }
    async sortDirection() {
        const sort = await this.getAttribute("aria-sort");
        switch (sort) {
            case "ascending":
                return exports.SortDirection.Ascending;
            case "descending":
                return exports.SortDirection.Descending;
            default:
                return exports.SortDirection.Unsorted;
        }
    }
}
exports.BaseColumnHeader = BaseColumnHeader;
/**
 * Base class representing a Grid2 cell.
 */
class BaseCell extends GridCommon.BaseCell {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".fxc-gc-cell");
    }
    /**
     * Invokes the click function of the cell which clicks the cell content.
     *
     * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
     * @returns A promise that resolves when the invoked function resolves.
     */
    async click(retryOptions) {
        // Check if there is a link generated by a link column
        const linkCellElement = this.element(By_1.default.css(".fxc-gcflink"));
        const isLinkCellPresent = await linkCellElement.isPresent();
        if (!isLinkCellPresent) {
            // Click the cell
            return await super.click(retryOptions);
        }
        const linkElement = this.element(By_1.default.css(".fxc-gcflink-link"));
        const linkCellWidth = (await linkCellElement.getSize()).width;
        const linkWidth = (await linkElement.getSize()).width;
        const elementToClick = linkCellWidth > linkWidth ? linkElement : linkCellElement;
        // Click the link
        return await elementToClick.click(retryOptions);
    }
}
exports.BaseCell = BaseCell;
/**
 * Base class to represent a Grid2 row.
 */
class BaseRow extends GridCommon.BaseRow {
    /**
     * Constructs a base grid row.
     *
     * @param createCell Cell constructor.
     * @param elementArrayFinder Element array finder.
     */
    constructor(createCell, elementArrayFinder) {
        super(createCell, elementArrayFinder);
    }
    /**
     * Gets the locator associated to this element.
     */
    get locator() {
        return By_1.default.css(".fxc-gc-row");
    }
    /**
     * Gets the row footer.
     */
    get footer() {
        return this.element(By_1.default.css(".fxc-gc-row-footer"));
    }
    /**
     * Gets the context menu in the row.
     *
     * @returns The first context menu.
     */
    get contextMenuToolbar() {
        return this.element(By_1.default.css(".fxc-gc-margincell-contextmenu")).element(Toolbar_1.default);
    }
}
exports.BaseRow = BaseRow;
/**
 * Class to represent a Grid2 view port.
 */
class View extends GridCommon.BaseView {
    /**
     * Gets the locator associated to this element.
     */
    get locator() {
        return By_1.default.css(".fxc-gc-tbody,.fxc-grid-tbody");
    }
}
exports.View = View;
/**
 * Base class that represents a Grid2 grid.
 */
class BaseGrid extends GridCommon.BaseGrid {
    /**
     * Constructs a base grid.
     *
     * @param createRow Constructs a Row.
     * @param createCell Constructs a Cell.
     * @param createColumnHeader Constructs a ColumnHeader.
     * @param elementArrayFinder Element array finder.
     */
    constructor(createRow, createCell, createColumnHeader, elementArrayFinder) {
        super(createRow, createCell, createColumnHeader, View, elementArrayFinder);
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(".fxc-gc");
    }
    /**
     * Gets a collection of group rows in the grid.
     */
    async getGroupRows() {
        const groupRows = [];
        const columnHeaderCount = (await this.columnHeaders).length;
        const allRows = this.rows;
        const cellCounts = Promise.all(await allRows.map((row) => row.cells.count()));
        (await cellCounts).forEach((count, index) => {
            if (columnHeaderCount !== count) {
                groupRows.push(allRows.get(index));
            }
        });
        return groupRows;
    }
    /**
     * If multi-select is enabled, the row that contains the specified text will be selected.
     *
     * @param options The set of options used to find the row.
     * @param {string} options.text The text that the row should contain.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @returns A promise that resolves when the row has been selected.
     */
    async selectRow(options) {
        const row = await this.findRow(options);
        return await row.element(By_1.default.className("fxs-grid-selection-cell")).click();
    }
    /**
     * Checks if the row with specified text exists in the Grid.
     *
     * @param rowText The text that the row should contain.
     * @param cellIndex The cell index that contains the specified text.
     * @returns True, if the row with specified text is present; false, otherwise.
     */
    async isRowPresent(rowText, cellIndex) {
        const gridRows = this.rows.filter((r) => {
            const promise = checkIfPresent(r);
            return promise;
        });
        async function checkIfPresent(row) {
            const text = await row.cells.get(cellIndex).getText();
            return text === rowText;
        }
        if ((await gridRows.count()) === 1) {
            return true;
        }
        else {
            return false;
        }
    }
}
exports.BaseGrid = BaseGrid;
//# sourceMappingURL=Grid2Base.js.map