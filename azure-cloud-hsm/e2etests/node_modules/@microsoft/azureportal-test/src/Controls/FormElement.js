"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const By_1 = require("../Locators/By");
const BrowserAutomation_1 = require("../BrowserAutomation");
const Constants = require("../Constants");
var ControlValidationState = Constants.ControlValidationState;
var CssClassNames = Constants.CssClassNames;
const Logger_1 = require("../Logger");
/**
 * Represents a FormElement.
 */
class FormElement extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.labelClass = "azc-text-label";
        this.editedClassName = "azc-is-edited";
        /**
         * The FormElement label.
         */
        this.label = this.element(By_1.default.className(this.labelClass));
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("msportalfx-form-formelement");
    }
    /**
     * Gets the validation state of the element or its children
     *
     * @returns {ControlValidationState} the validation state if found, else none
     */
    async getValidationState() {
        //order the search for validation state
        const orderedSearchState = [
            ControlValidationState.invalid,
            ControlValidationState.pending,
            ControlValidationState.valid,
            ControlValidationState.none,
        ];
        let result = ControlValidationState.none;
        //search for the state in order
        for (let i = 0; i < orderedSearchState.length; i++) {
            const state = orderedSearchState[i];
            result = await this.isInValidationState(state);
            if (result) {
                break;
            }
        }
        return result;
    }
    /**
     * Waits until the element reaches a given validation state.
     *
     * @param validationState the validation state to wait on
     * @param timeout The amount of time to wait before failing
     * @returns {Promise<void>} promise that resolves when validationState is present
     */
    async waitOnValidationState(validationState, timeout) {
        const validationStates = [].concat(validationState);
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const currentValidationState = await this.getValidationState();
            return validationStates.includes(currentValidationState);
        }, timeout, `Timed out waiting for the form element to be in validation state of: ${validationStates.map((validationState) => ControlValidationState[validationState]).join(", ")}`);
    }
    /**
     * Builds a FormElement locator using the specified options.
     *
     * @param options The options used to build the locator.
     * @returns A Locator instance.
     */
    buildLocator(options) {
        if (options.label) {
            if (options.contains) {
                return By_1.default.content(this.locator, By_1.default.className(this.labelClass), By_1.default.textContains(options.label));
            }
            else {
                return By_1.default.content(this.locator, By_1.default.className(this.labelClass), By_1.default.text(options.label));
            }
        }
        else {
            return this.locator;
        }
    }
    /**
     * Waits for the form element to be enabled.
     *
     * @param timeout The amount of time to wait before failing
     * @returns A promise that resolves when the form element is enabled
     */
    async waitUntilEnabled(timeout) {
        Logger_1.default.diagnostics(`Waiting for form element ${this.constructorName} to be enabled`);
        await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.hasClass(Constants.CssClassNames.Forms.disabledState).then((value) => {
                return !value;
            });
        }, timeout, `Timed out waiting for the form element ${this.constructorName} to be enabled`);
        return;
    }
    /**
     * Gets the enabled/disabled state of the form field.
     * The disabled state is actually applied to a child element of this div, and therefore we need to check for a css class instead of using the out of box selenium attribute.
     */
    async isEnabled() {
        return !(await this.getAttribute("class")).includes(Constants.CssClassNames.Forms.disabledState);
    }
    async isInValidationState(state) {
        //find all with css validation class matching the given state
        const count = await this.all(By_1.default.css(`[class*=${CssClassNames.Controls.ValidationState[ControlValidationState[state]]}]`)).count();
        if (count > 0) {
            return state;
        }
        else {
            return null;
        }
    }
    /**
     * Gets a value indicating whether the control's value has been edited.
     */
    async isEdited() {
        return (await this.getAttribute("class")).includes(this.editedClassName);
    }
}
exports.default = FormElement;
//# sourceMappingURL=FormElement.js.map