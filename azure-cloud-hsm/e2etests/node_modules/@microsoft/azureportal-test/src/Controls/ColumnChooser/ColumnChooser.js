"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EditableGrid_1 = require("../../Controls/EditableGrid");
const TextField_1 = require("../../Controls/TextField");
const GroupDropDownField_1 = require("../../Controls/GroupDropDownField");
const SimpleButton_1 = require("../../Controls/SimpleButton");
const ColumnChooserType_1 = require("./ColumnChooserType");
const By_1 = require("../../Locators/By");
const BrowserAutomation_1 = require("../../BrowserAutomation");
const String = require("../../Utils/String");
const Logger_1 = require("../../Logger");
const ReactView_1 = require("../../Views/ReactView");
const InfoBox_1 = require("../InfoBox");
class ColumnChooser {
    constructor(columnChooserBlade) {
        this.columnChooserBlade = columnChooserBlade;
        this.reactView = columnChooserBlade.asType(ReactView_1.default);
    }
    async isOldBlade() {
        try {
            const bladeContainer = this.columnChooserBlade.element(By_1.default.className("ext-chooser-container" /* ClassNames.oldBladeContainer */));
            const oldBladeDisplayed = await bladeContainer.isDisplayed();
            Logger_1.default.diagnostics(oldBladeDisplayed ? "Found old column chooser blade" : "Found new React column chooser blade");
            return oldBladeDisplayed;
        }
        catch {
            return false;
        }
    }
    /**
     * Waits until Grid is loaded.
     *
     * @param skipColumnCheck Optional flag to skip column checks for the new blade.
     * @returns A promise that resolves when expected column grids found.
     */
    async waitUntilReady(skipColumnCheck) {
        if (await this.isOldBlade()) {
            const allEditableGridsElementArrayFinder = this.columnChooserBlade.all(EditableGrid_1.default);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await allEditableGridsElementArrayFinder.count()) === 2;
            }, null, `Expected 2 column grid, found ${await allEditableGridsElementArrayFinder.count()}.`);
            const alleditableGrids = await allEditableGridsElementArrayFinder.asPortalElements();
            this.sourceGrid = alleditableGrids[0];
            this.columnGrid = alleditableGrids[1];
            const allSimpleButtonsElementArrayFinder = this.columnChooserBlade.all(SimpleButton_1.default);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await allSimpleButtonsElementArrayFinder.count()) === 4;
            }, null, "Expected <4> column grids, found " + (await allSimpleButtonsElementArrayFinder.count()));
            const allSimpleButtons = await allSimpleButtonsElementArrayFinder.asPortalElements();
            this.addButton = allSimpleButtons[0];
            this.removeButton = allSimpleButtons[1];
            this.applyButton = allSimpleButtons[2];
            this.resetButton = allSimpleButtons[3];
            const allTextFieldsElementArrayFinder = this.columnChooserBlade.all(TextField_1.default);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await allTextFieldsElementArrayFinder.count()) === 1;
            }, null, "Expected <1> column grids, found " + (await allTextFieldsElementArrayFinder.count()));
            this.filterBox = allTextFieldsElementArrayFinder.first();
            const allGroupDropDownsElementArrayFinder = this.columnChooserBlade.all(GroupDropDownField_1.default);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await allGroupDropDownsElementArrayFinder.count()) === 1;
            }, null, "Expected <1> column grids, found " + (await allGroupDropDownsElementArrayFinder.count()));
            this.typeDropDown = allGroupDropDownsElementArrayFinder.first();
            const allnoitemsElementArrayFinder = this.columnChooserBlade.all(By_1.default.className("ext-noitems"));
            const allnoitemsElement = await allnoitemsElementArrayFinder.asPortalElements();
            this.noSourceRowsElement = allnoitemsElement[0];
            this.noColumnRowsElement = allnoitemsElement[1];
        }
        else {
            if (skipColumnCheck) {
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    const elements = await this.reactView.findAll(By_1.default.className("ms-List" /* ClassNames.list */));
                    return elements.length > 0;
                }, null, "Missing column list");
            }
            else {
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                    const elements = await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */));
                    return elements.length > 0;
                }, null, "Column fields loaded");
            }
        }
    }
    /**
     * Clicks Apply button.
     *
     * @returns A promise that resolves when ApplyButton is clicked.
     */
    async clickApply() {
        if (await this.isOldBlade()) {
            await this.applyButton.click();
        }
        else {
            const saveButton = await this.reactView.find(By_1.default.className("ms-Button--primary" /* ClassNames.primaryButton */));
            await saveButton.click();
        }
    }
    /**
     * Clicks Reset button.
     *
     * @returns A promise that resolves when ResetButton is clicked.
     */
    async clickReset() {
        if (await this.isOldBlade()) {
            await this.resetButton.click();
        }
        else {
            // Simulate the old behavior by clicking reset to defaults and then click apply.
            await this.resetToDefaults();
            await this.clickApply();
        }
    }
    /**
     * Clicks the reset to defaults command button in the new blade.
     * NOTE: NoOp for old blade - there is no reset to defaults button.
     *
     * @returns A promise that resolves when reset to defaults command button is clicked.
     */
    async resetToDefaults() {
        if (!(await this.isOldBlade())) {
            const resetButton = await this.reactView.find(By_1.default.id("reset-button"));
            return await resetButton.click();
        }
    }
    /**
     * Switch between type of Available Columns.
     * NOTE: NoOp on new blade - there is no type switching.
     *
     * @param {ColumnChooserType} type Option to be selected.
     * @returns A promise that resolves when switch between available columns..
     */
    async switchToType(type) {
        if (await this.isOldBlade()) {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await this.typeDropDown.getOptions()).length > 0;
            }, null, "Type drop down is populated with options");
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                // eslint-disable-next-line no-useless-catch
                try {
                    switch (type) {
                        case ColumnChooserType_1.ColumnChooserType.All:
                            await this.typeDropDown.selectByIndex(0);
                            break;
                        case ColumnChooserType_1.ColumnChooserType.Properties:
                            await this.typeDropDown.selectByIndex(1);
                            break;
                        case ColumnChooserType_1.ColumnChooserType.Tags:
                            await this.typeDropDown.selectByIndex(2);
                            break;
                    }
                    return true;
                }
                catch (error) {
                    throw error;
                }
            }, null, `Expected to be able to select the type to ${type}`);
        }
    }
    /**
     * Validates expected and Source Grid rows.
     * NOTE: NoOp on the new blade - there is no source grid.
     *
     * @param {number} expectedRows number of expected rows.
     * @returns A promise that resolves when Source Grid and exptected rows are same..
     */
    async validateExpectedSourceRows(expectedRows) {
        if (await this.isOldBlade()) {
            if (expectedRows === 0) {
                await this.validateNoSourceRowsVisibility(true);
                await this.validateSourceGridVisibility(false);
            }
            else {
                await this.validateNoSourceRowsVisibility(false);
                await this.validateSourceGridVisibility(true);
                await this.validateExpectedRows(this.sourceGrid, expectedRows, "available column grid");
            }
        }
    }
    /**
     * Validates expected and Source Grid rows.
     * NOTE: NoOp on the new blade - there is no source grid.
     *
     * @param {string[]} expectedRows number of expected rows.
     * @returns A promise that resolves when Source Grid and exptected rows are same..
     */
    async validateExpectedSourceRowsGivenTheColumnNamesArrays(expectedRows) {
        if (await this.isOldBlade()) {
            if (expectedRows.length === 0) {
                await this.validateNoSourceRowsVisibility(true);
                await this.validateSourceGridVisibility(false);
            }
            else {
                await this.validateNoSourceRowsVisibility(false);
                await this.validateSourceGridVisibility(true);
                await this.validateExpectedRowsGivenTheColumnNamesArrays(this.sourceGrid, expectedRows, "available column grid");
            }
        }
    }
    /**
     * Validates expected and source Column Grid rows.
     *
     * @param {number} expectedRows : number of expected Column rows.
     * @returns A promise that resolves when source and exptected rows are same..
     */
    async validateExpectedColumnRows(expectedRows) {
        if (await this.isOldBlade()) {
            await this.validateExpectedRows(this.columnGrid, expectedRows, "selected column grid");
        }
        else {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */))).length === expectedRows, null, "Found expected number of selected columns");
        }
    }
    /**
     * Validates expected and source Column Grid rows.
     *
     * @param {number} expectedRows : number of expected Column rows.
     * @returns A promise that resolves when source and exptected rows are same..
     */
    async validateExpectedColumnRowsGivenTheColumnNamesArrays(expectedRows) {
        if (await this.isOldBlade()) {
            await this.validateExpectedRowsGivenTheColumnNamesArrays(this.columnGrid, expectedRows, "selected column grid");
        }
        else {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */))).length === expectedRows.length, null, "Found expected number of selected columns");
            const columnFields = await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */));
            for (let i = 0; i < expectedRows.length; i++) {
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await columnFields[i]
                    .element(By_1.default.className("ms-ComboBox-Input" /* ClassNames.comboBoxInput */))
                    .getAttribute("value")) === expectedRows[i], null, `Found expected column ${expectedRows[i]}`);
            }
        }
    }
    /**
     * Adds column from source grid to columns grid and moves to specified index.
     *
     * @param {string} column column name.
     * @param {number} index Move to specified index.
     * @returns A promise that resolves when column added and move to specified index.
     */
    async addColumnAndMoveToIndex(column, index) {
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        if (await this.isOldBlade()) {
            const rowInSelected = await this.addAndGetColumn(column);
            await rowInSelected.sendKeys(Key.CONTROL, Key.HOME);
            for (let currentIndex = 0; currentIndex < index; currentIndex++) {
                await rowInSelected.sendKeys(Key.CONTROL, Key.DOWN);
            }
        }
        else {
            await this.addColumnAndMoveToIndexHelper(column, index);
        }
    }
    /**
     * Adds column from source grid to columns grid.
     *
     * @param column column name.
     * @returns A promise that resolves when column added.
     */
    async addColumn(column) {
        if (await this.isOldBlade()) {
            await this.addAndGetColumn(column);
        }
        else {
            await this.addColumnHelper(column);
        }
    }
    /**
     * Validates expected columns on source grid and columns grid
     *
     * @param {number} propertyColumns number of property columns
     * @param {number} tagColumns number of tag columns
     * @param {number} selectedColumns number of columns that got selected
     */
    async validateExpectedColumns(propertyColumns, tagColumns, selectedColumns) {
        if (await this.isOldBlade()) {
            const allColumns = propertyColumns + tagColumns;
            await this.validateExpectedSourceRows(allColumns - selectedColumns);
            await this.validateExpectedColumnRows(selectedColumns);
        }
        else {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */))).length === selectedColumns, null, "Found expected number of selected columns");
        }
    }
    /**
     * Validates expected columns on source grid and columns grid
     *
     * @param {string[]} propertyColumns number of property columns
     * @param {string[]} tagColumns number of tag columns
     * @param {string[]} selectedColumns number of columns that got selected
     */
    async validateExpectedColumnsGivenTheColumnNamesArrays(propertyColumns, tagColumns, selectedColumns) {
        if (await this.isOldBlade()) {
            let allColumns = propertyColumns;
            allColumns = allColumns.concat(tagColumns);
            let sourceColumns = allColumns;
            sourceColumns = sourceColumns.filter((column) => {
                return !selectedColumns.includes(column);
            });
            sourceColumns.sort(function (a, b) {
                return a.toLowerCase().localeCompare(b.toLowerCase());
            }); // source columns are sorted
            await this.validateExpectedSourceRowsGivenTheColumnNamesArrays(sourceColumns);
            await this.validateExpectedColumnRowsGivenTheColumnNamesArrays(selectedColumns);
        }
        else {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */))).length === selectedColumns.length, null, "Found expected number of selected columns");
            const columnFields = await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */));
            for (let i = 0; i < selectedColumns.length; i++) {
                await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await columnFields[i]
                    .element(By_1.default.className("ms-ComboBox-Input" /* ClassNames.comboBoxInput */))
                    .getAttribute("value")) === selectedColumns[i], null, `Found expected column ${selectedColumns[i]}`);
            }
        }
    }
    /**
     * Adds Tag column from source grid to columns grid.
     *
     * @param {string} column column name.
     * @returns A promise that resolves when column added.
     */
    async addTagColumn(column) {
        if (await this.isOldBlade()) {
            await this.addAndGetColumn(column);
        }
        else {
            await this.addColumnHelper(column);
        }
    }
    /**
     * Adds new column and moves to specified index.
     *
     * @param {string} column Column to add.
     * @param {number} index on which column to be moved.
     */
    async addTagColumnAndMoveToIndex(column, index) {
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        if (await this.isOldBlade()) {
            const rowInSelected = await this.addAndGetTagColumn(column);
            await rowInSelected.sendKeys(Key.CONTROL, Key.HOME);
            for (let currentIndex = 0; currentIndex < index; currentIndex++) {
                await rowInSelected.sendKeys(Key.CONTROL, Key.DOWN);
            }
        }
        else {
            await this.addColumnAndMoveToIndexHelper(column, index);
        }
    }
    /**
     * Removes all columns from source grid to columns grid.
     */
    async removeAllColumns() {
        if (await this.isOldBlade()) {
            while ((await this.columnGrid.rows).length !== 0) {
                await this.removeAndGetColumnByIndex(0);
            }
        }
        else {
            while ((await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */))).length > 0) {
                const firstColumnField = await this.reactView.find(By_1.default.className("ms-List-cell" /* ClassNames.listCell */));
                const deleteButton = firstColumnField.element(By_1.default.id("delete-column-button"));
                await deleteButton.click();
            }
        }
    }
    async removeAndGetColumnByIndex(index) {
        const row = await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.columnGrid.rows.get(index);
        }, null, `Expected to find a row at index <${index}> in the selected columns`);
        await row.click();
        const columnText = await row.getText();
        await this.removeButton.click();
        const rowInAvailable = await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.sourceGrid.findRow({ text: columnText }), null, `Expected to find the ${columnText} row in the available columns.`);
        await rowInAvailable.click();
        return rowInAvailable;
    }
    async addAndGetTagColumn(column) {
        const row = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.sourceGrid.findRow({ text: column });
        }, null, `Expected to find the <${column}> row in the available columns`);
        await row.click();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await row.isSelected();
        }, null, `Expected the <${column}> row in the available columns to be selected`);
        await this.sourceGrid.rows.get(0).scrollIntoView();
        await this.addButton.click();
        const rowInSelected = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.columnGrid.findRow({ text: column });
        }, null, `Expected to find the <${column}> row in the selected columns`);
        await rowInSelected.click();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await rowInSelected.isSelected();
        }, null, `Expected the <${column}> row in the available columns to be selected`);
        return rowInSelected;
    }
    async validateExpectedRows(grid, expectedRows, gridType) {
        const startingHosts = await grid.rows.count();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await grid.rows.count()) === expectedRows;
        }, null, async () => {
            await this.dumpGrid(grid);
            return `Expected ${expectedRows} rows in the ${gridType}, found ${await grid.rows.count()} (started with ${startingHosts})`;
        });
    }
    async validateExpectedRowsGivenTheColumnNamesArrays(grid, expectedRows, gridType) {
        const startingHosts = await grid.rows.count();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await grid.rows.count()) === expectedRows.length;
        }, null, async () => {
            await this.dumpGrid(grid);
            return `Expected ${expectedRows.length} rows in the ${gridType}, found ${await grid.rows.count()} (started with ${startingHosts})`;
        });
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            for (let index = 0; index < expectedRows.length; index++) {
                if ((await grid.rows.get(index).getText()).toLowerCase() !== expectedRows[index].toLowerCase()) {
                    return false;
                }
            }
            return true;
        }, null, async () => {
            await this.dumpGrid(grid);
            return `Expected ${expectedRows.join(", ")} rows in the ${gridType}, found ${await grid.rows.count()} (started with ${startingHosts})`;
        });
    }
    async validateNoSourceRowsVisibility(visible) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await this.noSourceRowsElement.isDisplayed()) === visible;
        }, null, "Expected the no source element to be " + visible ? "visible" : "hidden");
    }
    async validateSourceGridVisibility(visible) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await this.sourceGrid.isDisplayed()) === visible;
        }, null, "Expected the no source grid to be " + visible ? "visible" : "hidden");
    }
    async dumpGrid(grid) {
        const gridRowNames = await grid.rows.map(async (row) => {
            return await row.getText();
        });
        Logger_1.default.information(`Actual:\n\t${gridRowNames.join("\n\t")}`);
    }
    async addColumnHelper(column) {
        const addColumnButton = await this.reactView.find(By_1.default.text("Add Column"));
        await addColumnButton.click();
        const newColumnField = await this.reactView.find(By_1.default.id("new-column-field"));
        const input = newColumnField.element(By_1.default.className("ms-ComboBox-Input" /* ClassNames.comboBoxInput */));
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        await input.sendKeys(column, Key.ENTER);
    }
    async addColumnAndMoveToIndexHelper(column, index) {
        const addColumnButton = await this.reactView.find(By_1.default.text("Add Column"));
        await addColumnButton.click();
        const newColumnField = await this.reactView.find(By_1.default.id("new-column-field"));
        const input = newColumnField.element(By_1.default.className("ms-ComboBox-Input" /* ClassNames.comboBoxInput */));
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        await input.sendKeys(column, Key.ENTER);
        const columnFields = await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */));
        const newIndex = columnFields.length - 1;
        const addedColumn = columnFields[newIndex];
        await addedColumn.click();
        const moveUpButton = await this.reactView.find(By_1.default.id("move-up-button"));
        for (let i = newIndex; i > index; i--) {
            await moveUpButton.click();
        }
    }
    async addAndGetColumn(column) {
        const row = await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.sourceGrid.findRow({ text: column }), null, () => {
            return String.format("Expected to find the <{0}> row in the available columns", column);
        });
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await row.click();
            return await row.isSelected();
        }, null, String.format("Expected the <{0}> row in the available columns to be selected", column));
        await this.sourceGrid.rows.first().scrollIntoView();
        await this.addButton.click();
        const rowInSelected = await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.columnGrid.findRow({ text: column }), null, () => String.format("Expected to find the <{0}> row in the selected columns", column));
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await rowInSelected.click();
            return await rowInSelected.isSelected();
        }, null, String.format("Expected the <{0}> row in the selected columns to be selected", column));
        return rowInSelected;
    }
    async removeAndGetColumn(column) {
        const row = await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.columnGrid.findRow({ text: column }), null, `Expected to find the ${column} row in the available columns`);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await row.click();
            return await row.isSelected();
        }, null, `Expected the ${column} row in the available columns to be selected`);
        await this.columnGrid.rows.first().scrollIntoView();
        await this.removeButton.click();
        const rowInAvailable = await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.sourceGrid.findRow({ text: column }), null, `Expected to find the ${column} row in the available columns`);
        await rowInAvailable.click();
        return rowInAvailable;
    }
    /**
     * Removes column from source grid to columns grid.
     *
     * @param {string} column column name.
     * @returns A promise that resolves when column is removed.
     */
    async removeColumn(column) {
        if (await this.isOldBlade()) {
            await this.removeAndGetColumn(column);
        }
        else {
            await this.removeColumnHelper(column);
        }
    }
    /**
     * Removes Tag column from source grid to columns grid.
     *
     * @param {string} column column name.
     * @returns A promise that resolves when column is removed.
     */
    async removeTagColumn(column) {
        if (await this.isOldBlade()) {
            await this.removeAndGetColumn(column);
        }
        else {
            await this.removeColumnHelper(column);
        }
    }
    async removeColumnHelper(column) {
        const columnFields = await this.reactView.findAll(By_1.default.className("ms-List-cell" /* ClassNames.listCell */));
        for (let i = 0; i < columnFields.length; i++) {
            const columnField = columnFields[i];
            if ((await columnField.element(By_1.default.className("ms-ComboBox-Input" /* ClassNames.comboBoxInput */)).getAttribute("value")) === column) {
                const deleteButton = columnField.element(By_1.default.id("delete-column-button"));
                await deleteButton.click();
                break;
            }
        }
    }
    /**
     * Sets filter via filter textbox with the supplied filter text.
     * NOTE: NoOp on the new blade - there is no filter.
     *
     * @param filterText filter to apply.
     */
    async setFilter(filterText) {
        if (await this.isOldBlade()) {
            await this.filterBox.clear();
            await this.filterBox.sendKeys(filterText);
            await this.filterBox.blur();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await this.filterBox.value()) === filterText;
            }, null, `Expected the filter text to be <${filterText}> but it is <${await this.filterBox.value()}>`);
        }
    }
    /**
     * Clears the filter text box.
     * NOTE: NoOp on the new blade - there is no filter.
     */
    async clearFilter() {
        if (await this.isOldBlade()) {
            await this.filterBox.clear();
            await this.filterBox.blur();
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return (await this.filterBox.value()) === "";
            }, null, `Expected the filter text to be empty but it is <${await this.filterBox.value()}>`);
        }
    }
    /**
     * Determines if there is an info box on the column chooser with the given text.
     *
     * @param expectedText The expected text for the info box.
     * @returns Promise which resolves to true if the info box is found with the text, otherwise false.
     */
    async hasInfoBoxText(expectedText) {
        const cleanString = (source) => {
            // Remove any font icons, any non-printable characters, newlines, carriage returns.
            return source
                ?.replace(/\n/g, "-")
                .replace(/\r/g, "")
                .trim()
                .replace(/[^a-zA-Z0-9\s\\/.-]/g, "");
        };
        const expectedErrorString = cleanString(expectedText);
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return cleanString(await this.getInfoBoxText()) === expectedErrorString;
        }, null, async () => `Expected the error info box string to be <${expectedErrorString}>, found <${cleanString(await this.getInfoBoxText())}>`);
    }
    async getInfoBoxText() {
        if (await this.isOldBlade()) {
            return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const found = await this.columnChooserBlade.all(InfoBox_1.default);
                return found.length === 1 ? found[0].infoBoxTextContent() : null;
            }, null, "Expected to find 1 info box");
        }
        else {
            return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const found = await this.reactView.findAll(By_1.default.className("ms-MessageBar-content" /* ClassNames.messageBar */));
                return found.length === 1 ? await found[0].getTextContent() : null;
            }, null, "Expected to find 1 info box");
        }
    }
}
exports.default = ColumnChooser;
//# sourceMappingURL=ColumnChooser.js.map