"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EditableGrid_1 = require("./EditableGrid");
const SimpleButton_1 = require("./SimpleButton");
const TagsByResource_1 = require("./TagsByResource");
const TextField_1 = require("./TextField");
const ToolbarItem_1 = require("./Toolbars/ToolbarItem");
const MenuBlade_1 = require("../Blades/MenuBlade");
const BrowserAutomation_1 = require("../BrowserAutomation");
const PortalFxResources = require("../PortalFxResources");
const By_1 = require("../Locators/By");
const PortalShell_1 = require("../PortalShell");
const TextBox_1 = require("./TextBox");
const ContextMenu_1 = require("../Commands/ContextMenu");
const String = require("../Utils/String");
const Controls_1 = require("../Controls");
const Utils = require("../Utils");
var assert = Utils.Assert;
class TagEditor {
    constructor(tagEditorBlade) {
        this.maxTypingAttempts = 5;
        this.tagEditorBlade = tagEditorBlade;
        this.tagEditorParent = tagEditorBlade.defaultBladeContent;
        this.inContextPane = !(this.tagEditorBlade instanceof MenuBlade_1.default);
    }
    /**
     * Waits until TagEditor is loaded. Should be called after TagEditor class is initialized.
     */
    async waitUntilReady() {
        if (this.tagEditorBlade instanceof MenuBlade_1.default) {
            this.tagEditorParent = await this.tagEditorBlade.detailBladeContent();
        }
        else {
            this.tagEditorParent = this.tagEditorBlade.defaultBladeContent;
        }
        this.tagsGrid = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allTagsGrids = this.tagEditorParent.all(EditableGrid_1.default);
            if ((await allTagsGrids.count()) > 0) {
                return allTagsGrids.first();
            }
            else {
                return false;
            }
        }, null, "Expected editable grid for tags");
    }
    /**
     * Validate expected tag count.
     *
     * @param expectedTags expected count of tags.
     */
    async validateExpectedTagCount(expectedTags) {
        await this.waitUntilReady();
        // If less than max tags, expect empty row editor.
        const expectedRows = expectedTags === TagEditor.maximumNumberOfTagsPerResource ? expectedTags : expectedTags + 1;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await this.tagsGrid.rows.count()) === expectedRows;
        }, null, `The tags grid did not have the expected tags. Expected row count: ${expectedRows}, existing row count: ${await this.tagsGrid.rows.count()}`);
    }
    /**
     * Adds random tag in the blade.
     *
     * @param {boolean} cleanUpTags to delete all the existing tags.
     * @returns {string} A promise that resolves with the added tag and its value.
     */
    async addRandomTag(cleanUpTags = false) {
        if (cleanUpTags) {
            await this.deleteAllTags(false);
        }
        const tagName = "tagKey" + Utils.Guid.newGuid();
        const tagValue = "tagValue" + Utils.Guid.newGuid();
        await this.setNewTagValues(tagName, tagValue);
        return tagName + " : " + tagValue;
    }
    /**
     * Sets the new tag value.
     *
     * @param {string} tagName Tag Name.
     * @param {string} tagValue Tag Value.
     */
    async setNewTagValues(tagName, tagValue) {
        await this.validateNewTagRowExists();
        await this.setFocusToNewTagRow();
        const editableRow = this.tagsGrid.rows.get((await this.tagsGrid.rows.count()) - 1);
        // Column 0 is the name (key) and column 2 is the value.
        // Retry typing until the textbox's value matches what we expect - SendKeys can drop characters, leading to duplicate tag names.
        let tagNameTypingAttempt = 0;
        while (tagNameTypingAttempt++ < this.maxTypingAttempts &&
            !((await editableRow.cells.get(0).element(TextField_1.default).value()) === tagName)) {
            const nameField = editableRow.cells.get(0).element(TextField_1.default);
            await nameField.clear();
            await nameField.sendKeys(tagName);
        }
        if (tagNameTypingAttempt >= this.maxTypingAttempts &&
            !((await editableRow.cells.get(0).element(TextField_1.default).value()) === tagName)) {
            throw new Error(`Failed to type tag name ${tagName} after ${tagNameTypingAttempt} attempts`);
        }
        // Tag values can have duplicates - okay to miss some keys here
        await editableRow.cells.get(2).element(TextField_1.default).sendKeys(tagValue);
    }
    /**
     * Validates new tag row exists or not.
     */
    async validateNewTagRowExists() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.doesNewTagRowExist();
        }, null, "Expected the new tag editor row to be present");
    }
    async doesNewTagRowExist() {
        // Make sure on first row.
        await this.tagsGrid.rows.get(0).cells.get(0).click();
        const nameEditor = await this.tagsGrid.rows
            .get((await this.tagsGrid.rows.count()) - 1)
            .cells.get(0)
            .elementOrDefaultAsync(TextField_1.default);
        if (nameEditor === null || (await nameEditor.value()) !== "") {
            return false;
        }
        const valueEditor = await this.tagsGrid.rows
            .get((await this.tagsGrid.rows.count()) - 1)
            .cells.get(2)
            .elementOrDefaultAsync(TextField_1.default);
        if (valueEditor === null || (await valueEditor.value()) !== "") {
            return false;
        }
        return true;
    }
    /**
     * Applies tags in blade.
     */
    async applyTagsInBlade() {
        const getApplybutton = async () => {
            return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                const simpleButtons = this.tagEditorBlade.all(SimpleButton_1.default);
                const filteredSimpleButtons = simpleButtons.filter((button) => {
                    const promise = checkButtonHasExpectedText(button);
                    return promise;
                });
                const filteredSimpleButtonsAsPortalElements = await filteredSimpleButtons.asPortalElements();
                if (filteredSimpleButtonsAsPortalElements.length > 1) {
                    throw new Error("More than one Simple Buttons found.");
                }
                if (filteredSimpleButtonsAsPortalElements.length === 1) {
                    return filteredSimpleButtonsAsPortalElements[0];
                }
                if (filteredSimpleButtonsAsPortalElements.length === 0) {
                    throw new Error("No button found");
                }
            }, null, "Expected to find apply button.");
        };
        await this.setFocusToNewTagRow();
        const tagsControl = this.tagEditorBlade.element(TagsByResource_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(() => tagsControl.isValid(), 3500, "Tags control should be in a valid state. There is probably a duplicate tag name in the control.");
        const errorInfoBox = this.tagEditorBlade.element(By_1.default.className("ext-infobox"));
        await assert.equal(async () => await errorInfoBox.isPresent(), false, "The error infobox should not be present");
        let applyButton = await getApplybutton();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await applyButton.isEnabled();
        }, null, "Expected apply button should be enabled.");
        await applyButton.click();
        applyButton = await getApplybutton();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return !(await applyButton.isEnabled());
        }, null, "Expected apply button to be disabled.");
        async function checkButtonHasExpectedText(button) {
            return (await button.getText()) === PortalFxResources.tagsClientStrings.common.applyLabel;
        }
    }
    /**
     * Sets the focus to new tag row.
     */
    async setFocusToNewTagRow() {
        // If there is an open dropdown, dismiss it.
        if ((await PortalShell_1.default.getPortalShell()
            .getPortalElement()
            .all(By_1.default.css(".fxc-dropdown-popup:not(.fxc-dropdown-hidden)"))
            .count()) > 0) {
            const driver = (0, BrowserAutomation_1.getBrowser)();
            await (await driver.getActiveElement()).sendKeys(driver.Key.ESCAPE);
        }
        // Click on the ":" column to prevent a dropdown from opening and obscuring elements.
        await this.tagsGrid.rows
            .get((await this.tagsGrid.rows.count()) - 1)
            .cells.get(1)
            .click();
    }
    /**
     * Validates the row tag.
     *
     * @param {number} rowIndex Row index to be validate.
     * @param {string} expectedTagName expected Tag Name.
     * @param {string} expectedTagValue expected Tag Value.
     */
    async validateRowTag(rowIndex, expectedTagName, expectedTagValue) {
        const actualTagStringForRow = await this.getTagStringForRow(rowIndex);
        await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return actualTagStringForRow === expectedTagName + " : " + expectedTagValue;
        }, null, `Expected the ${rowIndex} row to be the ${expectedTagName} editor with ${expectedTagValue} value, got ${actualTagStringForRow} instead`);
    }
    /**
     * Gets the string of tag for row.
     *
     * @param tagIndex Tag index.
     */
    async getTagStringForRow(tagIndex) {
        const tagGridRow = this.tagsGrid.rows.get(tagIndex).cells.get(0);
        await tagGridRow.click();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await tagGridRow.findAll(TextBox_1.default)).length > 0;
        }, null, "Expected text box in first row");
        return ((await tagGridRow.element(TextBox_1.default).value()) +
            " : " +
            (await this.tagsGrid.rows.get(tagIndex).cells.get(2).element(TextField_1.default).value()));
    }
    /**
     * Modifies the existing tag value.
     *
     * @param {string} nameOfTagToEdit Tag name to edit.
     * @param {string} newTagValue new value of tag.
     */
    async modifyExistingTagValue(nameOfTagToEdit, newTagValue) {
        // Find the tag row (and activate the editors).
        const tagRow = await this.findTagRow(nameOfTagToEdit);
        // Find the name and value editor.
        const nameEditor = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allTextFields = await tagRow.cells.get(0).all(TextField_1.default);
            if (allTextFields.length > 0) {
                return allTextFields[0];
            }
            else {
                return false;
            }
        }, null, "Expected the name editor.");
        const valueEditor = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allTextFields = await tagRow.cells.get(2).all(TextField_1.default);
            if (allTextFields.length > 0) {
                return allTextFields[0];
            }
            else {
                return false;
            }
        }, null, "Expected the value editor.");
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await nameEditor.isEnabled();
        }, null, "The tag key field is not enabled.");
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await valueEditor.isEnabled();
        }, null, "The tag value field is not enabled.");
        // Update the tag value.
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await valueEditor.clear();
            return (await valueEditor.value()) === "";
        }, null, "Could not clear the editor");
        await valueEditor.sendKeys(newTagValue);
    }
    /**
     * Finds the row with tag name.
     *
     * @param {string} nameOfTag Name of tag.
     */
    async findTagRow(nameOfTag) {
        // Click into the new row editor.
        await this.setFocusToNewTagRow();
        // Find the row for the tag.
        const tagRow = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const filteredRows = this.tagsGrid.rows.filter((row) => {
                const promise = checkRowHasExpectedTagName(row, nameOfTag);
                return promise;
            });
            const filteredRowsAsPortalElements = await filteredRows.asPortalElements();
            if (filteredRowsAsPortalElements.length >= 0) {
                return filteredRowsAsPortalElements[0];
            }
            else {
                return false;
            }
        }, null, `Expected to find the <${nameOfTag}> tag row.`);
        // Acivate the editors.
        await tagRow.click();
        return tagRow;
        async function checkRowHasExpectedTagName(row, nameOfTag) {
            return (await row.cells.get(0).getText()) === nameOfTag.toLowerCase();
        }
    }
    /**
     * Deletes the existing tag.
     *
     * @param {string} nameOfTagToDelete Tag name to delete.
     */
    async deleteExistingTag(nameOfTagToDelete) {
        const rowCount = await this.tagsGrid.rows.count();
        const haveNewTagRow = await this.doesNewTagRowExist();
        const tagRow = await this.findTagRow(nameOfTagToDelete);
        await this.findRowAndClickCommandButton(tagRow, PortalFxResources.listCommandDeleteListItem);
        const expectedTags = haveNewTagRow ? rowCount - 2 : rowCount - 1;
        await this.validateExpectedTagCount(expectedTags);
        await this.validateNewTagRowExists();
    }
    /**
     * Deletes the existing tag index.
     *
     * @param {number} tagIndex Tag index to delete.
     */
    async deleteExistingTagwithTagIndex(tagIndex) {
        const rowCount = await this.tagsGrid.rows.count();
        const haveNewTagRow = await this.doesNewTagRowExist();
        await this.findRowAndClickCommandButtonGivenRowIndex(tagIndex, PortalFxResources.listCommandDeleteListItem);
        const expectedTags = haveNewTagRow ? rowCount - 2 : rowCount - 1;
        await this.validateExpectedTagCount(expectedTags);
        await this.validateNewTagRowExists();
    }
    /**
     * Finds the specified row and clicks specified command
     *
     * @param {EditableGrid.Row} row on which to execute the command.
     * @param {string} commandText command text to be clicked.
     */
    async findRowAndClickCommandButton(row, commandText) {
        const commandButton = await (0, BrowserAutomation_1.getBrowser)().wait(() => row
            .all(ToolbarItem_1.default)
            .filter((item) => item.hasAttributeValue("title", commandText))
            .first(), null, "Expected to find command button");
        await commandButton.click();
    }
    /**
     * Opens the context menu for row and clicks specified command
     *
     * @param {EditableGrid.Row} row on which open the conext menu.
     * @param {string} commandText command text to be clicked.
     */
    async openContextMenuForRowAndClickCommand(row, commandText) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const contextMenuButtons = await row.all(ToolbarItem_1.default);
            const contextMenuButton = contextMenuButtons[contextMenuButtons.length - 1];
            await contextMenuButton.click();
            return true;
        }, null, "Expected context menu toolbar item.");
        const contextMenu = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await this.tagEditorParent.getAncestor(async (element) => await element.hasClass("fxs-portal"))).element(ContextMenu_1.default);
        }, null, "Expected to find context menu.");
        const contextMenuItem = await contextMenu.findContextMenuItemByText(commandText);
        await contextMenuItem.click();
    }
    /**
     * Validates that grid has no duplicate tags.
     *
     * @param {number}cellIndex Cell index to validate.
     */
    async validateNoDuplicateTags(cellIndex = 0) {
        await this.setFocusToNewTagRow();
        const rowDictionary = new Map();
        for (const row of await this.tagsGrid.rows) {
            const cellText = await row.cells.get(cellIndex).getText();
            const rowDictionaryKeys = rowDictionary.keys();
            const rowDictionaryArray = Array.from(rowDictionaryKeys);
            if (rowDictionaryArray.includes(cellText)) {
                assert.fail(`Found a duplicate item in the tags grid: <${cellText}>`);
            }
            rowDictionary.set(cellText, true);
        }
    }
    /**
     * Validated no duplicate tags in editor.
     */
    async validateNoDuplicateTagsInEditors() {
        await this.validateNewTagRowExists();
        await this.setFocusToNewTagRow();
        //TODO andrewfo : once timvoll has the suggestions checked in, we can revisit this.
        //tagsGrid.Rows[tagsGrid.Rows.Count() - 1].Cells[0].Click();
        //var nameDropdown = webDriver.WaitUntil(
        //   () => tagsGrid.Rows[tagsGrid.Rows.Count() - 1].Cells[0].FindElement<DropDown>(),
        //   "Could not find the tag name dropdown.");
        //webDriver.WaitUntil(
        //    () => nameDropdown.Options.Count == expectedTagNames.Count(),
        //    () => BuildTagNamesErrorString(expectedTagNames, nameDropdown.Options.Select((o) => o.Text), ""));
        //ValidateNoDuplicatesInDropDown(nameDropdown, "name editor");
        //tagsGrid.Rows[tagsGrid.Rows.Count() - 1].Cells[2].Click();
        //var valueDropdown = webDriver.WaitUntil(
        //    () => tagsGrid.Rows[tagsGrid.Rows.Count() - 1].Cells[2].FindElement<DropDown>(),
        //    "Could not find the tag value dropdown.");
        //webDriver.WaitUntil(
        //    () => valueDropdown.Options.Count == expectedTagValues.Count(),
        //    () => BuildTagNamesErrorString(expectedTagValues, valueDropdown.Options.Select((o) => o.Text), ""));
        //ValidateNoDuplicatesInDropDown(valueDropdown, "value editor");
        //// Reset the focus to close the dropdown.
        //SetFocusToNewTagRow();
    }
    /**
     * Deletes all tags in the blade.
     *
     * @param useRowCommands to use the row commands.
     * @returns a promise that resolves after all tags are deleted.
     */
    async deleteAllTags(useRowCommands = false) {
        if (useRowCommands) {
            while ((await this.tagsGrid.rows.count()) > 1) {
                await this.findRowAndClickCommandButtonGivenRowIndex(0, PortalFxResources.listCommandDeleteListItem);
            }
            await this.validateNewTagRowExists();
        }
        else {
            const tagsBladeCommandBar = this.tagEditorBlade.findCommandBar();
            await (await tagsBladeCommandBar.getItem(PortalFxResources.tagsClientStrings.common.deleteAll)).click();
        }
    }
    /**
     * Finds the row and clicks specified command.
     *
     * @param rowIndex the row idndex.
     * @param commandText command to be clicked.
     * @returns a promise that resolves after the specified command is clicked.
     */
    async findRowAndClickCommandButtonGivenRowIndex(rowIndex, commandText) {
        const commandButton = await (0, BrowserAutomation_1.getBrowser)().wait(() => this.tagsGrid.rows
            .get(rowIndex)
            .all(ToolbarItem_1.default)
            .filter((item) => item.hasAttributeValue("title", commandText))
            .first(), null, "Expected to find command button");
        await commandButton.click();
    }
    /**
     * Opens the context and clicks specified command.
     *
     * @param rowIndex the row idndex.
     * @param commandText command to be clicked.
     * @returns a promise that resolves after the specified command is clicked.
     */
    async openContextMenuForRowAndClickCommandGivenRowIndex(rowIndex, commandText) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const contextMenuButtonCollection = await this.tagsGrid.rows.get(rowIndex).all(ToolbarItem_1.default);
            const contextMenuButton = contextMenuButtonCollection[contextMenuButtonCollection.length - 1];
            await contextMenuButton.click();
            return true;
        }, null, "Expected context menu toolbar item");
        const contextMenu = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const contextMenuElements = await this.tagEditorParent.getAncestor(async (element) => await element.hasClass("fxs-portal"));
            return contextMenuElements.element(ContextMenu_1.default);
        }, null, "Expected to find context menu");
        await contextMenu.item({ text: commandText }).click();
    }
    async validateNewTagRowDoesNotExist() {
        const count = await this.tagsGrid.rows.count();
        await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            try {
                return count === TagEditor.maximumNumberOfTagsPerResource;
            }
            catch {
                return false;
            }
        }, null, "Expected the new tag editor row to be absent");
    }
    async validateMaxTagsMessageExists() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const infobox = await this.tagEditorParent.elementOrDefaultAsync(Controls_1.InfoBox);
            if (infobox !== null) {
                if ((await infobox.getText()) ===
                    String.format("You have reached the maximum of {0} tags per resource.", TagEditor.maximumNumberOfTagsPerResource)) {
                    return true;
                }
            }
            else {
                return false;
            }
        }, null, "Expected the max tags reached message to be present");
    }
    async validateMaxTagsMessageDoesNotExist() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const infobox = await this.tagEditorParent.elementOrDefaultAsync(Controls_1.InfoBox);
            if (infobox !== null) {
                if ((await infobox.getText()) ===
                    String.format("You have reached the maximum of {0} tags per resource.", TagEditor.maximumNumberOfTagsPerResource)) {
                    return false;
                }
            }
            else {
                return true;
            }
        }, null, "Expected the max tags reached message to be absent");
    }
    async launchRelatedResourcesForTag(tagIndex) {
        if (this.inContextPane) {
            throw new Error("Cannot launch related resources for tag from context pane");
        }
        await this.findRowAndClickCommandButtonGivenRowIndex(tagIndex, "Show resources with tag");
    }
}
TagEditor.maximumNumberOfTagsPerResource = 50;
exports.default = TagEditor;
//# sourceMappingURL=TagEditor.js.map