"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const By_1 = require("../Locators/By");
const Constants_1 = require("../Constants");
const BrowserAutomation_1 = require("../BrowserAutomation");
const String = require("../Utils/String");
const RunScripts_1 = require("../Utils/RunScripts");
const editorCss = `.${Constants_1.CssClassNames.Controls.editor}`;
const editorVMFmt = `ko.dataFor($("${editorCss}")[0]).{0}`;
const intellisenseCss = ".suggest-widget";
const viewModelErrFmt = "Ensure correct Editor.viewModelName is set. {0}";
/**
 * Represents a Editor.
 */
class Editor extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        /**
         * The view model property name on the editor contract
         */
        this.viewModelName = "editorVM";
        /**
         * The textarea element.
         */
        this.textarea = this.element(By_1.default.tagName("textarea"));
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(editorCss);
    }
    /**
     * Enters the specified text in the Editor.
     *
     * @param var_args The text to enter.
     * @returns A promise that resolves when the text has been entered.
     */
    async sendKeys(...var_args) {
        // eslint-disable-next-line prefer-spread
        return await this.textarea.sendKeys.apply(this.textarea, var_args);
    }
    /**
     * Gets the current content of the Editor.
     *
     * @returns A promise that will resolve with the current value of the Editor.
     */
    async read() {
        try {
            const content = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return ${String.format(editorVMFmt, this.viewModelName)}.content();`), async (pw) => await pw.executeScript(`${String.format(editorVMFmt, this.viewModelName)}.content()`));
            return content;
        }
        catch (err) {
            throw String.format(viewModelErrFmt, err);
        }
    }
    /**
     * Sets the content of the Editor.
     *
     * @param content: The content being written
     * @returns A promise that will resolve after setting the content.
     */
    async write(content) {
        try {
            await (0, RunScripts_1.runScript)(`${String.format(editorVMFmt, this.viewModelName)}.content("${content}");`);
            return null;
        }
        catch (err) {
            throw String.format(viewModelErrFmt, err);
        }
    }
    /**
     * empty the content of the Editor.
     *
     * @returns A promise that will resolve after emptying the content.
     */
    async empty() {
        return await this.write("");
    }
    /**
     * Returns a value that determines whether the editor is disabled.
     *
     * @returns A promise that resolves to a value that determines whether the editor is disabled.
     */
    async isDisabled() {
        try {
            const disabled = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return ${String.format(editorVMFmt, this.viewModelName)}.disabled();`), async (pw) => await pw.executeScript(`${String.format(editorVMFmt, this.viewModelName)}.disabled()`));
            return disabled;
        }
        catch (err) {
            throw String.format(viewModelErrFmt, err);
        }
    }
    /**
     * Returns a value that determines whether the intellisense window appeared.
     *
     * @returns A promise that resolves to the boolean that determines whether the intellisense window appeared.
     */
    async isIntellisenseUp() {
        const isUp = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return $("${intellisenseCss}").length > 0;`), async (pw) => await pw.executeScript(`$("${intellisenseCss}").length > 0`));
        return isUp;
    }
    /**
     * Internal method used for testing purpose.
     * Returns a number of worker IFrames created by the editor.
     *
     * @returns A promise that resolves to the number of the worker IFrames.
     */
    async workerIFramesCount() {
        const count = await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return $("iframe[id*='worker_iframe_']").length;`), async (pw) => await pw.executeScript(`$("iframe[id*='worker_iframe_']").length`));
        return count;
    }
}
exports.default = Editor;
//# sourceMappingURL=Editor.js.map