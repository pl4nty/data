"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseGrid = exports.BaseView = exports.BaseRow = exports.BaseCell = exports.BaseColumnHeader = exports.SortDirection = void 0;
const BrowserAutomation_1 = require("../BrowserAutomation");
const PortalElement_1 = require("../PortalElement");
const Constants = require("../Constants");
const By_1 = require("../Locators/By");
const String = require("../Utils/String");
const Logger_1 = require("../Logger");
const Toolbar_1 = require("./Toolbars/Toolbar");
const Array_1 = require("../Utils/Array");
/**
 * Represents a grid column sort direction.
 */
var SortDirection;
(function (SortDirection) {
    /**
     * Data is sorted in ascending order.
     */
    SortDirection[SortDirection["Ascending"] = 1] = "Ascending";
    /**
     * Data is sorted in descending order.
     */
    SortDirection[SortDirection["Descending"] = -1] = "Descending";
    /**
     * Data is not sorted.
     */
    SortDirection[SortDirection["Unsorted"] = 0] = "Unsorted";
})(SortDirection || (exports.SortDirection = SortDirection = {}));
/**
 * Base class representing a grid column header.
 */
class BaseColumnHeader extends PortalElement_1.default {
    /**
     * Gets the text of the header.
     */
    async getText() {
        const isDisplayed = await this.isDisplayed();
        // The header is not obviously scrollable because it is controled by the table element and scripting
        // Grid reflow may add horizontal scroll requirements to grids that previously did not scroll
        // To keep test compatibility we allow getting the text without scrolling
        if (!isDisplayed) {
            const text = await this.getAttribute("innerText");
            return text ? text.trim() : text;
        }
        return await super.getText();
    }
}
exports.BaseColumnHeader = BaseColumnHeader;
/**
 * Base class representing a grid cell.
 */
class BaseCell extends PortalElement_1.default {
    /**
     * Gets the text of the cell.
     */
    async getText() {
        const isDisplayed = await this.isDisplayed();
        // Grid reflow may add horizontal scroll requirements to grids that previously did not scroll
        // To keep test compatibility we allow getting the text without scrolling
        if (!isDisplayed) {
            const text = await this.getAttribute("innerText");
            return text ? text.trim() : text;
        }
        return await super.getText();
    }
}
exports.BaseCell = BaseCell;
/**
 * Base class to represent a grid row.
 */
class BaseRow extends PortalElement_1.default {
    /**
     * Constructs a base grid row.
     *
     * @param createCell Cell constructor.
     * @param elementArrayFinder Element array finder.
     */
    constructor(createCell, elementArrayFinder) {
        super(elementArrayFinder);
        this._createCell = createCell;
    }
    /**
     * The collection of cells.
     */
    get cells() {
        return this.all(this._createCell);
    }
    /**
     * Gets a value indicating whether or not this element is selected.
     */
    async isSelected() {
        const attribute = await this.getAttribute("aria-selected");
        return !String.isNullOrEmpty(attribute) && attribute.toLowerCase() === "true";
    }
    /**
     * Gets the first context menu in the row
     *
     * @returns The first context menu.
     */
    getContextMenuToolbar() {
        return this.element(By_1.default.css(".fxc-gc-margincell-contextmenu")).element(Toolbar_1.default);
    }
    /**
     * Gets a value indicating if this grid row is disabled.
     *
     * @returns A promise that resolves when the selected state is found.
     */
    async isDisabled() {
        const attribute = await this.getAttribute("aria-disabled");
        return !String.isNullOrEmptyOrUndefined(attribute) && attribute.toLowerCase() === "true";
    }
}
exports.BaseRow = BaseRow;
/**
 * Base class to represent a scrollable view port.
 */
class BaseView extends PortalElement_1.default {
    /**
     * Constructs a base grid row.
     *
     * @param elementArrayFinder Element array finder.
     */
    constructor(elementArrayFinder) {
        super(elementArrayFinder);
    }
    /**
     * Gets the vertical scroll position.
     */
    async getScrollTop() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollTop", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollTop`));
    }
    /**
     * Sets the vertical scroll position.
     */
    async setScrollTop(value) {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return arguments[0].scrollTop = ${value}`, this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollTop = ${value}`));
    }
    /**
     * Gets the horizontal scroll position.
     */
    async getScrollLeft() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollLeft", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollLeft`));
    }
    /**
     * Sets the horizontal scroll position.
     */
    async setScrollLeft(value) {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript(`return arguments[0].scrollLeft = ${value}`, this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollLeft = ${value}`));
    }
    /**
     * Gets the total scroll height.
     */
    async getScrollHeight() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollHeight", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollHeight`));
    }
    /**
     * Gets the viewport height.
     */
    async getHeight() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].clientHeight", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.clientHeight`));
    }
    /**
     * Gets the total scroll width.
     */
    async getScrollWidth() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollWidth", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollWidth`));
    }
    /**
     * Gets the viewport width.
     */
    async getWidth() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].clientWidth", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.clientWidth`));
    }
    /**
     * Indicates if the view can be scrolled horizontally.
     */
    async hasHorizontalScrollbar() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollWidth > arguments[0].clientWidth", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollWidth > htmlElem.clientWidth`));
    }
    /**
     * Indicates if the view can be scrolled vertically.
     */
    async hasVerticalScrollbar() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollHeight > arguments[0].clientHeight", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollHeight > htmlElem.clientHeight`));
    }
    /**
     * Scrolls the view to the top.
     */
    async scrollToTop() {
        return await this.setScrollTop(0);
    }
    /**
     * Scrolls the view to the bottom.
     */
    async scrollToBottom() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollTop = arguments[0].scrollHeight", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollTop = htmlElem.scrollHeight`));
    }
    /**
     * Scrolls the view to the bottom.
     */
    async scrollToLeft() {
        return await this.setScrollLeft(0);
    }
    /**
     * Scrolls the view to the bottom.
     */
    async scrollToRight() {
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].scrollLeft = arguments[0].scrollWidth", this), async () => await (await this.getWebElements())[0].executeScript(`(htmlElem) => htmlElem.scrollLeft = htmlElem.scrollWidth`));
    }
}
exports.BaseView = BaseView;
/**
 * Base class that represents a grid.
 */
class BaseGrid extends PortalElement_1.default {
    /**
     * Constructs a base grid.
     *
     * @param createRow Constructs a Row.
     * @param createCell Constructs a Cell.
     * @param createColumnHeader Constructs a ColumnHeader.
     * @param createView Constructs a View.
     * @param elementArrayFinder Element array finder.
     */
    constructor(createRow, createCell, createColumnHeader, createView, elementArrayFinder) {
        super(elementArrayFinder);
        this._createRow = createRow;
        this._createCell = createCell;
        this._createColumnHeader = createColumnHeader;
        this._createView = createView;
    }
    /**
     * Gets a collection of rows in the grid.
     */
    get rows() {
        return this.all(this._createRow);
    }
    /**
     * Gets a collection of column headers in the grid.
     */
    get columnHeaders() {
        return this.all(this._createColumnHeader);
    }
    /**
     * Gets a collection of all the cells in the grid.
     */
    get cells() {
        return this.all(this._createCell);
    }
    /**
     * Gets grid view port.
     */
    get view() {
        return this.all(this._createView).toPortalElement();
    }
    /**
     * Gets the total row count for the grid.
     */
    async getTotalRowCount() {
        const ariaRowCount = await this.getAttribute(Constants.CssClassNames.Grids.rowCount);
        return parseInt(ariaRowCount);
    }
    /**
     * Clicks the row that contains the specified text.
     *
     * @param options The set of options used to find the row.
     * @param {string} options.text The text that the row should contain.
     * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @returns A promise that resolves when the row has been clicked.
     */
    async clickRow(options) {
        return await this.findRow(options).then(async (row) => {
            await row.scrollIntoView();
            return row.click();
        });
    }
    /**
     * If multi-select is enabled, all the rows that contains the specified text will be selected.
     *
     * @param options The set of options used to find the row.
     * @param {string} options.text The text that the row should contain.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @returns A promise that resolves when all the rows has been selected.
     */
    async selectRows(options) {
        const selectPromises = [];
        options.texts.forEach((name) => {
            selectPromises.push(this.selectRow({ text: name, partialMatch: options.partialMatch }));
        });
        return await Promise.all(selectPromises);
    }
    /**
     * Performs a right click on the row that contains the specified text.
     *
     * @param options The set of options used to find the row.
     * @param {string} options.text The text that the row should contain.
     * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @returns A promise that resolves when the row has been right clicked.
     */
    async rightClickRow(options) {
        const row = await this.findRow(options);
        await row.scrollIntoView();
        return await row.rightClick();
    }
    /**
     * Finds a row that contains the specified text.
     *
     * @param options The set of options used to find the row.
     * @param {string} options.text The text that the row should contain.
     * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @param {number} [timeout] optional timeout to wait for the row to be present
     * @returns A promise that resolves with the found row.
     */
    async findRow(options, timeout) {
        let foundRows = [];
        let textToFind = options.text;
        if (options.caseInsensitive) {
            textToFind = textToFind.toLowerCase();
        }
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            await this.view.scrollToTop();
            const viewHeight = (await (await this.view.getWebElements())[0].getSize()).height;
            const scrollHeight = await this.view.getScrollHeight();
            let currScrollHeight = 0;
            while (foundRows.length === 0 && currScrollHeight < scrollHeight) {
                await this.view.setScrollTop(currScrollHeight);
                currScrollHeight += viewHeight;
                foundRows = await (0, Array_1.filterAsync)(await this.rows, async (row) => {
                    if (typeof options.cellIndex === "number") {
                        const cell = await row.cells;
                        let cellText = await cell[options.cellIndex].getText();
                        if (options.caseInsensitive) {
                            cellText = cellText.toLowerCase();
                        }
                        return options.partialMatch ? cellText.includes(textToFind) : cellText === textToFind;
                    }
                    else {
                        const texts = await Promise.all((await row.cells).map(async (cell) => {
                            try {
                                return await cell.getText();
                            }
                            catch (reason) {
                                Logger_1.default.warning(`getText() failed on a grid cell. Reason: ${reason.message}`);
                                return "";
                            }
                        }));
                        const match = texts.filter((text) => {
                            if (options.caseInsensitive) {
                                text = text.toLowerCase();
                            }
                            return options.partialMatch ? text.includes(textToFind) : text === textToFind;
                        });
                        return match.length > 0;
                    }
                });
            }
            return foundRows.length > 0;
        }, timeout, `grid.findRow timed out searching for ${options.text}`);
        return foundRows[0];
    }
    /**
     * Finds a cell that contains the specified text.
     *
     * @param options The set of options used to find the cell.
     * @param {string} options.text The text that the cell should contain.
     * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
     * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
     * @param {number} [timeout] optional timeout to wait for the cell to be present
     * @returns A promise that resolves with the found cell.
     */
    async findCell(options, timeout) {
        let foundCells;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            foundCells = this.cells.filter((cell) => {
                if (typeof options.cellIndex === "number") {
                    return cell.getText().then((cellText) => {
                        if (options.partialMatch) {
                            return cellText.includes(options.text);
                        }
                        else {
                            return cellText === options.text;
                        }
                    });
                }
                else {
                    return cell
                        .getText()
                        .catch((reason) => {
                        Logger_1.default.warning(`getText() failed on a grid cell. Reason: ${reason.message}`);
                        return "";
                    })
                        .then((text) => {
                        return options.partialMatch ? text.includes(options.text) : text === options.text;
                    });
                }
            });
            const count = await foundCells.count();
            return count > 0;
        }, timeout, `grid.findCell timed out searching for ${options.text}`);
        return foundCells.first();
    }
    /**
     * Returns a value that indicates whether the grid has rows.
     *
     * @returns A promise that resolves with a value that indicates whether the grid has rows.
     */
    async hasRows() {
        const count = await this.rows.count();
        return count > 0;
    }
    /**
     * Waits for columns of grid to load.
     *
     * @param {string[]} expectedColumns The texts of expected columns headers in order.
     */
    async waitForColumns(expectedColumns) {
        let actualColumnHeaders;
        let actualColumnCount;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            actualColumnHeaders = await this.columnHeaders.asPortalElements();
            actualColumnCount = actualColumnHeaders?.length;
            if (actualColumnCount !== expectedColumns.length) {
                return false;
            }
            for (let index = 0; index < expectedColumns.length; index++) {
                const actual = (await actualColumnHeaders[index].getText()).toLocaleLowerCase();
                const expected = expectedColumns[index].toLocaleLowerCase();
                if (actual.localeCompare(expected) !== 0) {
                    return false;
                }
            }
            return true;
        }, null, async () => {
            actualColumnHeaders && (await this.dumpColumns(expectedColumns, actualColumnHeaders));
            return `Columns never finished, expected <${expectedColumns.length}> columns, found <${actualColumnCount}>.`;
        });
    }
    /**
     * Waits for columnsSets..
     *
     * @param {string[][]} columnSets The string array of expected columns headers in order.
     */
    async waitForColumnSet(columnSets) {
        let columnSetIndex = -1;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            let actualColumnCount;
            const actualColumnHeaders = await this.columnHeaders.asPortalElements();
            const columnsHeadersTextArray = [];
            for (const actualColumnHeader of actualColumnHeaders) {
                columnsHeadersTextArray.push(await actualColumnHeader.getText());
            }
            columnSetIndex = columnSets.findIndex((columns) => {
                actualColumnCount = actualColumnHeaders.length;
                if (actualColumnCount !== columns.length) {
                    return false;
                }
                for (let index = 0; index < columns.length; index++) {
                    if (columnsHeadersTextArray[index]
                        .toLocaleLowerCase()
                        .localeCompare(columns[index].toLocaleLowerCase()) !== 0) {
                        return false;
                    }
                }
                return true;
            });
            return columnSetIndex >= 0;
        }, null, "Columns never finished");
        return columnSetIndex;
    }
    async dumpColumns(expectedColumns, columnHeadersAsPortalElements) {
        Logger_1.default.information(`Expected Columns:\n\t${expectedColumns.join("\n\t")}`);
        let actualColumns = "Actual:";
        for (const columnGeader of columnHeadersAsPortalElements) {
            actualColumns = actualColumns + `\n\t${(await columnGeader.getText()) + "\n\t"}`;
        }
        Logger_1.default.information(actualColumns);
        Logger_1.default.information("");
    }
    /**
     * Gets the grid caption.
     */
    async getCaption() {
        const element = this.element(By_1.default.tagName("caption"));
        return await (0, BrowserAutomation_1.runAutomation)(async (wd) => await wd.executeScript("return arguments[0].innerText", element), async () => await element.getText());
    }
}
exports.BaseGrid = BaseGrid;
//# sourceMappingURL=GridCommonBase.js.map