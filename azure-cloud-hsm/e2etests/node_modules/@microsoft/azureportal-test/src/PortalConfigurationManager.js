"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalContext_1 = require("./PortalContext");
const DefaultTimeouts_1 = require("./Utils/DefaultTimeouts");
const findup = require("findup-sync");
const fs = require("fs");
const Logger_1 = require("./Logger");
const BrowserAutomationType_1 = require("./BrowserAutomationType");
const ContextMode_1 = require("./ContextMode");
const defaultConfigFile = "./config.json"; // The path to the default config json file
const configJsonField = "configJson";
class PortalConfigurationManagerImpl {
    get configJsonPath() {
        return this._configJsonPath;
    }
    set configJsonPath(filePath) {
        const path = this.findConfigFile(filePath);
        if (path === null) {
            throw new Error(`The config json file was not found at the given path: ${filePath}`);
        }
        this._configJsonPath = path;
        const newConfigJson = this.readConfigFile();
        const keys = Object.keys(newConfigJson);
        for (const keyJson of keys) {
            const newValue = newConfigJson[keyJson];
            const defaultValue = this._configValuesDefault[keyJson];
            if (JSON.stringify(this._configValuesJson[keyJson]) === JSON.stringify(this._configValues[keyJson]) ||
                (defaultValue && JSON.stringify(newValue) !== JSON.stringify(defaultValue))) {
                this.set(keyJson, newValue);
            }
        }
        this._configValuesJson = newConfigJson;
    }
    constructor() {
        this._configValuesDefault = {
            signInUrl: "https://login.microsoftonline.com",
            portalUrl: "https://portal.azure.com",
            capabilities: {
                browserName: "chrome",
                chromeOptions: {
                    args: ["no-sandbox"],
                },
            },
            playwright: {
                browser: "chrome",
                resolution: {
                    width: 1280,
                    height: 960,
                },
                options: {
                    headless: false,
                    ignoreHTTPSErrors: true,
                },
                contextMode: ContextMode_1.ContextMode.Incognito,
            },
            browserAutomation: BrowserAutomationType_1.BrowserAutomationType.WebDriver,
        };
        this._configValues = { ...this._configValuesDefault }; // The config values that are actually used
        // Defining portal context so that it has all the default config properties
        this.portalContext = new PortalContextImpl();
        this.init();
    }
    init() {
        Logger_1.default.information("Initializing PortalConfigurationManager...");
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        this._configValuesArgv = process.argv;
        this._configValuesEnv = process.env;
        this._configValuesJson = {};
        Logger_1.default.information("Reading config values from argv, env, and config json...");
        const configJsonArgv = this.findConfigFile(this.getConfigArgv(configJsonField));
        const configJsonEnv = this.findConfigFile(this._configValuesEnv[configJsonField]);
        const configJsonDefault = this.findConfigFile(defaultConfigFile);
        this._configJsonPath = configJsonArgv || configJsonEnv || configJsonDefault;
        if (this._configJsonPath) {
            this._configValuesJson = this.readConfigFile();
        }
        // Helper lambda that defines a new property (key) on given target object
        const definePropertyIfNew = (target, key) => {
            if (!(key in target)) {
                Object.defineProperty(target, key, {
                    get: function () {
                        return that.get(key);
                    },
                    set: function (value) {
                        that.set(key, value);
                    },
                    enumerable: false,
                    configurable: true,
                });
            }
        };
        // Making portal context to be a proxy of itself
        // This allows to 'override' the default setter and getter of custom properties
        this.portalContext = new Proxy(this.portalContext, {
            set: function (target, key, value) {
                definePropertyIfNew(target, key);
                target[key] = value;
                return true;
            },
            get: function (target, key) {
                definePropertyIfNew(target, key);
                return target[key];
            },
        });
        Logger_1.default.information("Retrieving PortalContext config values...");
        const scrubMessage = (key, val) => {
            const redactedKeys = ["signInPassword", "silentAuthConfig"];
            return redactedKeys.includes(key) ? "[REDACTED]" : `'${JSON.stringify(val)}'`;
        };
        PortalContext_1.PortalContextPropNames.forEach((key) => {
            const valArgv = this.getConfigArgv(key);
            const valEnv = this.jsonify(this._configValuesEnv[key]);
            const valJson = this._configValuesJson[key];
            const valDefault = this._configValues[key];
            key = key;
            if (valArgv) {
                Logger_1.default.diagnostics("Using value for '" + key + "' from argv: " + scrubMessage(key, valArgv));
                this._configValues[key] = valArgv;
            }
            else if (valEnv) {
                Logger_1.default.diagnostics("Using value for '" + key + "' from env: " + scrubMessage(key, valEnv));
                this._configValues[key] = valEnv;
            }
            else if (valJson) {
                Logger_1.default.diagnostics("Using value for '" + key + "' from config json file: " + scrubMessage(key, valJson));
                this._configValues[key] = valJson;
            }
            else if (valDefault) {
                Logger_1.default.diagnostics("Using default value for '" + key + "': '" + valDefault + "'");
            }
            else {
                Logger_1.default.diagnostics("Value for '" + key + "' does not exist in either argv, env, config json file, or defaults");
            }
        });
        Logger_1.default.information("PortalConfigurationManager has been initialized...");
    }
    /**
     * Gets the given config value
     *
     * @param key the name of the config value to retrieve
     * @returns the config value if its set, else undefined
     */
    get(key) {
        if (!this._configValues[key]) {
            const valArgv = this.getConfigArgv(key);
            const valEnv = this.jsonify(this._configValuesEnv[key]);
            const valJson = this._configValuesJson[key];
            this._configValues[key] = valArgv ?? valEnv ?? valJson;
        }
        return this._configValues[key];
    }
    /**
     * Sets the config value.
     * If the value was provided in argv or env, the config value will not be reset
     *
     * @param key the name of the value to set
     * @param value the value to set it to
     */
    set(key, value) {
        Logger_1.default.information("Trying to set the value for '" + key + "'...");
        const isValArgv = ![null, undefined].includes(this.getConfigArgv(key));
        const isValEnv = ![null, undefined].includes(this.jsonify(this._configValuesEnv[key]));
        if (isValArgv || isValEnv) {
            Logger_1.default.information(`The value already provided in ${isValArgv ? "argv" : "env"}. Setting the value in code will have no effect.`);
        }
        else {
            this._configValues[key] = value;
        }
    }
    /**
     * Tries to convert a value to json format, returns the original value if it can't
     *
     * @param value to be converted
     * @returns value converted to json or the original value if conversion failed
     */
    jsonify(value) {
        if ([null, undefined].includes(value)) {
            return null;
        }
        const reSingle = /'/g;
        const reDouble = /"/g;
        try {
            const json = value.toString().replace(reSingle, reDouble);
            return JSON.parse(json);
        }
        catch {
            return value;
        }
    }
    /**
     * Retrieves a value from argument line if it exists
     *
     * @param key value of which will be retrieved
     * @returns value of the key or null of it doesn't exist
     */
    getConfigArgv(key) {
        const configIndex = this._configValuesArgv.indexOf("--" + key);
        const argvLength = this._configValuesArgv.length;
        // Checking whether the key exists, its value is not out of bounds, and the value was provided
        if (configIndex > -1) {
            if (configIndex < argvLength - 1 && !this._configValuesArgv[configIndex + 1].startsWith("--")) {
                return this.jsonify(this._configValuesArgv[configIndex + 1]);
            }
            else {
                throw new Error("Not enough arguments following: " + key);
            }
        }
        return null;
    }
    /**
     * Finds a config file given its path
     *
     * @param path - path to the config file
     * @returns absolute path to the config file or null if the file doesn't exist
     */
    findConfigFile(path) {
        if (!path) {
            return null;
        }
        try {
            Logger_1.default.diagnostics("Looking for config json file on the path: " + path);
            return findup(path);
        }
        catch {
            Logger_1.default.diagnostics("Unable to find config json file on the given path!");
            return null;
        }
    }
    /**
     * Reads the config file from the path set in this.configJsonPath
     *
     * @returns config JSON object
     */
    readConfigFile() {
        Logger_1.default.diagnostics("Reading config json");
        const configJson = fs.readFileSync(this._configJsonPath, "utf8").toString();
        return JSON.parse(configJson.replace(/^\uFEFF/, ""));
    }
}
/**
 * Represents the set of options used to configure a Portal instance.
 * Retrieves values from the PortalConfigurationManager object.
 */
class PortalContextImpl {
    validateConfig(key, value, expectedTypes) {
        if (value === null || value === undefined) {
            return;
        }
        const isValid = expectedTypes.some((type) => (type === "array" ? Array.isArray(value) : typeof value === type));
        if (!isValid) {
            throw new Error(`The value passed for the key '${key}' is invalid!\nCorrect type(s): ${expectedTypes.toString()}. Passed type: ${typeof value}`);
        }
    }
    /**
     * The browserstack url the tests should run on.
     */
    get browserStackUrl() {
        return PortalConfigurationManager.get("browserStackUrl");
    }
    set browserStackUrl(value) {
        this.validateConfig("portalContext.browserStackUrl", value, ["string"]);
        PortalConfigurationManager.set("browserStackUrl", value);
    }
    /**
     * The set of playwright browser automation.
     */
    get playwright() {
        return PortalConfigurationManager.get("playwright");
    }
    set playwright(value) {
        this.validateConfig("portalContext.playwright.browser", value?.browser, ["string"]);
        this.validateConfig("portalContext.playwright.options", value?.options, ["object"]);
        this.validateConfig("portalContext.playwright.resolution.width", value?.resolution?.width, ["number"]);
        this.validateConfig("portalContext.playwright.resolution.height", value?.resolution?.height, ["number"]);
        this.validateConfig("portalContext.playwright.contextMode", value?.contextMode, ["string"]);
        this.validateConfig("portalContext.playwright.userDataDir", value?.userDataDir, ["string"]);
        PortalConfigurationManager.set("playwright", value);
    }
    /**
     * The set of capabilities enabled in the webdriver session.
     * For a list of available capabilities, see https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities
     */
    get capabilities() {
        return PortalConfigurationManager.get("capabilities");
    }
    set capabilities(value) {
        this.validateConfig("portalContext.capabilities.browserName", value?.browserName, ["string"]);
        this.validateConfig("portalContext.capabilities.chromeOptions.args", value?.chromeOptions?.args, ["array"]);
        for (let i = 0; i < value?.chromeOptions?.args?.length; i++) {
            this.validateConfig(`portalContext.capabilities.chromeOptions.arg\[${i}\]`, value.chromeOptions.args[i], [
                "string",
            ]);
        }
        this.validateConfig("portalContext.capabilities.browserResolution.width", value?.browserResolution?.width, [
            "number",
        ]);
        this.validateConfig("portalContext.capabilities.browserResolution.height", value?.browserResolution?.height, [
            "number",
        ]);
        PortalConfigurationManager.set("capabilities", value);
    }
    /**
     * The path to the ChromeDriver binary.
     */
    get chromeDriverPath() {
        return PortalConfigurationManager.get("chromeDriverPath");
    }
    set chromeDriverPath(value) {
        this.validateConfig("portalContext.chromeDriverPath", value, ["string"]);
        PortalConfigurationManager.set("chromeDriverPath", value);
    }
    /**
     * The url of the Portal.
     */
    get portalUrl() {
        return PortalConfigurationManager.get("portalUrl");
    }
    set portalUrl(value) {
        this.validateConfig("portalContext.portalUrl", value, ["string"]);
        PortalConfigurationManager.set("portalUrl", value);
    }
    /**
     * The url of the page where signin is performed.
     */
    get signInUrl() {
        return PortalConfigurationManager.get("signInUrl");
    }
    set signInUrl(value) {
        this.validateConfig("portalContext.signInUrl", value, ["string"]);
        PortalConfigurationManager.set("signInUrl", value);
    }
    /**
     * Email of the user used to sign in to the Portal.
     */
    get signInEmail() {
        return PortalConfigurationManager.get("signInEmail");
    }
    set signInEmail(value) {
        this.validateConfig("portalContext.signInEmail", value, ["string"]);
        PortalConfigurationManager.set("signInEmail", value);
    }
    /**
     * Password of the user used to sign in to the Portal.
     */
    get signInPassword() {
        return PortalConfigurationManager.get("signInPassword");
    }
    set signInPassword(value) {
        this.validateConfig("portalContext.signInPassword", value, ["string"]);
        PortalConfigurationManager.set("signInPassword", value);
    }
    /**
     * Flag to enable silent auth while logging in
     */
    get useSilentAuthLogin() {
        return PortalConfigurationManager.get("useSilentAuthLogin");
    }
    set useSilentAuthLogin(value) {
        PortalConfigurationManager.set("useSilentAuthLogin", value);
    }
    /**
     * The set of features to enable while navigating within the Portal.
     */
    get silentAuthConfig() {
        return PortalConfigurationManager.get("silentAuthConfig");
    }
    set silentAuthConfig(value) {
        PortalConfigurationManager.set("silentAuthConfig", value);
    }
    /**
     * The set of features to enable while navigating within the Portal.
     */
    get features() {
        return PortalConfigurationManager.get("features");
    }
    set features(value) {
        this.validateConfig("portalContext.features", value, ["array"]);
        for (let i = 0; i < value?.length; i++) {
            this.validateConfig(`portalContext.features\[${i}\].name`, value[i].name, ["string"]);
            this.validateConfig(`portalContext.features\[${i}\].value`, value[i].value, ["string"]);
        }
        PortalConfigurationManager.set("features", value);
    }
    /**
     * The list of patch files to load within the Portal.
     */
    get patches() {
        return PortalConfigurationManager.get("patches");
    }
    set patches(value) {
        const isArray = Array.isArray(value);
        this.validateConfig("portalContext.patches", value, ["array", "string"]);
        if (isArray) {
            for (let i = 0; i < value.length; i++) {
                this.validateConfig(`portalContext.patches\[${i}\]`, value[i], ["string"]);
            }
        }
        PortalConfigurationManager.set("patches", !value || isArray ? value : value.split(","));
    }
    /**
     * Flag to enable executing the provided patches in Portal shell in addition to the extensions
     */
    get patchShell() {
        return PortalConfigurationManager.get("patchShell");
    }
    set patchShell(value) {
        this.validateConfig("portalContext.patchShell", value, ["boolean"]);
        PortalConfigurationManager.set("patchShell", value);
    }
    /**
     * The set of extensions to side load while navigating within the Portal.
     */
    get testExtensions() {
        return PortalConfigurationManager.get("testExtensions");
    }
    set testExtensions(value) {
        this.validateConfig("portalContext.testExtensions", value, ["array"]);
        for (let i = 0; i < value?.length; i++) {
            this.validateConfig(`portalContext.testExtensions\[${i}\].name`, value[i].name, ["string"]);
            this.validateConfig(`portalContext.testExtensions\[${i}\].value`, value[i].uri, ["string"]);
            this.validateConfig(`portalContext.testExtensions\[${i}\].obsoleteBundlesBitmask`, value[i].obsoleteBundlesBitmask, ["number"]);
        }
        PortalConfigurationManager.set("testExtensions", value);
    }
    /**
     * The set of timeouts used to override the default timeouts.
     * e.g.
     * timeouts: {
     *      timeout: 15000  //Overrides the default short timeout of 10000 (10 seconds).
     *      longTimeout: 70000 //Overrides the default long timetout of 60000 (60 seconds).
     * }
     */
    get timeouts() {
        return PortalConfigurationManager.get("timeouts");
    }
    set timeouts(value) {
        const timeoutValues = {};
        Object.keys(DefaultTimeouts_1.default).forEach((key) => {
            const timeoutKey = key;
            const timeoutValue = value ? value[timeoutKey] || DefaultTimeouts_1.default[timeoutKey] : DefaultTimeouts_1.default[timeoutKey];
            this.validateConfig(`portalContext.timeouts.${timeoutKey}`, timeoutValue, ["number"]);
            timeoutValues[timeoutKey] = timeoutValue;
        });
        PortalConfigurationManager.set("timeouts", timeoutValues);
    }
    /**
     * browser session Id
     */
    get sessionId() {
        return PortalConfigurationManager.get("sessionId");
    }
    set sessionId(value) {
        this.validateConfig("portalContext.sessionId", value, ["string"]);
        PortalConfigurationManager.set("sessionId", value);
    }
    /**
     * fake user Id
     */
    get fakeUser() {
        return PortalConfigurationManager.get("fakeUser");
    }
    set fakeUser(value) {
        this.validateConfig("portalContext.fakeUser", value, ["string"]);
        PortalConfigurationManager.set("fakeUser", value);
    }
    /**
     * Partner team running the tests.
     */
    get partnerTeamEmail() {
        return PortalConfigurationManager.get("partnerTeamEmail");
    }
    set partnerTeamEmail(value) {
        this.validateConfig("portalContext.partnerTeamEmail", value, ["string"]);
        PortalConfigurationManager.set("partnerTeamEmail", value);
    }
    /**
     * Browser automation type to use.
     */
    get browserAutomation() {
        return PortalConfigurationManager.get("browserAutomation").toLowerCase();
    }
    set browserAutomation(value) {
        this.validateConfig("portalContext.browserAutomation", value, ["string"]);
        PortalConfigurationManager.set("browserAutomation", value.toLowerCase());
    }
    /**
     * Tenant id to navigate to.
     */
    get tenantId() {
        return PortalConfigurationManager.get("tenantId");
    }
    set tenantId(value) {
        this.validateConfig("portalContext.tenantId", value, ["string"]);
        PortalConfigurationManager.set("tenantId", value);
    }
    /**
     * Flag to enable collection of code coverage data (Playwright only)
     */
    get codeCoverage() {
        return PortalConfigurationManager.get("codeCoverage");
    }
    set codeCoverage(value) {
        this.validateConfig("portalContext.codeCoverage", value, ["boolean"]);
        PortalConfigurationManager.set("codeCoverage", value);
    }
    /**
     * An array of paths to source files for code coverage analysis (Playwright only)
     */
    get codeCoverageOptions() {
        return PortalConfigurationManager.get("codeCoverageOptions");
    }
    set codeCoverageOptions(value) {
        this.validateConfig("portalContext.codeCoverageOptions.exclude", value?.exclude, ["array", "string"]);
        if (Array.isArray(value?.exclude)) {
            for (let i = 0; i < value.exclude.length; i++) {
                this.validateConfig(`portalContext.codeCoverageOptions.exclude\[${i}\]`, value.exclude[i], ["string"]);
            }
        }
        this.validateConfig("portalContext.codeCoverageOptions.includeJsOnly", value?.includeJsOnly, ["boolean"]);
        this.validateConfig("portalContext.codeCoverageOptions.onlySources", value?.onlySources, ["boolean"]);
        this.validateConfig("portalContext.codeCoverageOptions.sources", value?.sources, ["array", "string"]);
        if (Array.isArray(value?.sources)) {
            for (let i = 0; i < value.sources.length; i++) {
                this.validateConfig(`portalContext.codeCoverageOptions.sources\[${i}\]`, value.sources[i], ["string"]);
            }
        }
        PortalConfigurationManager.set("codeCoverageOptions", value);
    }
}
/**
 * The global PortalConfigurationManager object that contains configuration for the msportalfx-test framework Portal object to be used for tests.
 * The config hierarchy is args, environment variables, user set values via code, and config json file.
 */
const PortalConfigurationManager = new PortalConfigurationManagerImpl();
Logger_1.default.information("Initializing and validating PortalContext...");
PortalContext_1.PortalContextPropNames.forEach((key) => {
    // Self-assigning portal context values to trigger type validation
    const configVal = PortalConfigurationManager.portalContext[key];
    PortalConfigurationManager.portalContext[key] = configVal;
});
Logger_1.default.information("PortalContext has been initialized...");
exports.default = PortalConfigurationManager;
//# sourceMappingURL=PortalConfigurationManager.js.map