"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const By_1 = require("../Locators/By");
const DashboardFilterPill_1 = require("./DashboardFilterPill");
const BrowserAutomation_1 = require("../BrowserAutomation");
const AddPillButton_1 = require("../AddPillButton");
const String = require("../Utils/String");
const PortalShell_1 = require("../PortalShell");
const StartBoard_1 = require("../StartBoard");
/**
 * Represents a Pill List Item.
 */
class DashboardFilters extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.rootClassName = "fxc-pill-collection";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.rootClassName);
    }
    /**
     * Gets the dashboard's filter pills.
     */
    async pills() {
        return await this.all(DashboardFilterPill_1.default).asPortalElements();
    }
    /**
     * True if any pill is in edit mode.
     */
    async isInEditMode() {
        const allPills = await this.pills();
        for (const pill of allPills) {
            if (await pill.isInEditMode()) {
                return true;
            }
        }
    }
    /**
     * Waits until the widget is ready.
     */
    async waitUntilReady() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.isDisplayed();
        }, null, "The pill collection is not displayed.");
        return this;
    }
    /**
     * Waits until the widget is ready and its pills are read only.
     */
    async waitUntilReadyAndPillsAreReadOnly() {
        await this.waitUntilReady();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return !(await this.isInEditMode());
        }, null, "The dashboard filtering pills did not exit edit mode.");
        return this;
    }
    /**
     * Gets the dashboard's filter pill that is currently being edited.
     */
    async activePill() {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allPills = await this.pills();
            for (const pill of allPills) {
                if (await pill.isInEditMode()) {
                    return pill;
                }
            }
        }, null, "Unable to find a pill in edit mode");
    }
    /**
     * Get's the dashboard's filters add button.
     */
    async addButton() {
        let addButton;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                addButton = this.element(AddPillButton_1.default);
                return addButton !== null;
            }
            catch (Exception) {
                return false;
            }
        }, null, "Could not locate the add button");
        return addButton;
    }
    /**
     * Adds a dashboard filter pill. The pill will immediately enter edit mode.
     */
    async addFilterPill() {
        const addButton = await this.addButton();
        await (await addButton.waitUntilReady()).click();
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.activePill();
        }, null, "Did not observe a pill enter edit mode after clicking 'Add pill'");
    }
    /**
     * Exits the dashboard filter's edit mode.
     */
    async exitEditMode() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (await this.isInEditMode()) {
                const driver = (0, BrowserAutomation_1.getBrowser)();
                await (await driver.getActiveElement()).sendKeys(driver.Key.ESCAPE);
            }
            return !(await this.isInEditMode());
        }, null, "Unable to exit pill edit mode");
    }
    /**
     * Deletes the supplied pill from the pill collection.
     *
     * @param index The index of the pill to be removed.
     * @returns True if the pill was successfully deleted.
     */
    async deletePillAt(index) {
        const allPills = await this.pills();
        const pillAtIndex = allPills[index];
        // Given that pills can opt into the delete button being displayed,
        // throw an explicit error if the user tries to delete a pill
        // but its delete button is not visible.
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await pillAtIndex.deleteButton().isDisplayed();
        }, null, "The pill's delete button is not visible.");
        // Delete the pill.
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            // Click delete.
            await pillAtIndex.deleteButton().click();
            return true;
        }, null, `Unable to delete pill at index '${index}'.`);
    }
    /**
     * Checks the expected pills are present on dashboard or not.
     *
     * @param expectedCount the expected pill count to be verified.
     * @param waitForPillsReady  waits for the pills to appear.
     */
    async checkPills(expectedCount, waitForPillsReady = false) {
        if (waitForPillsReady) {
            await this.waitUntilReadyAndPillsAreReadOnly();
        }
        let filterPills = [];
        // check that the expected pills are on the dashboard.
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                filterPills = await this.pills();
                return expectedCount === filterPills.length;
            }
            catch {
                return false;
            }
        }, null, String.format("Didn't find the expected pills on the dashboard. Expected: <{0}> Actual: <{1}>", expectedCount, filterPills.length));
    }
    /**
     * Selects colors filter from the dropdown.
     *
     * @param filterBy the filter to apply.
     */
    async addFilter(filterBy) {
        const startBoard = PortalShell_1.default.getPortalShell().getPortalElement().element(StartBoard_1.default);
        await startBoard.waitForAllTilesLoaded();
        const newPill = await this.addFilterPill();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                // return true statemenet will never be reached unless next line doesn't throw.
                await (await newPill.filterIdDropdown()).selectOptionByText(filterBy);
                return true;
            }
            catch {
                return false;
            }
        }, null, "Unable to set id dropdown value");
        // Submit the filter
        await this.exitEditMode();
        await this.waitUntilReadyAndPillsAreReadOnly();
    }
}
exports.default = DashboardFilters;
//# sourceMappingURL=DashboardFilters.js.map