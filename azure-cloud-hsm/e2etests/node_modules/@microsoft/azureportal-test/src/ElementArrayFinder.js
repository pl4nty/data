"use strict";
/**
 * ------------------------------------------- START OF THIRD PARTY NOTICE -----------------------------------------
 * This file is based on or incorporates material from the projects listed below (Third Party IP).The original copyright notice and the license under which Microsoft received such Third Party IP, are set forth below.Such licenses and notices are provided for informational purposes only.Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.
 *
 * angular - protractor v3.0
 * Copyright(c) 2010- 2015 Google, Inc.
 *
 * Provided for Informational Purposes Only
 * MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ----------------------------------------------- END OF THIRD PARTY NOTICE ------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
const Locator_1 = require("./Locators/Locator");
const PortalElement_1 = require("./PortalElement");
const ReactView_1 = require("./Utils/ReactView");
const BrowserAutomation_1 = require("./BrowserAutomation");
const By_1 = require("./Locators/By");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const Logger_1 = require("./Logger");
const PlaywrightErrors_1 = require("./PlaywrightErrors");
/**
 * Represents an object to be used for operations on an array of elements.
 */
class ElementArrayFinder {
    /**
     * Gets an ElementArrayFinder that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @param locatorOptions optional locator. Works, when first parameter, subLocatorOrElementType is an element type.
     * @returns An ElementArrayFinder that matches the specified sub locator or element type.
     */
    static all(subLocatorOrElementType, locatorOptions) {
        return new ElementArrayFinder().all(subLocatorOrElementType, locatorOptions);
    }
    /**
     * Gets a PortalElement that matches the specified sub locator or element type.
     *
     * @param subLocatorOrElementType The sub locator or element type.
     * @returns A PortalElement that matches the specified sub locator or element type.
     */
    static element(subLocatorOrElementType) {
        return new ElementArrayFinder().all(subLocatorOrElementType).toPortalElement();
    }
    /**
     * Creates a new instance of this class.
     *
     * @param options The options used to create the new instance.
     * @param options.getWebElements A function that returns a list of the underlying Web Elements.
     * @param options.locator The locator specified when creating this ElementArrayFinder instance.
     * @param options.elementType The type of PortalElement that this ElementArrayFinder can produce.
     * @param options.actionResults An array of promises which will be retrieved with then. Resolves to the latest
     *  action result, or null if no action has been called.
     * @param options.frameId The id of the iframe that contains the web elements.
     */
    constructor(options) {
        this.getWebElements = options?.getWebElements;
        this.actionResults = options?.actionResults;
        this.locator = options?.locator;
        this.elementType = options?.elementType;
        this.frameId = options?.frameId;
    }
    /**
     * Returns a new ElementArrayFinder which would contain the children elements found (and could also be empty).
     *
     * @param locatorOrElementType The sublocator or the type of element from which the sublocator will be extracted.
     * @param locatorOptions optional locator. Works, when first parameter, locatorOrElementType is an element type.
     * @returns A new ElementArrayFinder.
     */
    all(locatorOrElementType, locatorOptions) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        let locator;
        let elementType;
        if (locatorOrElementType instanceof Locator_1.default) {
            locator = locatorOrElementType;
        }
        else {
            elementType = locatorOrElementType;
            if (locatorOptions) {
                locator = new elementType().buildLocator(locatorOptions);
            }
            else {
                locator = new elementType().locator;
            }
        }
        const getWebElements = (wait) => {
            if (!that.getWebElements) {
                return locator.findElements((0, BrowserAutomation_1.getBrowser)(), wait, PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout);
            }
            else {
                return that.getWebElements(wait).then((parentWebElements) => {
                    const childrenPromiseList = parentWebElements.map((parentWebElement) => {
                        if (parentWebElement === null) {
                            Logger_1.default.warning(`ElementArrayFinder.parentWebElement was null.  this.source.locator: ${this.locator?.toString()} that.source.locator  ${that.locator?.toString()}`);
                        }
                        return locator.findElements(parentWebElement, wait, PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout);
                    });
                    return Promise.all(childrenPromiseList).then((resolved) => {
                        return resolved.reduce((childrenList, resolvedE) => {
                            return childrenList.concat(resolvedE);
                        }, []);
                    });
                });
            }
        };
        return new ElementArrayFinder({
            getWebElements,
            locator,
            elementType,
            frameId: this.frameId,
        });
    }
    /**
     * Applies a filter function to each element within the ElementArrayFinder. This does not actually retrieve
     *      the underlying list of elements, so it can be used in page objects.
     *
     * @param filterFn Filter function that will test if an element should be returned. filterFn can either
     *      return a boolean or a promise that resolves to a boolean.
     * @returns A ElementArrayFinder that represents an array of elements that satisfy the filter function.
     */
    filter(filterFn) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        const getWebElements = () => {
            return that.getWebElements().then((parentWebElements) => {
                const list = parentWebElements.map((parentWebElement, index) => {
                    const portalElement = PortalElement_1.default.fromWebElement(parentWebElement, that.locator, that.elementType);
                    return filterFn(portalElement, index);
                });
                return Promise.all(list).then((resolvedList) => {
                    return parentWebElements.filter((_parentWebElement, index) => {
                        return resolvedList[index];
                    });
                });
            });
        };
        return new ElementArrayFinder({
            getWebElements,
            locator: this.locator,
            elementType: this.elementType,
            frameId: this.frameId,
        });
    }
    /**
     * Determines whether the specified function returns true for any element within the ElementArrayFinder.
     *
     * @param fn Function that will be tested. fn can either return a boolean or a promise that resolves to a boolean.
     * @returns A promise that resolves with a value that determines if the function returned true for any element within the ElementArrayFinder.
     */
    async some(fn) {
        const count = await this.filter(fn).count();
        return count > 0;
    }
    /**
     * Gets an element within the ElementArrayFinder by index. The index starts at 0.
     * Negative indices are wrapped (i.e. -i means ith element from last)
     * This does not actually retrieve the underlying element.
     *
     * @param {number} index Element index.
     * @returns The PortalElement that represents the element at the given index.
     */
    get(index) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        let indexPromise;
        if (typeof index === "number") {
            indexPromise = Promise.resolve(index);
        }
        else {
            indexPromise = index;
        }
        const getWebElements = async (wait) => {
            if (wait) {
                return (0, BrowserAutomation_1.getBrowser)().wait(async () => getWebElements(false));
            }
            const results = await Promise.all([indexPromise, that.getWebElements()]);
            let i = results[0];
            const parentWebElements = results[1];
            if (i < 0) {
                // wrap negative indices
                i = parentWebElements.length + i;
            }
            if (i < 0 || i >= parentWebElements.length) {
                throw new Error(
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `Index out of bound. Trying to access element at index: ${index}, but there are only ${parentWebElements.length} elements that match locator ${that.locator?.toString()}`);
            }
            return [parentWebElements[i]];
        };
        return new ElementArrayFinder({
            getWebElements,
            locator: this.locator,
            elementType: this.elementType,
            frameId: this.frameId,
        }).toPortalElement();
    }
    /**
     * Get the first matching element for the ElementArrayFinder. This does not actually retrieve the underlying element.
     *
     * @returns The PortalElement that represents the first matching element.
     */
    first() {
        return this.get(0);
    }
    /**
     * Gets the only matching element for the ElementArrayFinder.
     *
     * @returns The PortalElement if there is only a single matching element found, otherwise null.
     */
    async singleOrDefault() {
        const count = await this.count();
        if (count === 1) {
            return this.get(0);
        }
        return null;
    }
    /**
     * Returns a PortalElement representation of this ElementArrayFinder. It ensures
     * that the ElementArrayFinder resolves to one and only one underlying element.
     *
     * @returns A PortalElement representation.
     */
    toPortalElement() {
        let element;
        if (this.elementType) {
            element = new this.elementType(this, this.frameId);
        }
        else {
            element = new PortalElement_1.default(this, this.frameId);
        }
        return element;
    }
    /**
     * Counts the number of elements represented by the ElementArrayFinder.
     *
     * @returns A promise which resolves to the number of elements matching the locator.
     */
    async count() {
        return this.internalGetWebElements().then((arr) => {
            return arr.length;
        }, (err) => {
            const isNoSuchElemErr = (0, BrowserAutomation_1.runAutomationSync)((wd) => {
                return err instanceof wd.error.NoSuchElementError;
            }, () => {
                return err instanceof PlaywrightErrors_1.PlaywrightNoSuchElementError;
            });
            if (isNoSuchElemErr) {
                return 0;
            }
            throw err;
        });
    }
    /**
     * Represents the ElementArrayFinder as an array of PortalElements.
     *
     * @returns A promise which resolves to a list of PortalElements specified by the locator.
     */
    async asPortalElements() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const that = this;
        const arr = await this.internalGetWebElements();
        return arr.map((webElem) => {
            return PortalElement_1.default.fromWebElement(webElem, that.locator, that.elementType, this.frameId);
        });
    }
    /**
     * Retrieves the elements represented by the ElementArrayFinder. The input
     * function is passed to the resulting promise, which resolves to an
     * array of PortalElements.
     *
     * @param fn Function passed to the resulting promise.
     * @param errorFn Error function.
     * @returns A promise which will resolve to an array of ElementFinders represented by the ElementArrayFinder.
     */
    async then(fn, errorFn) {
        if (this.actionResults) {
            return await this.actionResults.then(fn, errorFn);
        }
        else {
            return await this.asPortalElements().then(fn, errorFn);
        }
    }
    /**
     * Calls the input function on each PortalElement represented by the ElementArrayFinder.
     *
     * @param fn Input function.
     */
    async each(fn) {
        await this.map(fn);
        return null;
    }
    /**
     * Applies a map function to each element within the ElementArrayFinder. The
     * callback receives the PortalElement as the first argument and the index as
     * a second arg.
     *
     * @param mapFn Map function that will be applied to each element.
     * @returns A promise that resolves to an array of values returned by the map function.
     */
    async map(mapFn) {
        const arr = await this.asPortalElements();
        const list = arr.map((portalElement, index) => {
            const mapResult = mapFn(portalElement, index);
            return Promise.resolve(mapResult);
        });
        return await Promise.all(list);
    }
    /**
     * Invokes the click function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async click(dialogCb) {
        return await this.performClick("left", dialogCb);
    }
    /**
     * Invokes a right click on the underlying web elements.
     *
     * @returns A promise that resolves when the right click resolves.
     */
    async rightClick() {
        return await this.performClick("right");
    }
    /**
     * Internal click function that invokes a click on the underlying web elements.
     *
     * @param {Button} mouseButton The button click to invoke.
     * @returns A promise that resolves when the right click resolves.
     */
    async performClick(mouseButton, dialogCb) {
        return await this.applyAction(async (webElem) => {
            return await webElem.click(mouseButton, dialogCb);
        });
    }
    /**
     * Invokes the getAttribute function on the underlying web elements.
     *
     * @param {string} attributeName The attribute to retrieve.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getAttribute(attributeName) {
        return await this.applyAction(async (webElem) => {
            return await webElem.getAttribute(attributeName);
        });
    }
    /**
     * Invokes the getCssValue function on the underlying web elements.
     *
     * @param {string} propertyName The attribute to retrieve.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getCssValue(propertyName) {
        return await this.applyAction(async (webElem) => {
            return await webElem.getCss(propertyName);
        });
    }
    /**
     * Invokes the sendKeys function on the underlying web elements.
     *
     * @param {string} var_args The text to send.
     * @returns A promise that resolves when the invoked function resolves.
     */
    async sendKeys(...var_args) {
        return await this.applyAction(async (webElem) => {
            return await webElem.sendKeys(...var_args);
        });
    }
    /**
     * Schedules a command to clear the value of this element.
     *
     * @returns A promise that will be resolved when the element has been cleared.
     */
    async clear() {
        return await this.applyAction(async (webElem) => {
            return await webElem.clear();
        });
    }
    /**
     * Invokes the getText function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getText() {
        return await this.applyAction(async (webElem) => {
            return await webElem.getText();
        });
    }
    /**
     * Invokes the getTagName function on the underlying web elements.
     *
     *  @returns A promise that resolves when the invoked function resolves
     */
    async getTagName() {
        return await this.applyAction(async (webElem) => {
            return await webElem.getTagName();
        });
    }
    /**
     * Invokes the getSize function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getSize() {
        return await this.applyAction(async (webElem) => {
            return await webElem.getSize();
        });
    }
    /**
     * Invokes the getLocation function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getLocation() {
        return await this.applyAction(async (webElem) => {
            return await webElem.getLocation();
        });
    }
    /**
     * Invokes the isDisplayed function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isDisplayed() {
        return await this.applyAction(async (webElem) => {
            return await webElem?.isDisplayed();
        });
    }
    /**
     * Invokes the isEnabled function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isEnabled() {
        return await this.applyAction(async (webElem) => {
            return await webElem?.isEnabled();
        });
    }
    async applyAction(actionFunction) {
        const callerError = new Error();
        const retryFunction = (0, PortalElement_1.retry)(this, actionFunction, "ElementArrayFinder.applyAction()");
        const applyActionImpl = async () => {
            try {
                const arr = await this.getWebElements(true);
                return await Promise.all(arr.map(retryFunction));
            }
            catch (reason) {
                reason.stack = "ElementArrayFinder.applyAction error: \n" + reason.stack + "\n" + callerError.stack;
                throw reason;
            }
        };
        return this.frameId
            ? await (0, ReactView_1.executeInReactViewIframe)(By_1.default.id(this.frameId), applyActionImpl)
            : await applyActionImpl();
    }
    async internalGetWebElements() {
        return await (this.frameId
            ? (0, ReactView_1.executeInReactViewIframe)(By_1.default.id(this.frameId), () => this.getWebElements())
            : this.getWebElements());
    }
    /**
     * Move the mouse pointer to specified location and right click.
     *
     * @returns A promise that resolves when mouse moves resolves.
     */
    async moveMouseAndRightClick(opt_offset) {
        return await this.applyAction(async (webElem) => {
            return await webElem.moveMouseAndClick(opt_offset, "right");
        });
    }
    /**
     * Move the mouse pointer to specified location and click.
     *
     * @returns A promise that resolves when mouse moves resolves.
     */
    async moveMouseAndLeftClick(opt_offset) {
        return await this.applyAction(async (webElem) => {
            return await webElem.moveMouseAndClick(opt_offset, "left");
        });
    }
    /**
     * Invokes the isSelected function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async isSelected() {
        return await this.applyAction(async (webElem) => {
            return await webElem.isSelected();
        });
    }
    /**
     * Invokes the getInputValue function on the underlying web elements.
     *
     * @returns A promise that resolves when the invoked function resolves.
     */
    async getInputValue() {
        return await this.applyAction(async (webElem) => {
            return await webElem.getInputValue();
        });
    }
}
exports.default = ElementArrayFinder;
//# sourceMappingURL=ElementArrayFinder.js.map