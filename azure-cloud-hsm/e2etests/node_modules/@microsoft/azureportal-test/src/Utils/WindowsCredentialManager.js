"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const os_1 = require("os");
const powershellScript = `
Param(
      [parameter(Mandatory=$true)]
      [string]$targetName
)

$nativeMethodWrapperSource = @"
    using System;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Text;

    namespace MsPortalFxUT
    {
        public static class NativeMethodHelpers
        {
            /// <summary>
            /// Read from Windows cred manager https://docs.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credreadw
            /// CredFree should be called on returned credentialPtr once done.
            /// </summary>
            /// <param name="targetName">pointer to null-terminated string that contains the name of the cred to read</param>
            /// <param name="credentialType">The CRED_TYPE_* https://docs.microsoft.com/en-us/windows/win32/api/wincred/ns-wincred-credentiala</param>
            /// <param name="flags">Always should be 0</param>
            /// <param name="credentialPtr">A credential pointer of to struct  https://docs.microsoft.com/en-us/windows/win32/api/wincred/ns-wincred-credentiala</param>
            /// <returns></returns>
            [DllImport("Advapi32.dll", EntryPoint = "CredReadW", CharSet = CharSet.Unicode, SetLastError = true)]
            internal static extern bool CredReadW(
                [MarshalAs(UnmanagedType.LPWStr)]
                string targetName,  //LPCWSTR TargetName. Pointer to a null-terminated string that contains the name of the credential to read.
                uint credentialType, //DWORD Type. Type of the credential to read. Type must be one of the CRED_TYPE_* defined types.
                uint flags,  //DWORD Flags. Currently reserved and must be zero.
                out IntPtr credentialPtr //PCREDENTIALW * Credential. Pointer to a single allocated block buffer to return the credential.
                );

            /// <summary>
            /// Free buffer returned by Cred* functions https://docs.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credfree
            /// </summary>
            /// <param name="buffer">Pointer to the buffer to be freed</param>
            [DllImport("Advapi32.dll", EntryPoint = "CredFree", CharSet = CharSet.Unicode, SetLastError = true)]
            internal static extern void CredFree([In] IntPtr buffer);

            /// <summary>
            /// Credential returned by CredReadW https://docs.microsoft.com/en-us/windows/win32/api/wincred/ns-wincred-credentiala
            /// </summary>
            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            internal struct Credential
            {
                public uint Flags; // DWORD Flags;
                public uint Type; // DWORD Type;
                [MarshalAs(UnmanagedType.LPWStr)]
                public string TargetName; // LPSTR TargetName;
                [MarshalAs(UnmanagedType.LPWStr)]
                public string Comment; // LPSTR Comment;
                public System.Runtime.InteropServices.ComTypes.FILETIME LastWritten; // FILETIME LastWritten;
                public uint CredentialBlobSize; // DWORD CredentialBlobSize;
                public IntPtr CredentialBlob; // LPBYTE CredentialBlob;
                public uint Persist; // DWORD Persist;
                public uint AttributeCount; // DWORD AttributeCount;
                public IntPtr Attributes; // PCREDENTIAL_ATTRIBUTEA Attributes;
                [MarshalAs(UnmanagedType.LPWStr)]
                public string TargetAlias; // LPSTR TargetAlias;
                [MarshalAs(UnmanagedType.LPWStr)]
                public string UserName; // LPSTR UserName;
            }

            public class CredResult : IDisposable
            {
                public CredResult(string targetName, string username, SecureString password)
                {
                    this.TargetName = targetName;
                    this.UserName = username;
                    this.Password = password;
                    this.Win32Error = 0;
                }

                public CredResult(int win32Error)
                {
                    this.Win32Error = win32Error;
                }

                public int Win32Error { get; private set; }
                public SecureString Password { get; private set; }
                public string UserName { get; private set; }
                public string TargetName { get; private set; }

                public void Dispose()
                {
                    if (Password != null)
                    {
                        Password.Dispose();
                        Password = null;
                    }
                }
            }

            public static CredResult GetCredential(string targetName)
            {
                const uint GenericType = 1;
                const uint requiredFlags = 0;
                IntPtr credentialPtr = IntPtr.Zero;
                CredResult result = null;
                byte[] passBytes = null;
                char[] passChars = null;
                try
                {
                    if (NativeMethodHelpers.CredReadW(targetName, GenericType, requiredFlags, out credentialPtr))
                    {
                        var cred = Marshal.PtrToStructure<Credential>(credentialPtr);

                        if (cred.CredentialBlob != IntPtr.Zero)
                        {
                            passBytes = new byte[cred.CredentialBlobSize];
                            Marshal.Copy(cred.CredentialBlob, passBytes, 0, (int)cred.CredentialBlobSize);
                            passChars = Encoding.Unicode.GetChars(passBytes);
                            var pass = new SecureString();

                            foreach (char c in passChars)
                            {
                                pass.AppendChar(c);
                            }

                            result = new CredResult(cred.TargetName, cred.UserName, pass);
                        }
                    }
                    else
                    {
                            result = new CredResult(Marshal.GetLastWin32Error());
                    }
                }
                finally
                {
                    if (credentialPtr != IntPtr.Zero)
                    {
                        NativeMethodHelpers.CredFree(credentialPtr);
                        credentialPtr = IntPtr.Zero;
                    }
                    if (passChars != null)
                    {
                        Array.Clear(passChars, 0, passChars.Length);
                        passChars = null;
                    }

                    if (passBytes != null)
                    {
                        Array.Clear(passBytes, 0, passBytes.Length);
                        passBytes = null;
                    }
                }

                return result;
            }
        }
    }

"@

try
{
  Add-Type -TypeDefinition $nativeMethodWrapperSource -Language CSharp
}
catch
{
    $Error.RemoveAt(0);
}


function Decrypt-SecureString
{
    param([System.Security.SecureString] $secPass)

    if($secPass -ne $null)
    {
        $marshal = [System.Runtime.InteropServices.Marshal]
        $passPtr = $marshal::SecureStringToBSTR( $secPass );
        $pass = $marshal::PtrToStringBSTR( $passPtr );
        $marshal::ZeroFreeBSTR( $passPtr )
        $pass
    }
    else
    {
        $null
    }
}

try
{
    $result = [MsPortalFxUT.NativeMethodHelpers]::GetCredential($targetName);
    $json = @{
        TargetName = $result.TargetName;
        UserName = $result.UserName;
        CredentialBlob = Decrypt-SecureString $result.Password;
        Win32Error = $result.Win32Error;
    } | ConvertTo-Json

    Write-Host $json;
}
finally
{
    if ($null -ne $result)
    {
        $result.Dispose()
    }
}`;
/**
 * Provides the ability to retrieve credentials from the Windows Credential Manager.
 */
class WindowsCredentialManager {
    /**
     * Gets the credential matching the given targetName from the Windows Credential Manager synchronously.
     *
     * @param targetName the target name of the credential to retrieve.
     * @returns an object containing the credential information.
     */
    static getWindowsCredentialSync(targetName) {
        this.assertSupportedPlatform();
        const inlineScript = `& {${powershellScript}}`;
        const powershellCommand = `${inlineScript} -targetName '${targetName}'`;
        const result = (0, child_process_1.spawnSync)("powershell.exe", ["-NoProfile", "-Command", powershellCommand]);
        return JSON.parse(result.stdout.toString());
    }
    /**
     * Gets the credential matching the given targetName from the Windows Credential Manager asynchronously.
     *
     * @param targetName the target name of the credential to retrieve.
     */
    static async getWindowsCredential(targetName) {
        this.assertSupportedPlatform();
        const inlineScript = `& {${powershellScript}}`;
        const powershellCommand = `${inlineScript} -targetName '${targetName}'`;
        const resultBuffer = await new Promise((res, rej) => {
            const { stdout, stderr } = (0, child_process_1.spawn)("powershell.exe", ["-NoProfile", "-Command", powershellCommand]);
            let data = "";
            stdout.on("data", (d) => {
                data += d;
            });
            stdout.on("end", () => {
                res(data);
            });
            stderr.on("data", (d) => {
                rej(d);
            });
        });
        return JSON.parse(resultBuffer.toString());
    }
    static assertSupportedPlatform() {
        const plat = (0, os_1.platform)();
        const rel = (0, os_1.release)();
        const isWsl = plat === "linux" && rel.toLowerCase().includes("microsoft");
        const isWindowsOrWSL = plat === "win32" || isWsl;
        if (!isWindowsOrWSL) {
            throw new Error(`WindowsCredentialManager is only supported on Windows or WSL. platform:${plat};release:${rel}`);
        }
    }
}
exports.default = WindowsCredentialManager;
//# sourceMappingURL=WindowsCredentialManager.js.map