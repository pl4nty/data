"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssStringSizeToInt = exports.isNullOrEmptyOrUndefined = exports.isNullOrUndefined = exports.isNullOrEmpty = exports.equalsIgnoringCase = exports.startsWith = exports.format = void 0;
const namedFormatSpecifierRegex = /\{[\w$]*\}/g;
const numberedFormatSpecifierRegex = /\{(\d+)\}/g;
/**
 * Formats a string based on its key value pair object.
 *
 * @param args The list of arguments format arguments. For example: "String with params {0} and {1}".format("val1", "val2");.
 * @returns Formatted string.
 */
function format(value, ...restArgs) {
    // this code is duplicated in StringUtil.ts. please update both locations with any changes.
    // all subsequent lines are written in a manner that allows both implementations to be identical.
    // please try to maintain that behavior.
    let matched = false;
    let retVal;
    if (restArgs && restArgs.length === 1 && restArgs[0] && typeof restArgs[0] === "object") {
        const actualArg = restArgs[0];
        retVal = value.replace(namedFormatSpecifierRegex, (match) => {
            const name = match.substring(1, match.length - 1);
            // eslint-disable-next-line no-prototype-builtins
            if (actualArg.hasOwnProperty(name)) {
                matched = true;
                return actualArg[name];
            }
            else {
                return match;
            }
        });
    }
    // we get here in two cases:
    //    1. arguments has more than one entry. this is the normal usage.
    //    2. arguments was an object but it's properties didn't match any of the named parameters.
    //       this often happens when developers write code like:
    //          try {
    //              ...
    //          } catch(err) {
    //              log("abc: {0}".format(err));
    //          }
    //       in this scenario also we want to match by number.
    //
    if (!matched) {
        retVal = value.replace(numberedFormatSpecifierRegex, (match, num) => {
            return num < restArgs.length ? restArgs[num] : match;
        });
    }
    return retVal;
}
exports.format = format;
/**
 * Determines if the current string starts with the given string.
 *
 * @param value The value to check if the current string starts with.
 * @returns Boolean true if the current string starts with the given string, else false.
 */
function startsWith(source, searchString) {
    return source.startsWith(searchString);
}
exports.startsWith = startsWith;
function equalsIgnoringCase(source, other) {
    return source.localeCompare(other, undefined, { sensitivity: "base" }) === 0;
}
exports.equalsIgnoringCase = equalsIgnoringCase;
function isNullOrEmpty(value) {
    return value === null || value === "";
}
exports.isNullOrEmpty = isNullOrEmpty;
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNullOrEmptyOrUndefined(value) {
    return value === null || value === "" || value === undefined;
}
exports.isNullOrEmptyOrUndefined = isNullOrEmptyOrUndefined;
/**
 * Routine to convert the string css px sizes to their integer units.
 *
 * @param cssSize Source css pixels number to convert to int.
 * @returns An integer number equal to the number of pixels in the given css px size.
 */
function cssStringSizeToInt(cssSize) {
    if (cssSize.endsWith("px")) {
        cssSize = cssSize.replace("px", "");
    }
    return Number(cssSize);
}
exports.cssStringSizeToInt = cssStringSizeToInt;
//# sourceMappingURL=String.js.map