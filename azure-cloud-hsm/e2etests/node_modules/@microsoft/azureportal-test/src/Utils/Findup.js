"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scan = void 0;
const fs = require("fs");
const path = require("path");
const Logger_1 = require("../Logger");
const sortDir = (a, b) => {
    const isADir = a.isDirectory();
    const isBDir = b.isDirectory();
    const nameA = a.name.toLowerCase();
    const nameB = b.name.toLowerCase();
    const bothSameType = (isADir && isBDir) || (!isADir && !isBDir);
    if ((!isADir && isBDir) || (bothSameType && nameA < nameB)) {
        return -1;
    }
    return 1;
};
const execFilter = (filterOptions, entry, fileDir) => {
    const { filter, noCase } = filterOptions;
    let partial = filterOptions.partial;
    const isFiterFunction = typeof filter === "function";
    const filterType = Array.isArray(filter) || isFiterFunction ? filter : [filter];
    if (isFiterFunction) {
        return filterType(entry, fileDir);
    }
    const CSCheck = (value) => (noCase ? value.toLowerCase() : value);
    const entryName = CSCheck(entry.name);
    const entryPath = CSCheck(path.join(fileDir, entryName));
    const matchCb = (entryValue, filterValue) => partial ? entryValue.includes(filterValue) : entryValue === filterValue;
    return filterType.some((filterEntry) => {
        const isFilterString = typeof filterEntry === "string";
        const filterSource = isFilterString ? filterEntry : filterEntry.source;
        const isBkslashInFilter = filterSource.includes("\\");
        const ifFwdslashInFilter = filterSource.includes("/");
        let entryValue = isBkslashInFilter || ifFwdslashInFilter ? entryPath : entryName;
        entryValue = ifFwdslashInFilter ? entryValue.replace(/\\/g, "/") : entryValue;
        partial = partial || isBkslashInFilter || ifFwdslashInFilter;
        return isFilterString ? matchCb(entryValue, CSCheck(filterEntry)) : filterEntry.test(entryValue);
    });
};
const getFiles = (dir, exclude) => {
    const currPath = path.resolve(process.cwd(), dir);
    const fileExists = fs.existsSync(currPath);
    if (!fileExists) {
        return [];
    }
    const isDirectory = fs.lstatSync(currPath).isDirectory();
    if (!isDirectory) {
        Logger_1.default.warning(`The given path is not a directory: '${currPath}'`);
        return [];
    }
    return fs
        .readdirSync(currPath, { withFileTypes: true })
        .filter((entry) => exclude === null || !execFilter(exclude, entry, currPath))
        .sort(sortDir);
};
const checkMatch = (dir, entry, match, includeDir) => {
    const currPath = path.resolve(process.cwd(), dir);
    const childPath = path.join(currPath, entry.name);
    const isDirectory = entry.isDirectory();
    const isMatching = (match === null || execFilter(match, entry, currPath)) && ((isDirectory && includeDir) || !isDirectory);
    return { childPath: childPath, isDirectory: isDirectory, isMatching: isMatching };
};
const scanParallel = (options) => {
    const { dir, exclude, includeDir, match } = options;
    const list = [];
    getFiles(dir, exclude).map((entry) => {
        const { childPath, isMatching, isDirectory } = checkMatch(dir, entry, match, includeDir);
        if (isMatching) {
            list.push(childPath);
        }
        if (isDirectory) {
            list.push(...scanParallel({ dir: childPath, exclude: exclude, includeDir: includeDir, match: match }));
        }
    });
    return list;
};
const scanSerial = (options) => {
    const { dir, exclude, includeDir, match } = options;
    let result = [];
    const entries = getFiles(dir, exclude);
    for (const entry of entries) {
        const { childPath, isMatching, isDirectory } = checkMatch(dir, entry, match, includeDir);
        if (isMatching) {
            result = [childPath];
        }
        else if (isDirectory) {
            result = scanSerial({ dir: childPath, exclude: exclude, includeDir: includeDir, match: match });
        }
        if (result.length > 0) {
            return result;
        }
    }
    return [];
};
/**
 * A robust scanner for files and/or directories based on given options.
 *
 * If no {@link ScanOptions.dir} is provided, the current working directory is used.
 * Parameter {@link ScanOptions.exclude} takes precedence over {@link ScanOptions.match}.
 * Parameter {@link ScanOptions.exclude} is tested against both directories and files while {@link ScanOptions.match} only tests against files
 * unless {@link ScanOptions.includeDir} is set to 'true'.
 *
 * The exclusion of a file/directory is done when {@link FilterOptions.filter} is truthy. This means that strings/regular expressions that match
 * the given filter or the callback that returns 'true' **will** get excluded from the search. For example, if you need to exclude a directory named
 * 'Tests' that is located inside a directory 'SDK', you can pass a callback
 * `(file: fs.Dirent, fileDir: string) => fileDir.endsWith("\\SDK") && file.isDirectory() && file.name === "Tests"`.
 *
 * @param {ScanOptions} [options] Scanner configuration that is used to determine what files to find. Look at {@link ScanOptions} for description.
 * @returns {string[]} An array of files found.
 */
function Scan(options) {
    const findAll = options?.findAll ?? false;
    const includeDir = options?.includeDir ?? false;
    let { dir, exclude, match } = options || { dir: null, exclude: null, match: null };
    dir = dir ? (Array.isArray(dir) ? dir : [dir]) : [process.cwd()];
    match = match ?? null;
    exclude = exclude ?? null;
    const scanOptions = (dirPath) => ({
        dir: dirPath,
        exclude: exclude,
        includeDir: includeDir,
        match: match,
    });
    let result = [];
    if (findAll) {
        dir.map((dirPath) => result.push(...scanParallel(scanOptions(dirPath))));
        return result;
    }
    for (const dirPath of dir) {
        result = scanSerial(scanOptions(dirPath));
        if (result.length > 0) {
            return result;
        }
    }
    return [];
}
exports.Scan = Scan;
//# sourceMappingURL=Findup.js.map