"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomNotificationsPane = void 0;
const By_1 = require("../Locators/By");
const ContextPane_1 = require("../ContextPane/ContextPane");
const PortalFxResources = require("../PortalFxResources");
const ActionsMenu_1 = require("../TopBar/ActionsMenu");
const String = require("../Utils/String");
const Notification_1 = require("./Notification");
const Logger_1 = require("../Logger");
const BrowserAutomation_1 = require("../BrowserAutomation");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
/**
 * Represents the Portal Notifications pane.
 */
class NotificationsPaneBase extends ContextPane_1.default {
    constructor() {
        super(...arguments);
        /**
         * The list of displayed notifications.
         */
        this.notifications = this.all(Notification_1.default);
    }
    // Checks if notifications pane is present, and if not will try to open it before checking for expected notifications.
    async handleMissingNotificationsPane(isPresent) {
        if (!isPresent) {
            const notificationsButton = ElementArrayFinder_1.default.element(By_1.default.className("fxs-topbar-notifications"));
            try {
                // Fetch and click actions menu item if and only if isDisplayed is false because command icons might be collapsed into drop menu.
                if (!(await notificationsButton.isDisplayed())) {
                    const actionsMenu = ElementArrayFinder_1.default.element(ActionsMenu_1.ActionsMenu);
                    await (await actionsMenu.getActionsMenuItem(PortalFxResources.notifications)).click();
                }
                else {
                    await notificationsButton.click();
                }
            }
            catch (reason) {
                if (reason.name) {
                    Logger_1.default.warning("Error " + reason.name + " caught at NotificationsPane.waitForNewNotification.");
                }
                else {
                    Logger_1.default.warning("Error caught at NotificationsPane.waitForNewNotification.");
                }
                throw reason;
            }
        }
    }
    // Asyncronous filter predicate that determines if the given notification contains the title, description, or combination of the two.
    async isMatchingNotification(notification, title, description) {
        let values;
        if (title && description) {
            values = await Promise.all([
                this.tryGetText(notification.title),
                this.tryGetText(notification.progressTitle),
                this.tryGetText(notification.description),
            ]);
            Logger_1.default.information(String.format("Notification has title '{0}', progress text '{1}', description '{2}'", values[0], values[1], values[2]));
            if (values[0]) {
                return values[0] === title && values[2] && values[2].includes(description);
            }
            else if (values[1]) {
                return values[1] === title && values[2] && values[2].includes(description);
            }
            return false;
        }
        else if (title) {
            values = await Promise.all([
                this.tryGetText(notification.title),
                this.tryGetText(notification.progressTitle),
            ]);
            Logger_1.default.information(String.format("Notification has title '{0}', progress text '{1}'", values[0], values[1]));
            if (values[0]) {
                return values[0] === title;
            }
            else if (values[1]) {
                return values[1] === title;
            }
            return false;
        }
        else if (description) {
            const text = await this.tryGetText(notification.description);
            Logger_1.default.information(String.format("Notification has description '{0}'", text));
            if (text) {
                return text.includes(description);
            }
            return false;
        }
    }
    // Asyncronous function that attempts to fetch the text property value in a notification (ie. title, description, etc.).
    async tryGetText(element) {
        try {
            if (await element.isPresent()) {
                return await element.getText();
            }
        }
        catch (reason) {
            if (reason.name) {
                Logger_1.default.warning("Error " + reason.name + " caught at NotificationsPane.tryGetText.");
            }
            else {
                Logger_1.default.warning("Error caught at NotificationsPane.tryGetText.");
            }
        }
        return "";
    }
    /**
     * Gets the total notification count.
     */
    async getNotificationCount() {
        return await this.notifications.count();
    }
    /**
     * Waits for a new notification to show up given the specified parameters. An error is thrown if the notification
     * does not show up after the timeout is reached.
     *
     * @param {string} title The notification title.
     * @param {string} description The notification description.
     * @param {number} timeout The time to wait, in milliseconds, for the notification to show up.
     * @returns The found Notification.
     */
    async waitForNewNotification(title, description, timeout) {
        if (!title && !description) {
            throw new Error("Either title or description must be specified.");
        }
        if (title && description) {
            Logger_1.default.information(String.format("Waiting for notification with title '{0}' and description '{1}'...", title, description));
        }
        else if (title) {
            Logger_1.default.information(String.format("Waiting for notification with title '{0}'...", title));
        }
        else if (description) {
            Logger_1.default.information(String.format("Waiting for notification with description '{0}'...", description));
        }
        let isPresent = false;
        try {
            isPresent = await this.isPresent();
        }
        catch (err) {
            Logger_1.default.warning(String.format("Failed to get isPresent status on NotificationsPane PortalElement. Error: '{0}'", err));
        }
        const timeoutMessage = String.format("Timed out waiting for new notification to appear.  Title: '{0}', description: '{1}'. ", title || "(null)", description || "(null)");
        const checkForNotification = async () => {
            return await (0, BrowserAutomation_1.getBrowser)().wait(async () => this.waitForNotificationCondition(title, description), timeout, timeoutMessage);
        };
        await this.handleMissingNotificationsPane(isPresent);
        return await checkForNotification();
    }
    // Asyncronous condition function passed to the BrowserAutomation's wait function.
    async waitForNotificationCondition(title, description) {
        let count;
        try {
            count = await this.getNotificationCount();
            if (count > 0) {
                Logger_1.default.information(String.format("Found {0} notifications in the notifications pane...", count));
                const matchingNotifications = await this.notifications.filter(async (notification) => {
                    return await this.isMatchingNotification(notification, title, description);
                });
                if (matchingNotifications.length > 0) {
                    if (matchingNotifications.length > 1) {
                        Logger_1.default.information("More than 1 matching notification found, returning the first one");
                    }
                    return matchingNotifications[0];
                }
                else {
                    return null;
                }
            }
            else {
                Logger_1.default.information("Found no notifications in the notifications pane...");
                return null;
            }
        }
        catch (error) {
            if (error.name && error.name === "StaleElementReferenceError") {
                Logger_1.default.warning("StaleElementReferenceError caught at NotificationsPane.waitForNewNotification.");
                return null;
            }
            Logger_1.default.warning(String.format("Error {0} caught at NotificationsPane.waitForNotificationCondition.", error));
            throw error;
        }
    }
}
class NotificationsPane extends NotificationsPaneBase {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("fxs-notificationspane");
    }
}
exports.default = NotificationsPane;
class CustomNotificationsPane extends NotificationsPaneBase {
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("ext-notificationspane-list");
    }
}
exports.CustomNotificationsPane = CustomNotificationsPane;
//# sourceMappingURL=NotificationsPane.js.map