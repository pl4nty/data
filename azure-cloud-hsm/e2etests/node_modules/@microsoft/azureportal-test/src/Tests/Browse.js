"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsExpectedDefaultColumns = exports.canSelectResourceColumns = exports.contextMenuContainsExpectedCommands = void 0;
const Commands = require("../Commands");
const Logger_1 = require("../Logger");
const assert = require("../Utils/Assert");
const Portal_1 = require("../Portal");
/**
 * Tests context menu in browse contains expected commands.
 * browse will be opened for the given resource type and the context menu for the first row in the grid
 * will be opened.  The commands present in the context menu will be compared with the expectedCommands
 *
 * @param {string} resourceProvider The resource provider.
 * @param {string} resourceType The resource type.
 * @param {string} browseBladeTitle - The title of the browse blade for the resource.
 * @param {number} columnIndex - The column to right click for the context menu.
 * @param {Array<string>} expectedCommands - An array of strings representing the expected context menu commands.
 * @param {number} [timeout] The time to wait, in milliseconds, for the context menu to show up
 * @returns A promise that resolves when the test is completed
 * @tutorial tutorial-browse-context-menu
 */
async function contextMenuContainsExpectedCommands(resourceProvider, resourceType, browseBladeTitle, columnIndex, expectedCommands, timeout) {
    const contextMenu = Portal_1.portal.element(Commands.ContextMenu);
    // Load the blade
    const blade = await Portal_1.portal.openBrowseBlade(resourceProvider, resourceType, browseBladeTitle, timeout);
    // Wait for the grid to load
    await Portal_1.portal.delay(200);
    await Portal_1.portal.wait(() => blade.grid.hasRows(), timeout);
    await Portal_1.portal.wait(async () => {
        // Right click the specified cell of the first row
        await blade.grid.rows.get(0).cells.get(columnIndex).rightClick();
        return expectedCommands.length === (await contextMenu.items.count());
    }, timeout, `Waiting for context menu to be displayed with ${expectedCommands.length} menu items.`);
    await assert.strictEqual(async () => await contextMenu.items.count(), expectedCommands.length, "Context menu has correct count of items");
    await assert.deepEqual(async () => await contextMenu.items.map((item) => item.getText()), expectedCommands);
}
exports.contextMenuContainsExpectedCommands = contextMenuContainsExpectedCommands;
/**
 * Tests extension resource specific columns can be selected in browse and that after selection the union of defaultColumns and columnsToSelect are shown in the browse grid.
 * In the case that they are not an AssertionError is thrown.
 *
 * @param {string} resourceProvider The resource provider.
 * @param {string} resourceType The resource type.
 * @param {string} browseBladeTitle - The title of the browse blade for the resource.
 * @param {Array<ColumnTestOptions>} defaultColumns - An array of default custom columns that are shown in browse
 * @param {Array<ColumnTestOptions>} columnsToSelect - An array of custom columns to check based on the custom column interface. If empty, this tests default columns only.
 * @param {number} [timeout] The time to wait
 * @returns A promise that resolves when the test is completed
 * @tutorial tutorial-browse-column-tests
 */
async function canSelectResourceColumns(resourceProvider, resourceType, browseBladeTitle, defaultColumns, columnsToSelect, timeout) {
    const expectedVisibleColumns = columnsToSelect ? defaultColumns.concat(columnsToSelect) : defaultColumns;
    let actualColumnHeaders = [];
    const browseBlade = await Portal_1.portal.openBrowseBlade(resourceProvider, resourceType, browseBladeTitle, timeout);
    await _resetColumns(browseBlade);
    const columnsBlade = await browseBlade.openColumnsPickerBlade(timeout);
    if (columnsToSelect) {
        const columnHeaderLabels = columnsToSelect.map((column) => column.columnLabel);
        await columnsBlade.updateSelectedColumns(columnHeaderLabels, timeout);
    }
    if (!columnsToSelect) {
        await columnsBlade.apply();
    }
    Logger_1.default.information("waiting on grid headers to be available");
    await browseBlade.waitUntilBladeAndAllTilesLoaded(timeout);
    await Portal_1.portal.wait(() => {
        return browseBlade.grid.columnHeaders
            .map((columnHeader) => columnHeader.getText())
            .then((currentHeaders) => {
            actualColumnHeaders = currentHeaders;
            return currentHeaders.length === expectedVisibleColumns.length;
        });
    });
    Logger_1.default.information("validating columns are as expected");
    const expectedColumnHeaders = expectedVisibleColumns.map((column) => column.columnLabel.toLocaleUpperCase()).sort();
    actualColumnHeaders = actualColumnHeaders.map((columnHeader) => columnHeader.toLocaleUpperCase()).sort();
    await assert.deepEqual(actualColumnHeaders, expectedColumnHeaders, `Expected columns: ${expectedColumnHeaders.toString()} \nActual columns: ${actualColumnHeaders.toString()}`);
    return _resetColumns(browseBlade);
}
exports.canSelectResourceColumns = canSelectResourceColumns;
/**
 * Tests columns in browse.
 *
 * @param {string} resourceProvider The resource provider.
 * @param {string} resourceType The resource type.
 * @param {string} browseBladeTitle - The title of the browse blade for the resource.
 * @param {Array<ColumnTestOptions>} defaultColumns - An array of default custom columns that are shown in browse
 * @param {number} [timeout] The time to wait
 * @returns Boolean true if the expected default columns were in browse.
 * @tutorial tutorial-browse-column-tests
 */
function containsExpectedDefaultColumns(resourceProvider, resourceType, browseBladeTitle, defaultColumns, timeout) {
    return canSelectResourceColumns(resourceProvider, resourceType, browseBladeTitle, defaultColumns, null, timeout);
}
exports.containsExpectedDefaultColumns = containsExpectedDefaultColumns;
/**
 * Resets the columns to their default state.
 *
 * @param {BrowseResourceBlade} browseBlade - The title of the browse blade for the resource.
 * @param {number} [timeout] The time to wait, in milliseconds, for the context menu to show up
 * @returns {Promise<void>} returns a promise that is resolved after clicking the reset button in the action bar
 */
async function _resetColumns(browseBlade, timeout) {
    Logger_1.default.information("resetting columns to default");
    const columnsBlade = await browseBlade.openColumnsPickerBlade(timeout);
    Logger_1.default.information("clicking reset");
    await columnsBlade.reset();
}
//# sourceMappingURL=Browse.js.map