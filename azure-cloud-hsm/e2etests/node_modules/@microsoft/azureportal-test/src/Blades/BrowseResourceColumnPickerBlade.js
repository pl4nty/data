"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FilterActionBar_1 = require("../ActionBars/FilterActionBar");
const Controls = require("../Controls");
const Blade_1 = require("./Blade");
const BrowserAutomation_1 = require("../BrowserAutomation");
const By_1 = require("../Locators/By");
const resources = require("../PortalFxResources");
const Logger_1 = require("../Logger");
/**
 * Represents a Blade used to choose columns to show in browse resources
 */
class BrowseResourceColumnPickerBlade extends Blade_1.default {
    constructor() {
        super(...arguments);
        /**
         * The grid that contains all columns that can be selected
         */
        this.sourceGrid = this.all(Controls.EditableGrid).get(0);
        this.columnGrid = this.all(Controls.EditableGrid).get(1);
    }
    /**
     * Waits until the columns grid has rows then selects each column contained within columnsToSelect then clicks
     * the update action
     *
     * @param {Array<string>} columnsToSelect is the list of columns to click on
     * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
     * @returns A promise that resolves with this blade instance after the changes.
     */
    async updateSelectedColumns(columnsToSelect, timeout) {
        // This function is badly named, but it might be used and is left here as an alias to the addColumns function.
        return await this.addColumns(columnsToSelect, timeout);
    }
    /**
     * Waits until the columns grid has rows then adds each column contained within columnsToAdd then clicks
     * the apply button
     *
     * @param {Array<string>} columnsToAdd is the list of columns to add to the selected columns
     * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
     * @returns A promise that resolves with this blade instance after the changes.
     */
    async addColumns(columnsToAdd, timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const sourceRows = await this.sourceGrid.hasRows();
            Logger_1.default.diagnostics("*** Waiting for rows, have rows: " + sourceRows + " ***");
            return sourceRows;
        }, timeout);
        Logger_1.default.diagnostics("*** Adding rows ***");
        await columnsToAdd.reduce(async (previousPromise, column) => {
            await previousPromise;
            Logger_1.default.diagnostics("*** Looking for row " + column + " ***");
            const row = await this.sourceGrid.findRow({ text: column, cellIndex: 0, caseInsensitive: true }, timeout / 10);
            if (row) {
                await row.click();
                await this._addSelectedColumn();
            }
            else {
                Logger_1.default.diagnostics("*** Can't find row " + column + " ***");
            }
        }, Promise.resolve());
        return await this.apply();
    }
    /**
     * Waits until the columns grid has rows then removes each column contained within columnsToRemove then clicks
     * the apply button
     *
     * @param {Array<string>} columnsToRemove is the list of columns to add to the selected columns
     * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
     * @returns A promise that resolves with this blade instance after the changes.
     */
    async removeColumns(columnsToRemove, timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const columnRows = await this.columnGrid.hasRows();
            Logger_1.default.diagnostics("*** Waiting for rows, have rows: " + columnRows + " ***");
            return columnRows;
        }, timeout);
        Logger_1.default.diagnostics("*** Removing rows ***");
        await columnsToRemove.reduce(async (previousPromise, column) => {
            await previousPromise;
            Logger_1.default.diagnostics("*** Looking for row " + column + " ***");
            const row = await this.columnGrid.findRow({ text: column, cellIndex: 0, caseInsensitive: true }, timeout / 10);
            if (row) {
                await row.click();
                await this._removeSelectedColumn();
            }
            else {
                Logger_1.default.diagnostics("*** Can't find row " + column + " ***");
            }
        }, Promise.resolve());
        return await this.apply();
    }
    /**
     * Waits until the columns grid has rows then sets each column contained within columnsToSelect then clicks
     * the apply button
     *
     * @param {Array<string>} columnsToSelect is the list of columns to be the selected columns
     * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
     * @returns A promise that resolves with this blade instance after the changes.
     */
    async setColumns(columnsToSelect, timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const sourceRows = await this.sourceGrid.hasRows();
            const columnRows = await this.columnGrid.hasRows();
            Logger_1.default.diagnostics("*** Waiting for rows, have source rows: " + sourceRows + ", have column rows: " + columnRows + " ***");
            return sourceRows || columnRows;
        }, timeout);
        const selectedColumns = await this.columnGrid.rows.map(async (row) => row.cells.get(0).getText());
        Logger_1.default.diagnostics("*** Removing rows ***");
        await selectedColumns.reduce(async (previousPromise, column) => {
            await previousPromise;
            Logger_1.default.diagnostics("*** Looking for row " + column + " ***");
            const row = await this.columnGrid.findRow({ text: column, cellIndex: 0, caseInsensitive: true }, timeout / 10);
            if (row) {
                await row.click();
                await this._removeSelectedColumn();
            }
            else {
                Logger_1.default.diagnostics("*** Can't find row for " + column + " ***");
            }
        }, Promise.resolve());
        return await this.addColumns(columnsToSelect);
    }
    /**
     * Clicks the apply button on the blade.
     *
     * @returns A promise that resolves with this blade instance when apply button has been clicked.
     */
    async apply() {
        const button = await this.applyButton();
        await button.click();
        return this;
    }
    /**
     * Clicks the reset button on the blade.
     *
     * @returns A promise that resolves with this blade instance when reset button has been clicked.
     */
    async reset() {
        const button = await this.resetButton();
        await button.click();
        return this;
    }
    /**
     * Gets the apply button on the blade (button or action bar button).
     *
     * @returns A promise that resolves with the apply button.
     */
    async applyButton() {
        const hasButtons = await this._hasButtons([resources.hubsExtension.resourceGroups.applyButton, resources.hubsExtension.resourceGroups.resetButton], new FilterActionBar_1.default());
        return hasButtons
            ? this._getButton(resources.hubsExtension.resourceGroups.applyButton)
            : this.element(FilterActionBar_1.default).updateButton;
    }
    /**
     * Gets the reset button on the blade (button or action bar button).
     *
     * @returns A promise that resolves with the reset button.
     */
    async resetButton() {
        const hasButtons = await this._hasButtons([resources.hubsExtension.resourceGroups.applyButton, resources.hubsExtension.resourceGroups.resetButton], new FilterActionBar_1.default());
        return hasButtons
            ? this._getButton(resources.hubsExtension.resourceGroups.resetButton)
            : this.element(FilterActionBar_1.default).resetButton;
    }
    /**
     * Gets the add column button on the blade.
     *
     * @returns A promise that resolves with the add column button.
     */
    async addButton() {
        await this._hasActionButtons();
        return this._getActionButtons(0);
    }
    /**
     * Gets the remove column button on the blade.
     *
     * @returns A promise that resolves with the remove column button.
     */
    async removeButton() {
        await this._hasActionButtons();
        return this._getActionButtons(1);
    }
    async _addSelectedColumn() {
        const button = await this.addButton();
        await button.click();
        return this;
    }
    async _removeSelectedColumn() {
        const button = await this.removeButton();
        await button.click();
        return this;
    }
    _getActionButtons(index) {
        return this.all(By_1.default.className("ext-action")).get(index);
    }
    async _hasActionButtons() {
        let haveButtons = false;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const found = await this._foundActionButtons(2);
            if (found) {
                haveButtons = true;
            }
            return found;
        });
        return haveButtons;
    }
    async _foundActionButtons(count) {
        const buttons = await this.all(By_1.default.className("ext-action"));
        return buttons.length === count;
    }
}
exports.default = BrowseResourceColumnPickerBlade;
//# sourceMappingURL=BrowseResourceColumnPickerBlade.js.map