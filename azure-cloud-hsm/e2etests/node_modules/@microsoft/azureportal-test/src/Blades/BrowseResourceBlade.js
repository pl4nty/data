"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TextField_1 = require("../Controls/TextField");
const portalFxResources = require("../PortalFxResources");
const String = require("../Utils/String");
const Blade_1 = require("./Blade");
const BrowseResourceBladeGrid_1 = require("./BrowseResourceBladeGrid");
const BrowseResourceColumnPickerBlade_1 = require("./BrowseResourceColumnPickerBlade");
const BrowserAutomation_1 = require("../BrowserAutomation");
const Logger_1 = require("../Logger");
const ResourceFilterTextField_1 = require("./ResourceFilterTextField");
const Portal_1 = require("../Portal");
const Locators_1 = require("../Locators");
/**
 * Represents a Blade used to browse resources.
 */
class BrowseResourceBlade extends Blade_1.default {
    constructor() {
        super(...arguments);
        /**
         * The grid that shows the browse results.
         */
        this.grid = this.element(BrowseResourceBladeGrid_1.default);
    }
    /**
     * Returns the text filter on the blade.
     *
     * @returns An instance of TextField class wrapped in a promise.
     */
    async getTextFilter() {
        const textFilter = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const resourceTest = this.element(ResourceFilterTextField_1.default);
            if (await resourceTest?.isPresent()) {
                return resourceTest;
            }
            const text = this.element(TextField_1.default);
            if (await text?.isPresent()) {
                return text;
            }
            return null;
        }, null, "Text filter not found on the blade.");
        if (textFilter) {
            return textFilter;
        }
        throw new Error("Text filter not found on the blade.");
    }
    /**
     * Filters the browse results using the specified filter.
     *
     * @param {string} filter The filter.
     * @returns A promise that resolves with this blade instance when filtered browse results are available.
     */
    async filterItems(filter) {
        Logger_1.default.information(String.format("Applying filter '{0}'...", filter));
        const textFilter = await this.getTextFilter();
        return textFilter.clear().then(() => {
            return textFilter.sendKeys(filter).then(async () => {
                await textFilter.value().then((text) => {
                    Logger_1.default.information(String.format("Filter was set to '{0}'", text));
                });
                return this;
            });
        });
    }
    /**
     * Opens the Browse Column picker blade
     *
     * @param timeout Optional timeout to wait for the columns blade to load
     * @returns A promise that resolves with the instance of the BrowseResourceColumnPickerBlade
     */
    async openColumnsPickerBlade(timeout) {
        const usingOldColumnChooser = Portal_1.portal?.portalContext?.features &&
            Portal_1.portal.portalContext.features.some((feature) => {
                return (feature.name &&
                    feature.name.toLowerCase() === "feature.oldcolumnchooser" &&
                    feature.value &&
                    feature.value.toLowerCase() === "true");
            });
        if (!usingOldColumnChooser) {
            // Not using the old column chooser, we need to throw an error (better than cryptic failures).
            throw new Error("The openColumnsPickerBlade() function is not available without the 'oldcolumnchooser' feature flag. " +
                "Either include the feature flag (something like this: " +
                'testFx.portal.portalContext.features.push({ name: "feature.oldcolumnchooser", value: "true" }); ' +
                "or switch to using the new ColumnChooser class.");
        }
        const returnColumnPickerBlade = async () => {
            const columnsBlade = Portal_1.portal.blade({ title: portalFxResources.chooseColumnsV2 });
            await columnsBlade.waitUntilBladeAndAllTilesLoaded(timeout);
            return columnsBlade.asType(BrowseResourceColumnPickerBlade_1.default);
        };
        const hasViewMenu = await this.hasCommand(portalFxResources.manageView);
        if (hasViewMenu) {
            Logger_1.default.diagnostics("Opening column chooser from Manage View menu");
            return this.clickCommand(portalFxResources.manageView).then(() => {
                const editColumnsButton = this.element(Locators_1.By.classAndText("azc-toolbarButton-container", portalFxResources.columns));
                return editColumnsButton.click().then(() => returnColumnPickerBlade());
            });
        }
        else {
            Logger_1.default.diagnostics("Opening column chooser directly from command bar");
            return this.clickCommand(portalFxResources.columns).then(() => returnColumnPickerBlade());
        }
    }
    /**
     * Opens the Browse Column picker blade
     *
     * @param timeout Optional timeout to wait for the columns blade to load
     * @returns A promise that resolves with the instance of the Blade
     */
    async openNewColumnsPickerBlade(timeout) {
        const usingOldColumnChooser = Portal_1.portal?.portalContext?.features &&
            Portal_1.portal.portalContext.features.some((feature) => {
                return (feature.name &&
                    feature.name.toLowerCase() === "feature.oldcolumnchooser" &&
                    feature.value &&
                    feature.value.toLowerCase() === "true");
            });
        if (usingOldColumnChooser) {
            // Not using the old column chooser, we need to throw an error (better than cryptic failures).
            throw new Error("The openNewColumnsPickerBlade() function is not available with the 'oldcolumnchooser' feature flag. " +
                "Either remove the feature flag or switch to using openColumnsPickerBlade class.");
        }
        const returnColumnPickerBlade = async () => {
            const columnsBlade = Portal_1.portal.blade({ title: portalFxResources.chooseColumnsV2 });
            await columnsBlade.waitUntilBladeAndAllTilesLoaded(timeout);
            return columnsBlade.asType(Blade_1.default);
        };
        const hasViewMenu = await this.hasCommand(portalFxResources.manageView);
        if (hasViewMenu) {
            Logger_1.default.diagnostics("Opening column chooser from Manage View menu");
            return this.clickCommand(portalFxResources.manageView).then(() => {
                const editColumnsButton = this.element(Locators_1.By.classAndText("azc-toolbarButton-container", portalFxResources.columns));
                return editColumnsButton.click().then(() => returnColumnPickerBlade());
            });
        }
        else {
            Logger_1.default.diagnostics("Opening column chooser directly from command bar");
            return this.clickCommand(portalFxResources.columns).then(() => returnColumnPickerBlade());
        }
    }
    /**
     * Returns the Text field filter on Resource blade.
     *
     * @returns The test field on the resource blade.
     */
    getFilterTextField() {
        return this.element(TextField_1.default);
    }
}
exports.default = BrowseResourceBlade;
//# sourceMappingURL=BrowseResourceBlade.js.map