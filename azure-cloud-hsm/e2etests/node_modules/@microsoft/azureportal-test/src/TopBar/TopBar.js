"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
const BrowserAutomation_1 = require("../BrowserAutomation");
const ActionsMenu_1 = require("./ActionsMenu");
const Settings_1 = require("../Settings");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const StartBoard_1 = require("../StartBoard");
const PortalShell_1 = require("../PortalShell");
const Logger_1 = require("../Logger");
const Button_1 = require("../Controls/Button");
/**
 * Represents the Top bar.
 */
class TopBar extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.rootClassName = "fxs-topbar";
        this.exitOrganizeModeButtonClassName = "fxs-topbar-exit-customize-button";
        this.directoryAndSubscriptionsClassName = "fxs-menu-directories-subscriptions";
        this.sideBarToggleButtonClassName = "fxs-topbar-sidebar-collapse-button";
        this.unreadCountElementClassName = "fxs-notificationspane-button-unreadcount";
        this.startButtonClassName = "fxs-topbar-home";
        this.showStartBoardClassName = "fxs-show-startboard";
        this.dashboardSaveButtonClassName = "fxs-topbar-dashboard-save";
        this.dashboardViewButtonClassName = "fxs-topbar-dashboard-view";
        this.dashboardDiscardButtonClassName = "fxs-topbar-dashboard-discard";
        this.notificationsTitle = "Notifications";
        this.notificationsClassName = "fxs-topbar-notifications";
        this.settingsTitle = "Settings";
        this.settingsClassName = "fxs-topbar-settings";
        this.helpMenuTitle = "Support + Troubleshooting";
        this.helpButtonClassName = "fxs-topbar-helpmenu";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.rootClassName);
    }
    /**
     * Gets the View Dashboard button.
     */
    async viewDashboardButton() {
        return Promise.resolve(this.element(By_1.default.className(this.dashboardViewButtonClassName)).asType(Button_1.default));
    }
    /**
     * Gets the Save Dashboard button.
     */
    async saveDashboardButton() {
        return Promise.resolve(this.element(By_1.default.className(this.dashboardSaveButtonClassName)).asType(Button_1.default));
    }
    /**
     * Gets the Discard Dashboard button.
     *
     * @returns Promise which resolves to discard button.
     */
    async discardDashboardButton() {
        return Promise.resolve(this.element(By_1.default.className(this.dashboardDiscardButtonClassName)).asType(Button_1.default));
    }
    /**
     * Clicks View Dashboard button.
     */
    async viewDashboard() {
        const button = await this.viewDashboardButton();
        await button.click();
    }
    /**
     * Clicks Save Dashboard button.
     */
    async saveDashboard() {
        const button = await this.saveDashboardButton();
        await button.click();
    }
    /**
     * Clicks Discard Dashboard button.
     *
     * @returns Promise which resolves when discard button click is done.
     */
    async discardDashboard() {
        const button = await this.discardDashboardButton();
        await button.click();
    }
    /**
     * Returns exit organize mode button.
     *
     * @returns Promise which resolves to exit organize mode button.
     */
    async exitOrganizeModeButton() {
        return Promise.resolve(this.element(By_1.default.className(this.exitOrganizeModeButtonClassName)).asType(Button_1.default));
    }
    /**
     * Gets the unread notification count.
     *
     * @returns the count
     */
    async getUnreadNotificationsCount() {
        const unreadCountElement = this.element(By_1.default.className(this.unreadCountElementClassName));
        try {
            // using isDisplayed instead of isPresent as it has a wait
            await unreadCountElement.isDisplayed();
        }
        catch (error) {
            Logger_1.default.information("Unread notification count element not displayed.");
            return 0;
        }
        const text = await unreadCountElement.getText();
        Logger_1.default.information(`Text returned ${text}`);
        return parseInt(text);
    }
    /**
     * Gets hamburger button.
     */
    async getSideBarToggleButton() {
        return Promise.resolve(this.element(By_1.default.className(this.sideBarToggleButtonClassName)));
    }
    async clickCommandsButton(title, className) {
        const button = await (0, BrowserAutomation_1.getBrowser)().wait(() => this.element(By_1.default.className(className)), null, `Could not find the menu item with class ${className} on the top bar.`);
        if (await button.isDisplayed()) {
            await button.click();
        }
        else {
            const actionsMenu = this.element(ActionsMenu_1.ActionsMenu);
            const actionsMenuItem = await actionsMenu.getActionsMenuItem(title);
            await actionsMenuItem.click();
        }
    }
    /**
     * Clicks the Directory and Subscriptions menu on the setting flyout.
     */
    async clickDirectoryAndSubscriptions() {
        // Check if the pane is already open.
        const settingsFlyoutElements = ElementArrayFinder_1.default.all(Settings_1.SettingsFlyout);
        const actualSettingsFlyoutElementsCount = await settingsFlyoutElements.count();
        if (!(actualSettingsFlyoutElementsCount === 1 && (await settingsFlyoutElements.get(0).isDisplayed()))) {
            // open the settings flyout
            await this.clickCommandsButton(this.settingsTitle, this.settingsClassName);
        }
        // find and click the directory and subscriptions menu
        const directoriesSubscriptionsMenu = await (0, BrowserAutomation_1.getBrowser)().wait(() => ElementArrayFinder_1.default.element(By_1.default.className(this.directoryAndSubscriptionsClassName)));
        await directoriesSubscriptionsMenu.click();
    }
    /**
     *  Clicks the Notifications menu on the top bar.
     */
    async clickNotifications() {
        await this.clickCommandsButton(this.notificationsTitle, this.notificationsClassName);
    }
    /**
     *  Clicks the Settings menu on the top bar.
     *
     * @returns Promise that resolves when settings button click is done.
     */
    async clickSettings() {
        await this.clickCommandsButton(this.settingsTitle, this.settingsClassName);
    }
    /**
     * Clicks the Help button on the top bar.
     *
     * @returns Promise that resolves when the help button click is done.
     */
    async clickHelp() {
        await this.clickCommandsButton(this.helpMenuTitle, this.helpButtonClassName);
    }
    /**
     * Opens the directory settings UX for the current Portal session.
     */
    async openDirectorySettings() {
        // Check if the pane is already open.
        const settingsFlyoutElements = ElementArrayFinder_1.default.all(Settings_1.SettingsFlyout);
        const actualSettingsFlyoutElementsCount = await settingsFlyoutElements.count();
        if (actualSettingsFlyoutElementsCount === 1 && (await settingsFlyoutElements.get(0).isDisplayed())) {
            return settingsFlyoutElements.get(0);
        }
        else if (actualSettingsFlyoutElementsCount > 1) {
            // Throw if there is more than one element.
            throw new Error("Expected to find a single portal settings element, but found " + actualSettingsFlyoutElementsCount);
        }
        else {
            await this.clickDirectoryAndSubscriptions();
            const settingsFlyout = ElementArrayFinder_1.default.element(Settings_1.SettingsFlyout);
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await settingsFlyout.isLoading()), null, "Expected settings to finish loading.");
            return settingsFlyout;
        }
    }
    /**
     * Opens the directories area of portal settings.
     *
     * @returns the settings element.
     * @deprecated Use `openDirectorySettings` instead.
     */
    async openDirectoryPane() {
        return await this.openDirectorySettings();
    }
    /**
     * Shows the StartBoard
     *
     * @returns A StartBoard object
     */
    async showStartBoard() {
        if (await this.isStartBoardVisible()) {
            return PortalShell_1.default.getPortalShell().element(StartBoard_1.default);
        }
        await this.clickStartButton();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.isStartBoardVisible(), null, "The startboard should be visible.");
        const startBoard = PortalShell_1.default.getPortalShell().element(StartBoard_1.default);
        await startBoard.waitForAllTilesLoaded();
        return startBoard;
    }
    /**
     * Checks if startboard is visible
     *
     * @returns True, if visible, otherwise false.
     */
    async isStartBoardVisible() {
        return await PortalShell_1.default.getPortalShell().getPortalElement().hasClass(this.showStartBoardClassName);
    }
    /**
     * Clicks the Start Button
     */
    async clickStartButton() {
        const startButton = ElementArrayFinder_1.default.element(By_1.default.className(this.startButtonClassName));
        await startButton.click();
    }
    async haveViewDashboardButton() {
        const found = this.tryFindElement(By_1.default.className(this.dashboardViewButtonClassName));
        if (found) {
            return await found.isDisplayed();
        }
        return false;
    }
    async haveSaveDashboardButton() {
        return await this.tryFindElement(By_1.default.className(this.dashboardSaveButtonClassName)).isDisplayed();
    }
}
exports.default = TopBar;
//# sourceMappingURL=TopBar.js.map