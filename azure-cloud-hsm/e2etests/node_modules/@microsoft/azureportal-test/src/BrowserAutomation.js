"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBrowser = exports.runAutomationSync = exports.runAutomation = exports.setAutomation = void 0;
const BrowserAutomationType_1 = require("./BrowserAutomationType");
const Logger_1 = require("./Logger");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const PortalPlaywright_1 = require("./PortalPlaywright");
const PortalWebDriver_1 = require("./PortalWebDriver");
const webdriverEnumVal = BrowserAutomationType_1.BrowserAutomationType.WebDriver;
const playwrightEnumVal = BrowserAutomationType_1.BrowserAutomationType.Playwright;
let _webdriver = null;
let _playwright = null;
let driver = null;
_initDriver(PortalConfigurationManager_1.default.portalContext.browserAutomation);
const diagnosticsLog = Logger_1.default.information.extend("BrowserAutomation");
/**
 * A helper function that initializes the driver
 *
 * @param {BrowserAutomationType} type The type of automation framework to use
 */
function _initDriver(type) {
    if (type === playwrightEnumVal && !_playwright) {
        _playwright = new PortalPlaywright_1.PortalPlaywright();
    }
    else if (type === webdriverEnumVal && !_webdriver) {
        _webdriver = new PortalWebDriver_1.PortalWebDriver();
    }
    driver = type === webdriverEnumVal ? _webdriver : _playwright;
    if (PortalConfigurationManager_1.default.portalContext.browserAutomation !== type) {
        PortalConfigurationManager_1.default.portalContext.browserAutomation = type;
    }
}
/**
 * Function to use when in need to switch between automation frameworks. Calls a helper function that does the driver initialization
 *
 * @param {BrowserAutomationType} type The type of automation framework to use
 * @param {boolean} quitPrevious Flag to whether or not previously initialized driver should quit
 * @returns A promise that resolves when the quit operation is done.
 */
async function setAutomation(type, quitPrevious = true) {
    if (quitPrevious) {
        await driver?.quit();
        _webdriver = null;
        _playwright = null;
    }
    _initDriver(type);
    diagnosticsLog(`Setting automation to ${type.charAt(0).toUpperCase() + type.slice(1).toLowerCase()}`);
}
exports.setAutomation = setAutomation;
/**
 * This is a shim used to bridge gaps where there is no good way to implement a common interface/function between webdriver and playwright asynchronous actions
 *
 * @param {Promise<T>} webdriverCb The webdriver specific implementation of the asynchronous action
 * @param {Promise<T>} playwrightCb The playwright specific implementation of the asynchronous action
 * @returns A promise that resolves with the given type.
 */
async function runAutomation(webdriverCb, playwrightCb) {
    if (driver.library === webdriverEnumVal) {
        return await webdriverCb(_webdriver);
    }
    else {
        return await playwrightCb(_playwright);
    }
}
exports.runAutomation = runAutomation;
/**
 * This is a shim used to bridge gaps where there is no good way to implement a common interface/function between webdriver and playwright actions
 *
 * @param {T} webdriverCb The webdriver specific implementation of the action
 * @param {T} playwrightCb The playwright specific implementation of the action
 * @returns The given type.
 */
function runAutomationSync(webdriverCb, playwrightCb) {
    if (driver.library === webdriverEnumVal) {
        return webdriverCb(_webdriver);
    }
    else {
        return playwrightCb(_playwright);
    }
}
exports.runAutomationSync = runAutomationSync;
function getBrowser() {
    return driver;
}
exports.getBrowser = getBrowser;
//# sourceMappingURL=BrowserAutomation.js.map