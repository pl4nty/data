"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PortalElement_1 = require("../PortalElement");
const BrowserAutomation_1 = require("../BrowserAutomation");
const By_1 = require("../Locators/By");
const Constants = require("../Constants");
const ExpectedConditions = require("../ExpectedConditions");
const PortalElement_2 = require("../PortalElement");
const SearchResult_1 = require("./SearchResult");
const SearchCategory_1 = require("./SearchCategory");
var ClassNames = Constants.CssClassNames;
/**
 * Represents the Portal Search menu.
 */
class SearchMenu extends PortalElement_2.default {
    constructor() {
        super(...arguments);
        this.mruItemsMenu = this.element(By_1.default.className(ClassNames.SearchMenu.mruItems));
        this.searchResultMenu = this.element(By_1.default.className(ClassNames.SearchMenu.searchResults));
        this.searchTextBox = this.element(By_1.default.tagName(`input`));
        this.searchBoxIcon = this.element(By_1.default.className(ClassNames.SearchMenu.searchBoxIcon));
        this.searchFlyout = this.element(By_1.default.className(ClassNames.SearchMenu.searchFlyout));
        /**
         * @deprecated SearchMenu.mruResults instance property has been deprecated, use SearchMenu.getAllMruMenuSearchResults instance method instead.
         */
        // eslint-disable-next-line deprecation/deprecation
        this.mruResults = this.mruItemsMenu.all(SearchResult_1.default);
        /**
         * The list of displayed search results.
         */
        this.searchResults = this.searchResultMenu.all(SearchResult_1.default);
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(ClassNames.SearchMenu.searchMenu);
    }
    /**
     * Get categories from search results. This method is only applicable when query string parameter asyncSearch is set to true.
     */
    async getCategories() {
        return await this.all(SearchCategory_1.default).asPortalElements();
    }
    /**
     * Get all recents from search results. This method is only applicable when mruItemsMenu is present.
     */
    async getAllMruMenuSearchResults() {
        await this.open();
        if (this.mruItemsMenu.isDisplayed()) {
            return await this.mruItemsMenu.all(By_1.default.className(ClassNames.SearchMenu.resultTitle));
        }
        else {
            throw new Error("Mru menu is not displayed");
        }
    }
    /**
     * Get "See all" link of a search category.
     *
     * @param searchCategory The category of search result containing see all link.
     */
    async getSeeAllLink(searchCategory) {
        const seeAllLinkofSearchCategory = searchCategory.element(By_1.default.tagName("a"));
        if ((await seeAllLinkofSearchCategory.getText()).toLowerCase() === "see all") {
            return seeAllLinkofSearchCategory;
        }
        throw new Error("Failed to get 'See all' link");
    }
    /**
     * Get "See more" link of a search category.
     *
     * @param searchCategory The category of search result containing see more link.
     */
    async getSeeMoreLink(searchCategory) {
        const seeAllLinkofSearchCategory = searchCategory.element(By_1.default.tagName("a"));
        if ((await seeAllLinkofSearchCategory.getText()).toLowerCase() === "see more") {
            return seeAllLinkofSearchCategory;
        }
        throw new Error("Failed to get 'See more' link");
    }
    /**
     * Searches for the given string.
     *
     * @param {string} text The text to search for.
     * @param {timeout} timeout in miliseconds to wait for search to complete. Default is 5000 miliseconds.
     * @returns The list of search results.
     */
    async search(text, timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(ExpectedConditions.isPresent(this.searchTextBox), 10000, "Timed out waiting for search text box");
        await (0, PortalElement_1.delay)(3000);
        await this.clearSearch();
        await this.searchTextBox.sendKeys(text);
        try {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.isElementDisplayed(By_1.default.className(ClassNames.SearchMenu.resultDetails)), timeout || 5000, "Timed out waiting for search results");
            await (0, PortalElement_1.delay)(3000);
            return this.searchResults;
        }
        catch (e) {
            if (await this.isElementDisplayed(By_1.default.className(ClassNames.SearchMenu.noResults))) {
                return this.searchResults;
            }
        }
        return null;
    }
    /**
     * Opens the search flyout..
     *
     * @returns the SearchMenu.
     */
    async open() {
        try {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
                return !(await this.searchFlyout.isDisplayed());
            }, null, "The search box is already open.");
        }
        catch {
            // search box is already open.
            return this;
        }
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            let retVal = true;
            if (await this.searchTextBox.isDisplayed()) {
                await this.searchTextBox.click();
            }
            else {
                retVal = false;
            }
            return retVal;
        }, null, "Unable to find search box or search button.");
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await this.searchFlyout.isDisplayed();
        }, null, "The search box never opened.");
        return this;
    }
    /**
     * Closes the search flyout.sometimes, icon becomes enabled only after searchTextBox is clicked,Hence cliking seachTextBox and then SearchIcon.
     */
    async close() {
        if (await this.searchTextBox.isDisplayed()) {
            await this.searchTextBox.click();
        }
        if (await this.searchBoxIcon.isDisplayed()) {
            await this.searchBoxIcon.click();
        }
    }
    /**
     * Clears the previous search.
     *
     * @returns The search menu.
     */
    async clearSearch() {
        await this.open();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            try {
                const clearElem = this.element(By_1.default.className(ClassNames.SearchMenu.clearElement));
                if (await clearElem.isDisplayed()) {
                    await clearElem.click();
                }
                return true;
            }
            catch {
                return false;
            }
        }, null, "Ensure that the search menu is cleared.");
        //await this.open();
        return this;
    }
    /**
     * Filters global search result on the basis of title.
     *
     * @param {any} searchResults List of search results.
     * @param {string} title title of the search result.
     * @returns an array that satisfies the filter conditions.
     */
    async filterSearchResultsByTitle(searchResults, title) {
        const filteredItems = [];
        for (const item of searchResults) {
            if ((await item.title.getText()).toLowerCase() === title.toLowerCase()) {
                filteredItems.push(item);
            }
        }
        if (filteredItems.length === 0) {
            throw `No results were found with the title ${title}`;
        }
        return filteredItems;
    }
    /**
     * Filters global search result on the basis of result type.
     *
     * @param {any} searchResults List of search results.
     * @param {string} resultType Result type of the search result.
     * @returns an array that satisfies the filter conditions.
     */
    async filterSearchResultsByResultType(searchResults, resultType) {
        const filteredItems = [];
        for (const item of searchResults) {
            if ((await item.resultType.getText()).toLowerCase() === resultType.toLowerCase()) {
                filteredItems.push(item);
            }
        }
        if (filteredItems.length === 0) {
            throw `No results were found with the result type ${resultType}`;
        }
        return filteredItems;
    }
    /**
     * Checks if MruItemsMenu is present or not in SearchMenu.
     */
    async isMruItemsMenuPresent() {
        return await this.mruItemsMenu.isPresent();
    }
}
exports.default = SearchMenu;
//# sourceMappingURL=SearchMenu.js.map