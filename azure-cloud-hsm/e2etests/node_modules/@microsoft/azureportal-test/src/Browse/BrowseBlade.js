"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBrowseFromBlade = void 0;
const ArgBrowseBlade_1 = require("../Blades/ArgBrowseBlade");
const CommandBarMenuItem_1 = require("../Commands/CommandBarMenuItem");
const Controls_1 = require("../Controls");
const Index_1 = require("../Index");
const Locators_1 = require("../Locators");
const ReactView_1 = require("../Utils/ReactView");
/**
 * Gets the browse blade from a given portal blade. This will determine the underlying framework and provide a
 * framework-agnostic facade.
 *
 * @param portal The portal instance.
 * @param blade The portal blade representing KO or react ARG browse.
 * @param bladeNameOverride Optional blade name override when looking for the blade.
 * @param logging Optional flag to enable logging debug information.
 * @returns Promise which resolves with the browse blade or throws an error if the blade does not represent a browse blade.
 */
async function getBrowseFromBlade(portal, blade, bladeNameOverride, logging) {
    const reactContainer = blade.element(Locators_1.By.className("fxs-part-reactframe" /* ClassNames.reactContainer */));
    if (reactContainer) {
        const iframes = await portal.all(Locators_1.By.className("fxs-reactview-frame-active"));
        const iframeNames = await Promise.all(iframes.map(async (iframe) => await iframe.getAttribute("name")));
        if (iframes?.length > 0 &&
            iframeNames.some((name) => bladeNameOverride !== undefined
                ? name === bladeNameOverride + ".ReactView"
                : browseResourceViewNames[name])) {
            logging &&
                Index_1.Logger.default.information("Found react browse container" +
                    (bladeNameOverride ? ` with blade name override '${bladeNameOverride}'` : ""));
            return new ReactBrowse.ReactBrowseBlade(portal);
        }
    }
    const bladeContainer = blade.element(Locators_1.By.className("ext-hubs-artbrowse-container" /* ClassNames.koContainer */));
    if (bladeContainer) {
        logging &&
            Index_1.Logger.default.information("Found KO browse container, class: " + (await bladeContainer.getAttribute("class")));
        return new KoBrowse.KoBrowseBlade(blade);
    }
    logging && Index_1.Logger.default.warning("Blade does not contain browse");
    throw new Error("Blade does not contain browse");
}
exports.getBrowseFromBlade = getBrowseFromBlade;
const browseResourceViewNames = {
    // Default browse blades
    "Browse.ReactView": true,
    "BrowseAll.ReactView": true,
    "BrowseResourceGroups.ReactView": true,
    "BrowseResource.ReactView": true,
    // Custom data source browse blades
    "ArmBrowse.ReactView": true,
    "BrowseFallback.ReactView": true,
    "BrowseFavoriteResources.ReactView": true,
    "BrowseRecentResources.ReactView": true,
    // Resource group overview blade
    "ResourceGroupOverview.ReactView": true,
};
var KoBrowse;
(function (KoBrowse) {
    class KoBrowseBlade {
        constructor(_blade) {
            this._blade = _blade;
            this.expectGroupingInCommandBar = false;
        }
        get commands() {
            return (async () => {
                const toolbar = this._blade.element(Controls_1.Toolbar);
                if (await toolbar?.isDisplayed()) {
                    return new KoBrowseCommands(toolbar);
                }
                throw new Error("Toolbar found but not displayed");
            })();
        }
        get grouping() {
            return (async () => {
                const groupingDropDown = await this._getGroupingDropdown();
                if (await groupingDropDown?.isDisplayed()) {
                    const grouping = cleanText(await groupingDropDown.getValue());
                    if (grouping === "No grouping") {
                        return "none";
                    }
                    if (grouping?.toLowerCase()?.startsWith("group by ")) {
                        return grouping.substring(9).toLowerCase();
                    }
                    throw new Error(`Unexpected grouping value, not expected format: ${grouping}`);
                }
                throw new Error("Missing group dropdown");
            })();
        }
        async setGrouping(grouping) {
            const groupingDropDown = await this._getGroupingDropdown();
            if (await groupingDropDown?.isDisplayed()) {
                let optionToSelect = "";
                if (grouping.toLowerCase() === "none" ||
                    grouping.toLowerCase() === "group by none" ||
                    grouping.toLowerCase() === "no grouping") {
                    optionToSelect = "No grouping";
                }
                else if (grouping.toLowerCase().startsWith("group by ")) {
                    optionToSelect = grouping.charAt(0).toUpperCase() + grouping.slice(1).toLowerCase();
                }
                else {
                    optionToSelect = "Group by " + grouping.toLowerCase();
                }
                if (cleanText(await groupingDropDown.getValue()).toLowerCase() !== optionToSelect.toLowerCase()) {
                    await groupingDropDown.selectOptionByText(optionToSelect);
                }
                return cleanText(await groupingDropDown.getValue()).toLowerCase() === optionToSelect.toLowerCase();
            }
            throw new Error("Missing group dropdown");
        }
        async _getGroupingDropdown() {
            const filtersContainers = await this._blade.all(Locators_1.By.className("ext-hubs-artbrowse-filters"));
            if (filtersContainers?.length === 1) {
                const dropDowns = await filtersContainers[0].all(Controls_1.GroupDropDownField);
                if (dropDowns?.length === 2) {
                    // First drop down is group by
                    return dropDowns[0];
                }
            }
            const cardsContainers = await this._blade.all(Locators_1.By.className("ext-hubs-artbrowse-cards"));
            if (cardsContainers?.length === 1) {
                const dropDowns = await cardsContainers[0].all(Controls_1.GroupDropDownField);
                if (dropDowns?.length === 2) {
                    // First drop down is group by
                    return dropDowns[0];
                }
            }
            return null;
        }
        get search() {
            return (async () => {
                const searchTextBox = this._blade.element(Controls_1.TextBox);
                if (await searchTextBox?.isDisplayed()) {
                    return new KoBrowseSearch(searchTextBox);
                }
                throw new Error("Browse search text box not found or is not displayed yet in KO browse");
            })();
        }
        get filters() {
            return (async () => {
                const filterPills = this._blade.element(Locators_1.By.className("fxc-pill-collection" /* ClassNames.pillCollection */));
                if (await filterPills?.isDisplayed()) {
                    return new KoBrowseFilters(filterPills);
                }
                throw new Error("Browse filter pills not found or is not displayed yet in KO browse");
            })();
        }
        get featureCards() {
            return (async () => {
                const featureCardContainer = this._blade.element(Locators_1.By.className("ext-hubs-card-carousel-content" /* ClassNames.featureCardContainer */));
                if (await featureCardContainer?.isDisplayed()) {
                    return new KoBrowseFeatureCards(featureCardContainer);
                }
                throw new Error("Browse feature card container not found or is not displayed yet in KO browse");
            })();
        }
        get grid() {
            return (async () => {
                const dataGrid = this._blade.element(Controls_1.DataGrid);
                if (await dataGrid?.isDisplayed()) {
                    return new KoBrowseGrid(dataGrid);
                }
                throw new Error("Browse grid not found or is not displayed yet in KO browse");
            })();
        }
        get pager() {
            return (async () => {
                const pagerControl = this._blade.element(Locators_1.By.className("ext-hubs-artbrowse-pagecontainer" /* ClassNames.pagerControl */));
                if (await pagerControl?.isDisplayed()) {
                    const pagerCountElement = this._blade.element(Locators_1.By.className("ext-hubs-artbrowse-count" /* ClassNames.pagerCount */));
                    return new KoBrowsePager(pagerControl, pagerCountElement);
                }
                throw new Error("Browse pager not found or is not displayed yet in KO browse");
            })();
        }
        async launchFeedback() {
            const feedbackLink = this._blade.element(Locators_1.By.className("ext-hubs-artbrowse-feedbacklink" /* ClassNames.feedbackLink */));
            if (await feedbackLink?.isDisplayed()) {
                feedbackLink.click();
                return true;
            }
            return false;
        }
    }
    KoBrowse.KoBrowseBlade = KoBrowseBlade;
    class KoBrowseCommands {
        constructor(_toolbar) {
            this._toolbar = _toolbar;
        }
        get commandCount() {
            return (async () => (await this._getDisplayedItems()).length)();
        }
        get commands() {
            return (async () => {
                const items = await this._getDisplayedItems();
                return items.map((item) => new KoBrowseCommand(item));
            })();
        }
        async getCommand(index) {
            return new KoBrowseCommand((await this._getDisplayedItems())[index]);
        }
        async getCommandByText(commandText, options) {
            const { index } = options || {};
            const items = await this._getDisplayedItems();
            const itemsWithText = items.map(async (item) => ({
                item,
                match: checkStringMatch(await item.getText(), commandText, options),
            }));
            const results = (await Promise.all(itemsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseCommand(results[0].item);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseCommand(results[index].item);
            }
            throw new Error(`Browse command with text ${commandText} not found: ${results.length === 0 ? "text not found" : "text found in multiple commands"}`);
        }
        async _getDisplayedItems() {
            const items = await this._toolbar.all(Controls_1.ToolbarItem);
            const filteredItems = await Promise.all(items.map(async (item) => ({
                item,
                displayed: await item.isDisplayed(),
            })));
            return filteredItems.filter((item) => item.displayed).map((items) => items.item);
        }
    }
    class KoBrowseCommand {
        constructor(_toolbarItem) {
            this._toolbarItem = _toolbarItem;
        }
        get text() {
            return (async () => cleanText(await this._toolbarItem.getText()))();
        }
        get image() {
            return (async () => {
                const icon = this._toolbarItem.element(Locators_1.By.className("azc-toolbarButton-icon" /* ClassNames.toolbarIcon */));
                return Promise.resolve(await icon?.element(Locators_1.By.tagName("svg")).getInnerHtml());
            })();
        }
        get isSeparator() {
            return (async () => {
                return this._toolbarItem.hasClass("azc-toolbarSeparator" /* ClassNames.toolbarSeparator */);
            })();
        }
        get isMenu() {
            return (async () => {
                return this._toolbarItem.hasClass("azc-toolbarMenuButton" /* ClassNames.toolbarMenuButton */);
            })();
        }
        async openMenu() {
            if (!(await this.isMenu)) {
                throw new Error("This command is not a menu item");
            }
            return await this._expandMenuPopup(this._toolbarItem);
        }
        async closeMenu() {
            if (!(await this.isMenu)) {
                throw new Error("This command is not a menu item");
            }
            return await this._collapseMenuPopup(this._toolbarItem);
        }
        get menuCommands() {
            return (async () => {
                if (!(await this.isMenu)) {
                    throw new Error("This command is not a menu item");
                }
                const menuPopup = this._toolbarItem.element(Locators_1.By.className("azc-toolbarButton-groupPopup" /* ClassNames.toolbarButtonGroupPopup */));
                const items = await this._getDisplayedItems(menuPopup);
                return items.map((item) => new KoBrowseMenuCommand(item));
            })();
        }
        async getMenuCommand(index) {
            if (!(await this.isMenu)) {
                throw new Error("This command is not a menu item");
            }
            const menuPopup = this._toolbarItem.element(Locators_1.By.className("azc-toolbarButton-groupPopup" /* ClassNames.toolbarButtonGroupPopup */));
            const items = await this._getDisplayedItems(menuPopup);
            return new KoBrowseMenuCommand(items[index]);
        }
        async getMenuCommandByText(commandText, options) {
            const { index } = options || {};
            if (!(await this.isMenu)) {
                throw new Error("This command is not a menu item");
            }
            const menuPopup = this._toolbarItem.element(Locators_1.By.className("azc-toolbarButton-groupPopup" /* ClassNames.toolbarButtonGroupPopup */));
            const items = await this._getDisplayedItems(menuPopup);
            const itemsWithText = items.map(async (item) => ({
                item,
                match: checkStringMatch(await item.getText(), commandText, options),
            }));
            const results = (await Promise.all(itemsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseMenuCommand(results[0].item);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseMenuCommand(results[index].item);
            }
            throw new Error(`Browse menu command with text ${commandText} not found: ${results.length === 0 ? "text not found" : "text found in multiple commands"}`);
        }
        async activate() {
            await this._toolbarItem.click();
        }
        async _expandMenuPopup(toolbarItem) {
            const menuPopup = toolbarItem.element(Locators_1.By.className("azc-toolbarButton-groupPopup" /* ClassNames.toolbarButtonGroupPopup */));
            if (await menuPopup.hasClass("fxs-dropmenu-is-open" /* ClassNames.dropMenuIsOpen */)) {
                return true;
            }
            // Click to open the menu
            await toolbarItem.click();
            return await menuPopup.hasClass("fxs-dropmenu-is-open" /* ClassNames.dropMenuIsOpen */);
        }
        async _collapseMenuPopup(toolbarItem) {
            const menuPopup = toolbarItem.element(Locators_1.By.className("azc-toolbarButton-groupPopup" /* ClassNames.toolbarButtonGroupPopup */));
            if (!(await menuPopup.hasClass("fxs-dropmenu-is-open" /* ClassNames.dropMenuIsOpen */))) {
                return true;
            }
            // Send ESC to close the menu.
            await menuPopup.sendKeys(Index_1.Key.ESCAPE);
            return !(await menuPopup.hasClass("fxs-dropmenu-is-open" /* ClassNames.dropMenuIsOpen */));
        }
        async _getDisplayedItems(menuPopup) {
            const items = await menuPopup.all(CommandBarMenuItem_1.default);
            const filteredItems = await Promise.all(items.map(async (item) => ({
                item,
                displayed: await item.isDisplayed(),
            })));
            return filteredItems.filter((item) => item.displayed).map((items) => items.item);
        }
    }
    class KoBrowseMenuCommand {
        constructor(_commandBarMenuItem) {
            this._commandBarMenuItem = _commandBarMenuItem;
        }
        get text() {
            return (async () => cleanText(await this._commandBarMenuItem.getText()))();
        }
        get image() {
            return (async () => {
                const icon = this._commandBarMenuItem.element(Locators_1.By.className("azc-toolbarButton-icon" /* ClassNames.toolbarIcon */));
                return Promise.resolve(await icon?.element(Locators_1.By.tagName("svg")).getInnerHtml());
            })();
        }
        get isSeparator() {
            return (async () => {
                return this._commandBarMenuItem.hasClass("azc-toolbarSeparator" /* ClassNames.toolbarSeparator */);
            })();
        }
        get isMenu() {
            return Promise.resolve(false);
        }
        async openMenu() {
            return Promise.reject("This command is not a menu item");
        }
        async closeMenu() {
            return Promise.reject("This command is not a menu item");
        }
        get menuCommands() {
            return Promise.reject("This command is not a menu item");
        }
        async getMenuCommand(_index) {
            return Promise.reject("This command is not a menu item");
        }
        async getMenuCommandByText(_commandText, _options) {
            return Promise.reject("This command is not a menu item");
        }
        async activate() {
            await this._commandBarMenuItem.click();
        }
    }
    class KoBrowseSearch {
        constructor(_textBox) {
            this._textBox = _textBox;
        }
        get searchTerm() {
            return (async () => cleanText(await this._textBox.value()))();
        }
        async setSearchTerm(searchTerm) {
            if ((await this.searchTerm) === searchTerm) {
                return true;
            }
            await this._textBox.clear();
            await this._textBox.sendKeys(searchTerm);
            return (await this.searchTerm) === searchTerm;
        }
    }
    class KoBrowseFilters {
        constructor(_filterPills) {
            this._filterPills = _filterPills;
        }
        get filterCount() {
            return (async () => (await this._filterPills.all(Locators_1.By.className("fxc-pill-collection-item" /* ClassNames.pillCollectionItem */))).length)();
        }
        get filters() {
            return (async () => {
                const filterPills = await this._filterPills.all(ArgBrowseBlade_1.BrowseFilterPill);
                return filterPills.map((filterPill) => new KoBrowseFilter(filterPill));
            })();
        }
        async getFilter(index) {
            return new KoBrowseFilter((await this._filterPills.all(ArgBrowseBlade_1.BrowseFilterPill))[index]);
        }
        async getFilterByColumn(column, options) {
            const { index } = options || {};
            const filterPills = await this._filterPills.all(ArgBrowseBlade_1.BrowseFilterPill);
            const filterPillsWithText = filterPills.map(async (filterPill) => ({
                filterPill: filterPill,
                match: checkStringMatch(await filterPill.getFilterText(), column, options),
            }));
            const results = (await Promise.all(filterPillsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseFilter(results[0].filterPill);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseFilter(results[index].filterPill);
            }
            throw new Error(`Browse filter with column ${column} not found: ${results.length === 0 ? "text not found" : "text found in multiple commands"}`);
        }
        async addFilter(_filter) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
        async removeFilter(_column, _options) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    class KoBrowseFilter {
        constructor(_filterPill) {
            this._filterPill = _filterPill;
        }
        get column() {
            return (async () => {
                return cleanText(await this._filterPill.getFilterText());
            })();
        }
        get operator() {
            return (async () => {
                return cleanText(await this._filterPill.getOperatorText());
            })();
        }
        get valueText() {
            return (async () => {
                return cleanText(await this._filterPill.getValueText());
            })();
        }
        get values() {
            // TODO andrewfo : implement
            // TODO andrewfo : yikes, need to open the dialog and find all the values...
            return Promise.reject("Not implemented");
        }
    }
    class KoBrowseFeatureCards {
        constructor(_featureCardContainer) {
            this._featureCardContainer = _featureCardContainer;
        }
        get cardCount() {
            return (async () => (await this._featureCardContainer.all(Locators_1.By.className("ext-hubs-card" /* ClassNames.featureCard */))).length)();
        }
        get cards() {
            return (async () => {
                const cards = await this._featureCardContainer.all(Locators_1.By.className("ext-hubs-card" /* ClassNames.featureCard */));
                return cards.map((card) => new KoBrowseFeatureCard(card));
            })();
        }
        async getCard(index) {
            return new KoBrowseFeatureCard((await this._featureCardContainer.all(Locators_1.By.className("ext-hubs-card" /* ClassNames.featureCard */)))[index]);
        }
        async getCardByText(cardText, options) {
            const { index } = options || {};
            const cards = await this._featureCardContainer.all(Locators_1.By.className("ext-hubs-card" /* ClassNames.featureCard */));
            const cardsWithText = cards.map(async (card) => ({
                commandBarItem: card,
                match: checkStringMatch(await card.element(Locators_1.By.className("ext-hubs-card-label" /* ClassNames.featureCardLabel */))?.getText(), cardText, options),
            }));
            const results = (await Promise.all(cardsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseFeatureCard(results[0].commandBarItem);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseFeatureCard(results[index].commandBarItem);
            }
            throw new Error(`Browse feature card with text ${cardText} not found: ${results.length === 0 ? "text not found" : "text found in multiple commands"}`);
        }
    }
    class KoBrowseFeatureCard {
        constructor(_featureCard) {
            this._featureCard = _featureCard;
        }
        get text() {
            return (async () => {
                const cardLabel = this._featureCard.element(Locators_1.By.className("ext-hubs-card-label" /* ClassNames.featureCardLabel */));
                return cleanText(await cardLabel?.getText());
            })();
        }
        get image() {
            return (async () => {
                const cardIcon = this._featureCard.element(Locators_1.By.className("ext-hubs-card-icon" /* ClassNames.featureCardIcon */));
                return Promise.resolve(await cardIcon?.element(Locators_1.By.tagName("svg")).getInnerHtml());
            })();
        }
        get count() {
            return (async () => {
                const cardCount = this._featureCard.element(Locators_1.By.className("ext-hubs-card-count" /* ClassNames.featureCardCount */));
                return cleanText(await cardCount?.getText());
            })();
        }
        async activate() {
            await this._featureCard.click();
        }
    }
    class KoBrowseGrid {
        constructor(_dataGrid) {
            this._dataGrid = _dataGrid;
        }
        get columnCount() {
            return (async () => (await this._dataGrid.columnHeaders).length)();
        }
        get columns() {
            return (async () => {
                const columns = await this._dataGrid.columnHeaders;
                return Promise.all(columns.map((column) => new KoBrowseGridColumn(column)));
            })();
        }
        async getColumn(index) {
            return new KoBrowseGridColumn((await this._dataGrid.columnHeaders)[index]);
        }
        async getColumnByLabel(label, options) {
            const { index } = options || {};
            const columns = await this._dataGrid.columnHeaders;
            const columnsWithText = columns.map(async (column) => ({
                column,
                match: checkStringMatch(await column.getText(), label, options),
            }));
            const results = (await Promise.all(columnsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseGridColumn(results[0].column);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseGridColumn(results[index].column);
            }
            throw new Error(`Browse grid column with text ${label} not found: ${results.length === 0 ? "text not found" : "text found in multiple columns"}`);
        }
        get rowCount() {
            return (async () => (await this._dataGrid.rows).length)();
        }
        get rows() {
            return (async () => {
                const rows = await this._dataGrid.rows;
                return Promise.all(rows.map((row) => new KoBrowseGridRow(row)));
            })();
        }
        async getRow(index) {
            return new KoBrowseGridRow((await this._dataGrid.rows)[index]);
        }
        async getRowByCellText(cellText, cellIndex, options) {
            const { index } = options || {};
            const rows = await this._dataGrid.rows;
            const rowsWithText = rows.map(async (row) => ({
                row,
                match: checkStringMatch(await (await row.cells)[cellIndex].getText(), cellText, options),
            }));
            const results = (await Promise.all(rowsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseGridRow(results[0].row);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseGridRow(results[index].row);
            }
            throw new Error(`Browse grid row with cell text ${cellText} in cell index ${cellIndex} not found: ${results.length === 0 ? "text not found" : "text found in multiple rows"}`);
        }
        get sorting() {
            // TODO andrewfo : implement
            // Not sure we can determine this properly...
            return Promise.reject("Not implemented");
        }
        async setSorting(_sorting) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    class KoBrowseGridColumn {
        constructor(_columnHeader) {
            this._columnHeader = _columnHeader;
        }
        get label() {
            return (async () => cleanText(await this._columnHeader.getText()))();
        }
    }
    class KoBrowseGridRow {
        constructor(_gridRow) {
            this._gridRow = _gridRow;
        }
        get cellCount() {
            return (async () => (await this._gridRow.cells).length)();
        }
        get cells() {
            return (async () => {
                const cells = await this._gridRow.cells;
                return Promise.all(cells.map((cell) => new KoBrowseGridCell(cell)));
            })();
        }
        async getCell(index) {
            return new KoBrowseGridCell((await this._gridRow.cells)[index]);
        }
        async getCellByText(cellText, options) {
            const { index } = options || {};
            const cells = await this._gridRow.cells;
            const cellsWithText = cells.map(async (cell) => ({
                cell,
                match: checkStringMatch(await cell.getText(), cellText, options),
            }));
            const results = (await Promise.all(cellsWithText)).filter((result) => result.match);
            if (index === undefined && results.length === 1) {
                return new KoBrowseGridCell(results[0].cell);
            }
            else if (index !== undefined && index >= 0 && index < results.length) {
                return new KoBrowseGridCell(results[index].cell);
            }
            throw new Error(`Browse grid cell with text ${cellText} in index ${index || 0} not found: ${results.length === 0 ? "text not found" : "text found in multiple cells"}`);
        }
        async select() {
            // TODO andrewfo : not sure if this is correct...
            if (!(await this._gridRow.isSelected())) {
                return this._gridRow.click();
            }
        }
        async unselect() {
            // TODO andrewfo : not sure if this is correct...
            if (await this._gridRow.isSelected()) {
                return this._gridRow.click();
            }
        }
    }
    class KoBrowseGridCell {
        constructor(_gridCell) {
            this._gridCell = _gridCell;
        }
        get text() {
            return (async () => cleanText(await this._gridCell.getText()))();
        }
        get image() {
            return (async () => {
                const svgs = await this._gridCell.all(Locators_1.By.tagName("svg"));
                if (svgs?.length === 1) {
                    return await svgs[0].getInnerHtml();
                }
                return null;
            })();
        }
        async activate() {
            await this._gridCell.click();
        }
        async executeContextMenu(_itemText) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    const pagerRowCountRegEx = /Showing (\d+) to (\d+) of (\d+) records/;
    class KoBrowsePager {
        constructor(_pager, _pagerCount) {
            this._pager = _pager;
            this._pagerCount = _pagerCount;
        }
        get pageSize() {
            return (async () => {
                const pagerCountText = cleanText(await this._pagerCount?.getText());
                const matches = pagerRowCountRegEx.exec(pagerCountText);
                if (matches?.length === 4) {
                    // Showing <start> to <end> of <recordCount> records
                    const start = parseInt(matches[1]);
                    const end = parseInt(matches[2]);
                    const recordCount = parseInt(matches[3]);
                    if (end === recordCount && start === 1) {
                        return 100; // Indeterminate, assume default of 100.
                    }
                    return end - start + 1;
                }
                throw new Error("Pager count text not in correct format");
            })();
        }
        get pageCount() {
            return (async () => {
                const suffix = this._pager.element(Locators_1.By.className("ext-hubs-artbrowse-pagesuffix" /* ClassNames.pagerSuffix */));
                const suffixText = cleanText(await suffix?.getText());
                if (suffixText.startsWith("of ")) {
                    return parseInt(suffixText.substring(3));
                }
                throw new Error("Pager suffix text not in correct format");
            })();
        }
        get page() {
            return (async () => {
                const pagePicker = this._pager.element(Controls_1.GroupDropDownField);
                const pageValue = await pagePicker.getValue();
                return parseInt(pageValue);
            })();
        }
        get recordCount() {
            return (async () => {
                const pagerCountText = cleanText(await this._pagerCount?.getText());
                const matches = pagerRowCountRegEx.exec(pagerCountText);
                if (matches?.length === 4) {
                    // Showing <start> to <end> of <recordCount> records
                    const recordCount = parseInt(matches[3]);
                    return recordCount;
                }
                throw new Error("Pager count text not in correct format");
            })();
        }
        async gotoPage(_page) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
})(KoBrowse || (KoBrowse = {}));
var ReactBrowse;
(function (ReactBrowse) {
    class ReactBrowseBlade {
        constructor(_portal) {
            this._portal = _portal;
            this.expectGroupingInCommandBar = true;
        }
        get commands() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.className("ms-CommandBar" /* ClassNames.commandBar */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 command bar, found ${elements.length}`);
                }
                const commandBar = elements[0];
                if (await commandBar?.isDisplayed()) {
                    return new ReactBrowseCommands(this._portal, commandBar);
                }
                throw new Error("Browse command bar not found or is not displayed yet in react browse");
            });
        }
        get grouping() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.className("ms-CommandBar" /* ClassNames.commandBar */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 command bar, found ${elements.length}`);
                }
                const commandBar = elements[0];
                if (await commandBar?.isDisplayed()) {
                    const commands = new ReactBrowseCommands(this._portal, commandBar);
                    const command = await commands.getCommandByClassName("browse-grouping");
                    const commandText = cleanText(await command.text)?.toLowerCase();
                    if (commandText?.startsWith("group by ")) {
                        return commandText?.substring(9)?.trim();
                    }
                    return commandText?.trim();
                }
                throw new Error("Browse command bar not found or is not displayed yet in react browse");
            });
        }
        async setGrouping(grouping) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.className("ms-CommandBar" /* ClassNames.commandBar */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 command bar, found ${elements.length}`);
                }
                const commandBar = elements[0];
                if (await commandBar?.isDisplayed()) {
                    const commands = new ReactBrowseCommands(this._portal, commandBar);
                    const command = await commands.getCommandByClassName("browse-grouping");
                    let optionToSelect = "";
                    let expectedSelectedText = "";
                    if (grouping.toLowerCase() === "none" ||
                        grouping.toLowerCase() === "group by none" ||
                        grouping.toLowerCase() === "no grouping") {
                        optionToSelect = "group by none";
                        expectedSelectedText = "group by none";
                    }
                    else if (grouping.toLowerCase().startsWith("group by ")) {
                        optionToSelect = grouping;
                        expectedSelectedText = grouping.slice(9);
                    }
                    else {
                        optionToSelect = "group by " + grouping;
                        expectedSelectedText = grouping;
                    }
                    if (cleanText(await command.text)?.toLowerCase() !== expectedSelectedText.toLowerCase()) {
                        await command.openMenu();
                        const menuCommand = await command.getMenuCommandByText(optionToSelect, { ignoreCase: true });
                        await menuCommand.activate();
                    }
                    return cleanText(await command.text)?.toLowerCase() === expectedSelectedText.toLowerCase();
                }
                throw new Error("Browse command bar not found or is not displayed yet in react browse");
            });
        }
        get search() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.className("ms-SearchBox" /* ClassNames.searchBoxField */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 search box, found ${elements.length}`);
                }
                const searchTextBox = elements[0];
                if (await searchTextBox?.isDisplayed()) {
                    return new ReactBrowseSearch(searchTextBox);
                }
                throw new Error("Browse search text box not found or is not displayed yet in react browse");
            });
        }
        get filters() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.className("pillCollection" /* ClassNames.filterPillCollection */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 filter pill collection, found ${elements.length}`);
                }
                const filterPills = elements[0];
                if (await filterPills?.isDisplayed()) {
                    return new ReactBrowseFilters(filterPills);
                }
                throw new Error("Browse filter pills not found or is not displayed yet in react browse");
            });
        }
        get featureCards() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.xpath("[data-testid='uilc-AzCardGrid']"));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 card grid, found ${elements.length}`);
                }
                const cardGrid = elements[0];
                if (await cardGrid?.isDisplayed()) {
                    return new ReactBrowseFeatureCards(cardGrid);
                }
                throw new Error("Browse grid not found or is not displayed yet in react browse");
            });
        }
        get grid() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.className("ms-DetailsList" /* ClassNames.detailsList */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 details list, found ${elements.length}`);
                }
                const detailsList = elements[0];
                if (await detailsList?.isDisplayed()) {
                    return new ReactBrowseGrid(detailsList);
                }
                throw new Error("Browse grid not found or is not displayed yet in react browse");
            });
        }
        get pager() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const elements = await this._portal.all(Locators_1.By.classStartsWith("pagerContainer-" /* ClassNames.pagerContainerPrefix */));
                if (elements.length !== 1) {
                    throw new Error(`Expected 1 pager container, found ${elements.length}`);
                }
                const pagerContainer = elements[0];
                if (await pagerContainer?.isDisplayed()) {
                    return new ReactBrowsePager(pagerContainer);
                }
                throw new Error("Browse search text box not found or is not displayed yet in react browse");
            });
        }
        async launchFeedback() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const pagerRightPanel = this._portal.element(Locators_1.By.classStartsWith("pagerRightPanel-" /* ClassNames.pagerRightPanelPrefix */));
                if (await pagerRightPanel?.isDisplayed()) {
                    const feedbackLink = pagerRightPanel.element(Locators_1.By.className("ms-Link" /* ClassNames.link */));
                    if (await feedbackLink?.isDisplayed()) {
                        feedbackLink.click();
                        return true;
                    }
                }
                return false;
            });
        }
    }
    ReactBrowse.ReactBrowseBlade = ReactBrowseBlade;
    class ReactBrowseCommands {
        constructor(_portal, _commandBar) {
            this._portal = _portal;
            this._commandBar = _commandBar;
        }
        get commandCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return (await this._commandBar.all(Locators_1.By.className("ms-OverflowSet-item" /* ClassNames.commandBarItem */))).length;
            });
        }
        get commands() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const commands = await this._commandBar.all(Locators_1.By.className("ms-OverflowSet-item" /* ClassNames.commandBarItem */));
                return await Promise.all(commands.map((command) => new ReactBrowseCommand(this._portal, command)));
            });
        }
        async getCommand(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const commands = await this._commandBar.all(Locators_1.By.className("ms-OverflowSet-item" /* ClassNames.commandBarItem */));
                return (await Promise.all(commands.map((command) => new ReactBrowseCommand(this._portal, command))))[index];
            });
        }
        async getCommandByText(commandText, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const commands = await this._commandBar.all(Locators_1.By.className("ms-OverflowSet-item" /* ClassNames.commandBarItem */));
                const commandsWithText = commands.map(async (command) => ({
                    command,
                    match: checkStringMatch(await command.getText(), commandText, options),
                }));
                const results = (await Promise.all(commandsWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return new ReactBrowseCommand(this._portal, results[0].command);
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return new ReactBrowseCommand(this._portal, results[index].command);
                }
                throw new Error(`Browse command with text ${commandText} not found: ${results.length === 0 ? "text not found" : "text found in multiple commands"}`);
            });
        }
        async getCommandByClassName(className) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const commands = await this._commandBar.all(Locators_1.By.className("ms-OverflowSet-item" /* ClassNames.commandBarItem */));
                const commandsWithMatch = commands.map(async (command) => {
                    const buttons = await command.all(Locators_1.By.tagName("button"));
                    if (buttons?.length !== 1) {
                        return { command };
                    }
                    return {
                        command,
                        match: await buttons[0].hasClass(className),
                    };
                });
                const results = (await Promise.all(commandsWithMatch)).filter((result) => result.match);
                if (results.length === 1) {
                    return new ReactBrowseCommand(this._portal, results[0].command);
                }
                throw new Error(`Browse command with class ${className} not found`);
            });
        }
    }
    class ReactBrowseCommand {
        constructor(_portal, _command) {
            this._portal = _portal;
            this._command = _command;
        }
        get text() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return cleanText(await this._command.getText());
            });
        }
        get image() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const icons = await this._command.all(Locators_1.By.className("ms-Icon" /* ClassNames.icon */));
                if (icons?.length === 1) {
                    // Image is a fluent icon
                    return await icons[0].getAttribute("data-icon-name");
                }
                const svgs = await this._command.all(Locators_1.By.tagName("svg"));
                if (svgs?.length === 1) {
                    // Found an SVG
                    return await svgs[0].getInnerHtml();
                }
                return null;
            });
        }
        get isSeparator() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const icons = await this._command.all(Locators_1.By.className("ms-Icon" /* ClassNames.icon */));
                if (icons.length === 1) {
                    // Image is a fluent icon, check if the icon is Separator.
                    return (await icons[0].getAttribute("data-icon-name")) === "Separator";
                }
                return false;
            });
        }
        get isMenu() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return (await this._command.all(Locators_1.By.className("ms-Button--hasMenu" /* ClassNames.commandBarButtonWithMenu */))).length !== 0;
            });
        }
        async openMenu() {
            if (!(await this.isMenu)) {
                throw new Error("This command is not a menu item");
            }
            // Reacquire the frame base since the popup was dynamically injected.
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const buttonElement = this._command.element(Locators_1.By.tagName("button"));
                if (buttonElement) {
                    const currentMenuId = await buttonElement.getAttribute("aria-controls");
                    if (currentMenuId?.length) {
                        const containers = await this._portal.all(Locators_1.By.id(currentMenuId));
                        return containers?.length === 1;
                    }
                    // Click to open the menu.
                    await this._command.click();
                    const postActionMenuId = await buttonElement.getAttribute("aria-controls");
                    if (postActionMenuId?.length) {
                        const containers = await this._portal.all(Locators_1.By.id(postActionMenuId));
                        return containers?.length === 1;
                    }
                }
                throw new Error("Unable to determine way to open the menu");
            });
        }
        async closeMenu() {
            if (!(await this.isMenu)) {
                throw new Error("This command is not a menu item");
            }
            // Reacquire the frame base since the popup was dynamically injected.
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const buttonElement = this._command.element(Locators_1.By.tagName("button"));
                if (buttonElement) {
                    const currentMenuId = await buttonElement.getAttribute("aria-controls");
                    if (!currentMenuId?.length) {
                        return true;
                    }
                    // Click to close the menu.
                    await this._command.click();
                    const postActionMenuId = await buttonElement.getAttribute("aria-controls");
                    if (!postActionMenuId?.length) {
                        return true;
                    }
                }
                throw new Error("Unable to determine way to open the menu");
            });
        }
        get menuCommands() {
            return (async () => {
                if (!(await this.isMenu)) {
                    throw new Error("This command is not a menu item");
                }
                // Reacquire the frame base since the popup was dynamically injected.
                return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                    const buttonElement = this._command.element(Locators_1.By.tagName("button"));
                    if (buttonElement) {
                        const currentMenuId = await buttonElement.getAttribute("aria-controls");
                        if (currentMenuId?.length) {
                            const containers = await this._portal.all(Locators_1.By.id(currentMenuId));
                            if (containers?.length !== 1) {
                                throw new Error("Menu not open");
                            }
                            const getMenuCommands = async (contextMenu) => {
                                const menuItems = await contextMenu.all(Locators_1.By.className("ms-ContextualMenu-item"));
                                return menuItems.map((menuItem) => new ReactBrowseCommand(this._portal, menuItem));
                            };
                            const contextMenu = containers[0].element(Locators_1.By.className("ms-ContextualMenu"));
                            if (await contextMenu.hasClass("is-open")) {
                                return await getMenuCommands(contextMenu);
                            }
                        }
                    }
                    throw new Error("Unable to determine menu commands, make sure the menu was open");
                });
            })();
        }
        async getMenuCommand(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return (await this.menuCommands)[index];
            });
        }
        async getMenuCommandByText(commandText, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const commands = await this.menuCommands;
                const commandsWithText = commands.map(async (command) => ({
                    command,
                    match: checkStringMatch(await command.text, commandText, options),
                }));
                const results = (await Promise.all(commandsWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return results[0].command;
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return results[index].command;
                }
                throw new Error(`Browse menu command with text ${commandText} not found: ${results.length === 0 ? "text not found" : "text found in multiple commands"}`);
            });
        }
        async activate() {
            await this._command.click();
        }
    }
    class ReactBrowseSearch {
        constructor(_textBox) {
            this._textBox = _textBox;
        }
        get searchTerm() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const input = this._textBox.element(Locators_1.By.tagName("input"));
                return cleanText(await input.getInputValue());
            });
        }
        async setSearchTerm(searchTerm) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                if ((await this.searchTerm) === searchTerm) {
                    return true;
                }
                const input = this._textBox.element(Locators_1.By.tagName("input"));
                await input.clear();
                await input.sendKeys(searchTerm);
                return (await this.searchTerm) === searchTerm;
            });
        }
    }
    class ReactBrowseFilters {
        constructor(_filterPills) {
            this._filterPills = _filterPills;
        }
        get filterCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return (await this._filterPills.all(Locators_1.By.className("pillCollection-pill" /* ClassNames.filterPillItem */))).length;
            });
        }
        get filters() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const filters = await this._filterPills.all(Locators_1.By.className("pillCollection-pill" /* ClassNames.filterPillItem */));
                return await Promise.all(filters.map((filter) => new ReactBrowseFilter(filter)));
            });
        }
        async getFilter(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const filters = await this._filterPills.all(Locators_1.By.className("pillCollection-addPill" /* ClassNames.filterPillAddItem */));
                return (await Promise.all(filters.map((filter) => new ReactBrowseFilter(filter))))[index];
            });
        }
        async getFilterByColumn(column, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const filters = await this._filterPills.all(Locators_1.By.className("pillCollection-pill" /* ClassNames.filterPillItem */));
                const filtersWithText = filters.map(async (filter) => {
                    const contentContainer = filter.element(Locators_1.By.classStartsWith("pillContentContainer-" /* ClassNames.pillContentContainPrefix */));
                    const contentSpans = await contentContainer.all(Locators_1.By.tagName("span"));
                    if (contentSpans.length !== 3) {
                        return { filter };
                    }
                    return {
                        filter,
                        match: checkStringMatch(await contentSpans[0].getText(), column, options),
                    };
                });
                const results = (await Promise.all(filtersWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return new ReactBrowseFilter(results[0].filter);
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return new ReactBrowseFilter(results[index].filter);
                }
                throw new Error(`Browse filter with column ${column} not found: ${results.length === 0 ? "text not found" : "text found in multiple filters"}`);
            });
        }
        async addFilter(_filter) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
        async removeFilter(_column, _options) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    class ReactBrowseFilter {
        constructor(_filter) {
            this._filter = _filter;
        }
        get column() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const contentContainer = this._filter.element(Locators_1.By.classStartsWith("pillContentContainer-" /* ClassNames.pillContentContainPrefix */));
                const contentSpans = await contentContainer.all(Locators_1.By.tagName("span"));
                if (contentSpans.length === 3) {
                    return cleanText(await contentSpans[0].getText());
                }
            });
        }
        get operator() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const contentContainer = this._filter.element(Locators_1.By.classStartsWith("pillContentContainer-" /* ClassNames.pillContentContainPrefix */));
                const contentSpans = await contentContainer.all(Locators_1.By.tagName("span"));
                if (contentSpans.length === 3) {
                    return cleanText(await contentSpans[1].getText());
                }
            });
        }
        get valueText() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const contentContainer = this._filter.element(Locators_1.By.classStartsWith("pillContentContainer-" /* ClassNames.pillContentContainPrefix */));
                const contentSpans = await contentContainer.all(Locators_1.By.tagName("span"));
                if (contentSpans.length === 3) {
                    return cleanText(await contentSpans[2].getText());
                }
            });
        }
        get values() {
            // TODO andrewfo : implement
            // TODO andrewfo : yikes, need to open the dialog and find all the values...
            return Promise.reject("Not implemented");
        }
    }
    class ReactBrowseFeatureCards {
        constructor(_cardGrid) {
            this._cardGrid = _cardGrid;
        }
        get cardCount() {
            return (async () => {
                return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                    return (await this._cardGrid.all(Locators_1.By.xpath("[data-testid='uilc-AzBrowseCard']"))).length;
                });
            })();
        }
        get cards() {
            return (async () => {
                return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                    return (await this._cardGrid.all(Locators_1.By.xpath("[data-testid='uilc-AzBrowseCard']"))).map((browseCard) => new ReactBrowseFeatureCard(browseCard));
                });
            })();
        }
        async getCard(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const cards = await this._cardGrid.all(Locators_1.By.xpath("[data-testid='uilc-AzBrowseCard']"));
                return new ReactBrowseFeatureCard(cards[index]);
            });
        }
        async getCardByText(cardText, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const cards = await this._cardGrid.all(Locators_1.By.xpath("[data-testid='uilc-AzBrowseCard']"));
                const cardsWithText = cards.map(async (card) => {
                    return {
                        card,
                        match: checkStringMatch(await card.element(Locators_1.By.xpath("h3[data-testid='uilc-AzText']")).getText(), cardText, options),
                    };
                });
                const results = (await Promise.all(cardsWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return new ReactBrowseFeatureCard(results[0].card);
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return new ReactBrowseFeatureCard(results[index].card);
                }
                throw new Error(`Browse feature card with text ${cardText} not found: ${results.length === 0 ? "text not found" : "text found in multiple cards"}`);
            });
        }
    }
    class ReactBrowseFeatureCard {
        constructor(_browseCard) {
            this._browseCard = _browseCard;
        }
        get text() {
            return (async () => {
                return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                    return cleanText(await this._browseCard.element(Locators_1.By.xpath("h3[data-testid='uilc-AzText']")).getText());
                });
            })();
        }
        get image() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const icons = await this._browseCard.all(Locators_1.By.className("ms-Icon" /* ClassNames.icon */));
                if (icons?.length === 1) {
                    // Image is a fluent icon
                    return await icons[0].getAttribute("data-icon-name");
                }
                const svgs = await this._browseCard.all(Locators_1.By.tagName("svg"));
                if (svgs?.length === 1) {
                    // Found an SVG
                    return await svgs[0].getInnerHtml();
                }
                return null;
            });
        }
        get count() {
            return (async () => {
                return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                    return cleanText(await this._browseCard.element(Locators_1.By.xpath("div[data-testid='uilc-AzText']")).getText());
                });
            })();
        }
        async activate() {
            return this._browseCard.click();
        }
    }
    class ReactBrowseGrid {
        constructor(_detailsList) {
            this._detailsList = _detailsList;
        }
        get columnCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Subtract one since the check box column is counted
                return (await this._detailsList.all(Locators_1.By.className("ms-DetailsHeader-cell" /* ClassNames.detailsColumn */))).length - 1;
            });
        }
        get columns() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Skip the check box column
                const columns = (await this._detailsList.all(Locators_1.By.className("ms-DetailsHeader-cell" /* ClassNames.detailsColumn */))).slice(1);
                return Promise.all(columns.map((column) => new ReactBrowseGridColumn(column)));
            });
        }
        async getColumn(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Add one to skip the check box column
                return new ReactBrowseGridColumn((await this._detailsList.all(Locators_1.By.className("ms-DetailsHeader-cell" /* ClassNames.detailsColumn */)))[index + 1]);
            });
        }
        async getColumnByLabel(label, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Skip the check box column
                const columns = (await this._detailsList.all(Locators_1.By.className("ms-DetailsHeader-cell" /* ClassNames.detailsColumn */))).slice(1);
                const columnsWithText = columns.map(async (column) => ({
                    column,
                    match: checkStringMatch(await column.getText(), label, options),
                }));
                const results = (await Promise.all(columnsWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return new ReactBrowseGridColumn(results[0].column);
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return new ReactBrowseGridColumn(results[index].column);
                }
                throw new Error(`Browse grid column with text ${label} not found: ${results.length === 0 ? "text not found" : "text found in multiple columns"}`);
            });
        }
        get rowCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return (await this._detailsList.all(Locators_1.By.className("ms-DetailsRow" /* ClassNames.detailsRow */))).length;
            });
        }
        get rows() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const rows = await this._detailsList.all(Locators_1.By.className("ms-DetailsRow" /* ClassNames.detailsRow */));
                return Promise.all(rows.map((row) => new ReactBrowseGridRow(row)));
            });
        }
        async getRow(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return new ReactBrowseGridRow((await this._detailsList.all(Locators_1.By.className("ms-DetailsRow" /* ClassNames.detailsRow */)))[index]);
            });
        }
        async getRowByCellText(cellText, cellIndex, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const rows = await this._detailsList.all(Locators_1.By.className("ms-DetailsRow" /* ClassNames.detailsRow */));
                const rowsWithText = rows.map(async (row) => ({
                    row,
                    // Add one to cell index skip check box
                    match: checkStringMatch(await (await row.all(Locators_1.By.className("ms-DetailsRow-cell" /* ClassNames.detailsCell */)))[cellIndex + 1].getText(), cellText, options),
                }));
                const results = (await Promise.all(rowsWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return new ReactBrowseGridRow(results[0].row);
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return new ReactBrowseGridRow(results[index].row);
                }
                throw new Error(`Browse grid row with cell text ${cellText} in cell index ${cellIndex} not found: ${results.length === 0 ? "text not found" : "text found in multiple rows"}`);
            });
        }
        get sorting() {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
        async setSorting(_sorting) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    class ReactBrowseGridColumn {
        constructor(_columnHeader) {
            this._columnHeader = _columnHeader;
        }
        get label() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return cleanText(await this._columnHeader.getText());
            });
        }
    }
    class ReactBrowseGridRow {
        constructor(_detailsRow) {
            this._detailsRow = _detailsRow;
        }
        get cellCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Subtract one since the check box column is counted
                return (await this._detailsRow.all(Locators_1.By.className("ms-DetailsRow-cell" /* ClassNames.detailsCell */))).length - 1;
            });
        }
        get cells() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Skip the check box column
                const cells = (await this._detailsRow.all(Locators_1.By.className("ms-DetailsRow-cell" /* ClassNames.detailsCell */))).slice(1);
                return Promise.all(cells.map((cell) => new ReactBrowseGridCell(cell)));
            });
        }
        async getCell(index) {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Add one to skip the check box column
                return new ReactBrowseGridCell((await this._detailsRow.all(Locators_1.By.className("ms-DetailsRow-cell" /* ClassNames.detailsCell */)))[index + 1]);
            });
        }
        async getCellByText(cellText, options) {
            const { index } = options || {};
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                // Skip the check box column
                const cells = (await this._detailsRow.all(Locators_1.By.className("ms-DetailsRow-cell" /* ClassNames.detailsCell */))).slice(1);
                const cellsWithText = cells.map(async (cell) => ({
                    cell,
                    match: checkStringMatch(await cell.getText(), cellText, options),
                }));
                const results = (await Promise.all(cellsWithText)).filter((result) => result.match);
                if (index === undefined && results.length === 1) {
                    return new ReactBrowseGridCell(results[0].cell);
                }
                else if (index !== undefined && index >= 0 && index < results.length) {
                    return new ReactBrowseGridCell(results[index].cell);
                }
                throw new Error(`Browse grid cell with text ${cellText} not found: ${results.length === 0 ? "text not found" : "text found in multiple cells"}`);
            });
        }
        async select() {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
        async unselect() {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    class ReactBrowseGridCell {
        constructor(_detailsRowCell) {
            this._detailsRowCell = _detailsRowCell;
        }
        get text() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                return cleanText(await this._detailsRowCell.getText());
            });
        }
        get image() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const icons = await this._detailsRowCell.all(Locators_1.By.className("ms-Icon" /* ClassNames.icon */));
                if (icons?.length === 1) {
                    // Image is a fluent icon
                    return await icons[0].getAttribute("data-icon-name");
                }
                const svgs = await this._detailsRowCell.all(Locators_1.By.tagName("svg"));
                if (svgs?.length === 1) {
                    // Found an SVG
                    return await svgs[0].getInnerHtml();
                }
                return null;
            });
        }
        async activate() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const links = await this._detailsRowCell.all(Locators_1.By.tagName("a"));
                if (links?.length === 0) {
                    throw new Error("Could not find any links in this cell");
                }
                await links[0].click();
            });
        }
        async executeContextMenu(_itemText) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
    const pagerRowCountRegEx = /Showing (\d+) - (\d+) of (\d+)/;
    class ReactBrowsePager {
        constructor(_pagerContainer) {
            this._pagerContainer = _pagerContainer;
        }
        get pageSize() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const leftContainer = this._pagerContainer.element(Locators_1.By.classStartsWith("pagerLeftPanel-" /* ClassNames.pagerLeftPanelPrefix */));
                if (await leftContainer?.isDisplayed()) {
                    const leftContainerText = cleanText(await leftContainer.getText());
                    const matches = pagerRowCountRegEx.exec(leftContainerText);
                    // Showing <start> - <end> of <recordCount>.
                    if (matches?.length === 4) {
                        const start = parseInt(matches[1]);
                        const end = parseInt(matches[2]);
                        const recordCount = parseInt(matches[3]);
                        let pageSize = 0;
                        if (end === recordCount && start === 1) {
                            pageSize = -1; // Indeterminate
                        }
                        else {
                            pageSize = end - start + 1;
                        }
                        return pageSize;
                    }
                }
                throw new Error(`Could not get the page size`);
            });
        }
        get pageCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const leftContainer = this._pagerContainer.element(Locators_1.By.classStartsWith("pagerLeftPanel-" /* ClassNames.pagerLeftPanelPrefix */));
                if (await leftContainer?.isDisplayed()) {
                    const leftContainerText = cleanText(await leftContainer.getText());
                    const matches = pagerRowCountRegEx.exec(leftContainerText);
                    // Showing <start> - <end> of <recordCount>.
                    if (matches?.length === 4) {
                        const start = parseInt(matches[1]);
                        const end = parseInt(matches[2]);
                        const recordCount = parseInt(matches[3]);
                        const pageSize = end - start + 1;
                        return Math.floor((recordCount + (pageSize - 1)) / pageSize);
                    }
                }
                throw new Error(`Could not get the page count`);
            });
        }
        get page() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const leftContainer = this._pagerContainer.element(Locators_1.By.classStartsWith("pagerLeftPanel-" /* ClassNames.pagerLeftPanelPrefix */));
                if (await leftContainer?.isDisplayed()) {
                    const leftContainerText = cleanText(await leftContainer.getText());
                    const matches = pagerRowCountRegEx.exec(leftContainerText);
                    // Showing <start> - <end> of <recordCount>.
                    if (matches?.length === 4) {
                        const start = parseInt(matches[1]);
                        const end = parseInt(matches[2]);
                        const pageSize = end - start + 1;
                        return Math.floor(start / pageSize) + 1;
                    }
                }
                throw new Error(`Could not get the page count`);
            });
        }
        get recordCount() {
            return (0, ReactView_1.executeInReactViewIframe)(Locators_1.By.className("fxs-reactview-frame-active"), async () => {
                const leftContainer = this._pagerContainer.element(Locators_1.By.classStartsWith("pagerLeftPanel-" /* ClassNames.pagerLeftPanelPrefix */));
                if (await leftContainer?.isDisplayed()) {
                    const leftContainerText = cleanText(await leftContainer.getText());
                    const matches = pagerRowCountRegEx.exec(leftContainerText);
                    if (matches?.length === 4) {
                        // Showing <start> - <end> of <recordCount>.
                        return parseInt(matches[3]);
                    }
                }
                throw new Error(`Could not get the page count`);
            });
        }
        async gotoPage(_page) {
            // TODO andrewfo : implement
            return Promise.reject("Not implemented");
        }
    }
})(ReactBrowse || (ReactBrowse = {}));
const nonWordRegEx = /[^\w\-.()/[\]]/g;
function cleanText(text) {
    return text.replaceAll(nonWordRegEx, " ").trim();
}
function checkStringMatch(actualText, expectedText, options) {
    const { ignoreCase, textComparison } = options || {};
    switch (textComparison) {
        case 1 /* TextComparison.StartsWith */:
            return ignoreCase
                ? cleanText(actualText?.toLowerCase())?.startsWith(expectedText?.toLowerCase())
                : cleanText(actualText)?.startsWith(expectedText);
        case 2 /* TextComparison.EndsWith */:
            return ignoreCase
                ? cleanText(actualText?.toLowerCase())?.endsWith(expectedText?.toLowerCase())
                : cleanText(actualText)?.endsWith(expectedText);
        case 3 /* TextComparison.Includes */:
            return ignoreCase
                ? cleanText(actualText?.toLowerCase())?.includes(expectedText?.toLowerCase())
                : cleanText(actualText)?.includes(expectedText);
        default:
            return ignoreCase
                ? cleanText(actualText?.toLowerCase()) === expectedText?.toLowerCase()
                : cleanText(actualText) === expectedText;
    }
}
//# sourceMappingURL=BrowseBlade.js.map