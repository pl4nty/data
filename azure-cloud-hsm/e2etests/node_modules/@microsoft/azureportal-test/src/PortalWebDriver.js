"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortalWebDriver = exports.WebDriverElement = void 0;
const fs = require("fs");
const path = require("path");
const webdriver = require("selenium-webdriver");
const LogLevel_1 = require("./LogLevel");
const PortalElement_1 = require("./PortalElement");
const String = require("./Utils/String");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const Logger_1 = require("./Logger");
const BrowserAutomationType_1 = require("./BrowserAutomationType");
const Guid_1 = require("./Utils/Guid");
const RunScripts_1 = require("./Utils/RunScripts");
// The findup typescript definitions are outdated in typings so don't have typescript import them
// eslint-disable-next-line @typescript-eslint/no-require-imports
const findup = require("findup-sync");
const diagnosticsLog = Logger_1.default.diagnostics.extend("PortalWebDriver");
class WebDriverElement {
    constructor(element) {
        this.element = element;
        this.getAttribute = (0, PortalElement_1.retry)(this, async (name) => {
            return await this.element.getAttribute(name);
        }, "WebDriverElement.getAttribute()");
        this.findElement = (0, PortalElement_1.retry)(this, async (locator, waitUntilLocated, timeout) => {
            let element;
            if (waitUntilLocated) {
                element = await PortalWebDriver.getDriver().wait(webdriver.until.elementLocated(() => this.element.findElement(locator)), timeout, String.format("Timed out waiting {1} milliseconds for element to be located by {0}.\n", locator.toString(), timeout));
            }
            else {
                try {
                    element = await this.element.findElement(locator);
                }
                catch (e) {
                    // ignore failure NoSuchElementException
                }
            }
            return !!element && new WebDriverElement(element);
        }, "WebDriverElement.findElement()");
        this.findElements = (0, PortalElement_1.retry)(this, async (locator, waitUntilLocated, timeout) => {
            let elements;
            if (waitUntilLocated) {
                elements = await PortalWebDriver.getDriver().wait(webdriver.until.elementsLocated(() => this.element.findElements(locator)), timeout, String.format("Timed out waiting {1} milliseconds for elements to be located by {0}.\n", locator.toString(), timeout));
            }
            else {
                try {
                    elements = await this.element.findElements(locator);
                }
                catch (e) {
                    // ignore failure NoSuchElementException
                    elements = [];
                }
            }
            return elements.map((element) => {
                return new WebDriverElement(element);
            });
        }, "WebDriverElement.findElements()");
        this.getCss = (0, PortalElement_1.retry)(this, async (property) => {
            return await this.element.getCssValue(property);
        }, "WebDriverElement.getCss()");
        this.getSelectorPath = (0, PortalElement_1.retry)(this, async () => {
            return await PortalWebDriver.driver.executeScript(`let [htmlElem] = arguments;
            const path = [];
            while (htmlElem.nodeType === Node.ELEMENT_NODE) {
                let selector = htmlElem.nodeName.toLowerCase();
                let sib = htmlElem;
                let nth = 1;
                while ((sib = sib.previousSibling)) {
                    if (sib.nodeName.toLowerCase() === selector) { nth++; }
                }
                if (nth !== 1) { selector += ":nth-of-type(" + nth + ")"; }
                path.unshift(selector);
                htmlElem = htmlElem.parentNode;
            }
            return path.slice(1).join(" > ");
        `, this.element);
        });
        this.getText = (0, PortalElement_1.retry)(this, async () => {
            return await this.element.getText();
        }, "WebDriverElement.getText()");
        this.getTagName = (0, PortalElement_1.retry)(this, async () => {
            return await this.element.getTagName();
        }, "WebDriverElement.getTagName()");
        this.getSize = (0, PortalElement_1.retry)(this, async () => {
            return await this.element.getSize();
        }, "WebDriverElement.getSize()");
        this.getLocation = (0, PortalElement_1.retry)(this, async () => {
            return await this.element.getLocation();
        }, "WebDriverElement.getLocation()");
        this.isDisplayed = (0, PortalElement_1.retry)(this, async () => {
            return await this.element.isDisplayed();
        }, "WebDriverElement.isDisplayed()");
        this.isSelected = (0, PortalElement_1.retry)(this, async () => {
            return this.element.isSelected();
        }, "WebDriverElement.isSelected()");
        this.isEnabled = (0, PortalElement_1.retry)(this, async () => {
            return this.element.isEnabled();
        }, "WebDriverElement.isEnabled()");
    }
    async click(button, dialogCb) {
        dialogCb = dialogCb || (async () => { });
        const normalClick = async () => {
            await this.element.click();
        };
        const scriptClick = async () => {
            const selector = await this.getSelectorPath();
            await (0, RunScripts_1.runScript)(`
                let el = document.querySelector('${selector}');
                if(!el || !"click" in el){
                    throw new Error("Element not found");
                }
                el.click && setTimeout(() => document.querySelector('${selector}').click(), 100);
            `);
            await new Promise((resolve) => setTimeout(resolve, 100));
        };
        if (!button || button === "left") {
            "clickScript" in dialogCb ? await scriptClick() : await normalClick();
        }
        else {
            await PortalWebDriver.getDriver().actions().click(this.element, webdriver.Button.RIGHT).perform();
        }
        if (dialogCb) {
            const alertPromise = PortalWebDriver.getDriver().switchTo().alert();
            let result;
            try {
                result = await alertPromise;
            }
            catch (e) {
                // ignore failure NoAlertOpenError
            }
            if (result) {
                await dialogCb(alertPromise);
            }
        }
    }
    async sendKeys(...var_args) {
        return this.element.sendKeys(...var_args);
    }
    async clear() {
        await this.element.clear();
    }
    async moveMouseAndClick(opt_offset, clickType) {
        const button = clickType === "right" ? webdriver.Button.RIGHT : undefined;
        return PortalWebDriver.driver.actions().mouseMove(this.element, opt_offset).click(button).perform();
    }
    async getInputValue() {
        return this.element.getAttribute("value");
    }
}
exports.WebDriverElement = WebDriverElement;
class PortalWebDriver {
    constructor() {
        //#region IBrowserAutomation
        this.library = BrowserAutomationType_1.BrowserAutomationType.WebDriver;
        this.findElement = (0, PortalElement_1.retry)(this, async (locator, waitUntilLocated, timeout) => {
            let element;
            if (waitUntilLocated) {
                element = await PortalWebDriver.getDriver().wait(webdriver.until.elementLocated(() => PortalWebDriver.getDriver().findElement(locator)), timeout, String.format("Timed out waiting {1} milliseconds for element to be located by {0}.\n", locator.toString(), timeout));
            }
            else {
                try {
                    element = await PortalWebDriver.getDriver().findElement(locator);
                }
                catch {
                    // ignore failure NoSuchElementException
                }
            }
            return !!element && new WebDriverElement(element);
        }, "PortalWebDriver.findElement()");
        this.findElements = (0, PortalElement_1.retry)(this, async (locator, waitUntilLocated, timeout) => {
            let elements;
            if (waitUntilLocated) {
                elements = await PortalWebDriver.getDriver().wait(webdriver.until.elementsLocated(() => PortalWebDriver.getDriver().findElements(locator)), timeout, String.format("Timed out waiting {1} milliseconds for elements to be located by {0}.\n", locator.toString(), timeout));
            }
            else {
                try {
                    elements = await PortalWebDriver.getDriver().findElements(locator);
                }
                catch {
                    elements = [];
                }
            }
            return elements.map((element) => {
                return !!element && new WebDriverElement(element);
            });
        }, "PortalWebDriver.findElements()");
    }
    get driver() {
        return PortalWebDriver.getDriver();
    }
    get error() {
        return webdriver.error;
    }
    get Key() {
        return webdriver.Key;
    }
    async goto(url) {
        await PortalWebDriver.getDriver().get(url);
        return;
    }
    async wait(condition, timeout, opt_messageOrTimeoutErrorFunction, name) {
        return await PortalWebDriver.wait(condition, timeout, opt_messageOrTimeoutErrorFunction, name);
    }
    async executeScript(script, ...var_args) {
        return await PortalWebDriver.executeScript(script, var_args);
    }
    async executeAsyncScript(script, ...var_args) {
        return await PortalWebDriver.executeAsyncScript(script, var_args);
    }
    async getCurrentUrl() {
        return await PortalWebDriver.getCurrentUrl();
    }
    async takeScreenshot(filePrefix) {
        return await PortalWebDriver.takeScreenshot(filePrefix);
    }
    async acceptAlert() {
        return await PortalWebDriver.acceptAlert();
    }
    async dismissAlert() {
        return await PortalWebDriver.dismissAlert();
    }
    async getAlertText() {
        return await PortalWebDriver.getAlertText();
    }
    async getBrowserLogs(level) {
        return await PortalWebDriver.getBrowserLogs(level);
    }
    async closeWindow(index) {
        return await PortalWebDriver.closeWindow(index);
    }
    async resizeWindow(width, height) {
        return await PortalWebDriver.resizeWindow(width, height);
    }
    async quit(closeAlert) {
        return await PortalWebDriver.quit(closeAlert);
    }
    async create(context) {
        return await Promise.resolve(PortalWebDriver.createWebDriver(context));
    }
    async reload() {
        await PortalWebDriver.getDriver().navigate().refresh();
    }
    hasBrowser() {
        return !!PortalWebDriver.driver;
    }
    async getActiveElement() {
        const element = await PortalWebDriver.getDriver().switchTo().activeElement();
        return new WebDriverElement(element);
    }
    async moveMouse(location, offset) {
        const to = location instanceof WebDriverElement ? location.element : location;
        return await this.driver.actions().mouseMove(to, offset).perform();
    }
    async getWindowTitle() {
        return await this.driver.getTitle();
    }
    async sendKeys(...var_args) {
        return await this.driver
            .actions()
            .sendKeys(...var_args)
            .perform();
    }
    async getWindowHandle() {
        return this.driver.getWindowHandle();
    }
    async getAllWindowHandles() {
        return await this.driver.getAllWindowHandles();
    }
    async switchToWindow(handle) {
        return this.driver.switchTo().window(handle);
    }
    /**
     * Gets the internal WebDriver instance used by this Portal object.
     *
     * @returns The WebDriver instance.
     */
    static getDriver() {
        if (!this.driver) {
            throw new Error("Please navigate to the Portal before using any of the methods in this class. Use hasBrowser() function to check whether the driver has been created.");
        }
        return this.driver;
    }
    /**
     * Schedules a command to wait for a condition to hold. The condition may be
     * specified by a promise or a custom function.
     *
     * For a function, the wait will repeatedly evaluate the condition until it returns a truthy value. If any errors occur
     * while evaluating the condition, they will be allowed to propagate. In the event a condition returns a promise, the
     * polling loop will wait for it to be resolved and use the resolved value for whether the condition has been satisified.
     *
     * @param condition The condition to wait on, defined as a promise or a function to evaluate as a condition.
     * @param {number} timeout How long to wait for the condition to be true.
     * @param {string} opt_messageOrTimeoutErrorFunction An optional message to use if the wait times out.
     * @param name The name of the wait.
     * @returns  A promise that will be fulfilled with the first truthy value returned by the condition function, or
     *     rejected if the condition times out.
     */
    static async wait(condition, timeout, opt_messageOrTimeoutErrorFunction, name) {
        return await Promise.resolve((async () => {
            if ([null, undefined].includes(name)) {
                name = (0, Guid_1.newGuid)().substring(0, 6);
            }
            diagnosticsLog(`[Wait ${name}] Entering wait for name ${name}`);
            // We want to keep 0, but not allow null or undefined
            if ([null, undefined].includes(timeout)) {
                timeout = PortalConfigurationManager_1.default.portalContext.timeouts.timeout;
                diagnosticsLog(`[Wait ${name}] Using provided timeout of ${timeout}`);
            }
            if (timeout <=
                PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout) {
                diagnosticsLog(`[Wait ${name}] Provided timeout ${timeout} was less than or equal to the PortalConfigurationManager.portalContext.timeouts.internalWaitForElementLocatedTimeout of ${PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout} which may cause portal.Wait to never retry.  It is recommended to provide a portal.Wait timeout longer than the specified PortalConfigurationManager.portalContext.timeouts.internalWaitForElementLocatedTimeout.`);
            }
            const startTime = Date.now();
            const webDriverCondition = condition;
            const retryableErrors = ["StaleElementReferenceError", "TimeoutError", "NoSuchElementError"];
            try {
                return await this.getDriver().wait(webDriverCondition, timeout, typeof opt_messageOrTimeoutErrorFunction === "string"
                    ? opt_messageOrTimeoutErrorFunction
                    : null);
            }
            catch (error) {
                const errorName = error.name || "";
                diagnosticsLog(`[Wait ${name}] Error '${errorName}' occurred in Portal.wait condition.`);
                if (retryableErrors.includes(errorName)) {
                    Logger_1.default.warning(`[Wait ${name}] ${errorName} caught at Portal.wait.`);
                    const elapsed = Date.now() - startTime;
                    const newTimeout = timeout - elapsed;
                    if (newTimeout <= 0) {
                        diagnosticsLog(`[Wait ${name}] Maximum amount of time retrying has been reached.  Error '${errorName}' occurred in Portal.wait condition.  Not retrying... Condition was: ${condition.toString()}`);
                        throw typeof opt_messageOrTimeoutErrorFunction === "string" ||
                            opt_messageOrTimeoutErrorFunction === null ||
                            opt_messageOrTimeoutErrorFunction === undefined
                            ? error
                            : await opt_messageOrTimeoutErrorFunction();
                    }
                    diagnosticsLog(`[Wait ${name}] Retrying after '${errorName}' caught at Portal.wait.`);
                    return await this.wait(condition, newTimeout, opt_messageOrTimeoutErrorFunction, name);
                }
                diagnosticsLog(`[Wait ${name}] Unhandled error '${errorName}' occurred in Portal.wait condition.  Not retrying... Condition was: ${condition.toString()}`);
                throw typeof opt_messageOrTimeoutErrorFunction === "string" ||
                    opt_messageOrTimeoutErrorFunction === null ||
                    opt_messageOrTimeoutErrorFunction === undefined
                    ? error
                    : await opt_messageOrTimeoutErrorFunction();
            }
        })());
    }
    /**
     * Schedules a command to execute JavaScript in the context of the currently
     * selected frame or window. The script fragment will be executed as the body
     * of an anonymous function. If the script is provided as a function object,
     * that function will be converted to a string for injection into the target
     * window.
     *
     * @param {string} script The script to execute.
     * @param {...*} var_args The arguments to pass to the script.
     * @returns A promise that will resolve to the scripts return value.
     */
    static async executeScript(script, ...var_args) {
        const promises = var_args.map((i) => {
            if (Array.isArray(i)) {
                i = i[0];
            }
            if (i instanceof PortalElement_1.default) {
                // Get the webdriver web element to pass down to webdriver's executeScript
                return i.getWebElements().then((r) => r[0].element); // take the first element (same behavior as PortalElement)
            }
            else {
                return i;
            }
        });
        const args = await Promise.all(promises);
        return await this.getDriver().executeScript(script, ...args);
    }
    /**
     * dismiss an alert if one is present.
     *
     * @returns A promise that will be resolved when the alert is dismissed.
     */
    static async dismissAlert() {
        return await new Promise((resolve) => {
            this.getDriver()
                .switchTo()
                .alert()
                .dismiss()
                .then(() => resolve(null))
                .catch(() => {
                resolve(null);
            });
        });
    }
    /**
     * Schedules a command to execute asynchronous JavaScript in the context of the
     * currently selected frame or window. The script fragment will be executed as
     * the body of an anonymous function. If the script is provided as a function
     * object, that function will be converted to a string for injection into the
     * target window.
     *
     * Any arguments provided in addition to the script will be included as script
     * arguments and may be referenced using the {@code arguments} object.
     * Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
     * Arrays and objects may also be used as script arguments as long as each item
     * adheres to the types previously mentioned.
     *
     * Unlike executing synchronous JavaScript with {@link #executeScript},
     * scripts executed with this function must explicitly signal they are finished
     * by invoking the provided callback. This callback will always be injected
     * into the executed function as the last argument, and thus may be referenced
     * with {@code arguments[arguments.length - 1]}. The following steps will be
     * taken for resolving this functions return value against the first argument
     * to the script's callback function:
     *
     * - For a HTML element, the value will resolve to a
     *     {@link webdriver.WebElement}
     * - Null and undefined return values will resolve to null
     * - Booleans, numbers, and strings will resolve as is
     * - Functions will resolve to their string representation
     * - For arrays and objects, each member item will be converted according to
     *     the rules above
     *
     * __Example #1:__ Performing a sleep that is synchronized with the currently
     * selected window:
     *
     *     var start = new Date().getTime();
     *     driver.executeAsyncScript(
     *         'window.setTimeout(arguments[arguments.length - 1], 500);').
     *         then(function() {
     *           Log.information(
     *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
     *         });
     *
     * __Example #2:__ Synchronizing a test with an AJAX application:
     *
     *     var button = driver.findElement(By.id('compose-button'));
     *     button.click();
     *     driver.executeAsyncScript(
     *         'var callback = arguments[arguments.length - 1];' +
     *         'mailClient.getComposeWindowWidget().onload(callback);');
     *     driver.switchTo().frame('composeWidget');
     *     driver.findElement(By.id('to')).sendKeys('dog@example.com');
     *
     * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
     * this example, the inject script is specified with a function literal. When
     * using this format, the function is converted to a string for injection, so it
     * should not reference any symbols not defined in the scope of the page under
     * test.
     *
     *     driver.executeAsyncScript(function() {
     *       var callback = arguments[arguments.length - 1];
     *       var xhr = new XMLHttpRequest();
     *       xhr.open("GET", "/resource/data.json", true);
     *       xhr.onreadystatechange = function() {
     *         if (xhr.readyState == 4) {
     *           callback(xhr.responseText);
     *         }
     *       }
     *       xhr.send('');
     *     }).then(function(str) {
     *       Log.information(JSON.parse(str)['food']);
     *     });
     *
     * @param {!(string|Function)} script The script to execute.
     * @param {...*} var_args The arguments to pass to the script.
     * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to the
     *    scripts return value.
     * @template T
     */
    static async executeAsyncScript(script, ...var_args) {
        return await this.getDriver().executeAsyncScript(script, var_args);
    }
    /**
     * Schedules a command to retrieve the URL of the current page.
     *
     * @returns A promise that will be resolved with the current URL.
     */
    static async getCurrentUrl() {
        return await this.getDriver().getCurrentUrl();
    }
    /**
     * Schedule a command to take a screenshot. The driver makes a best effort to return a screenshot of the following, in order of preference:
     * <ol>
     *   <li>Entire page
     *   <li>Current window
     *   <li>Visible portion of the current frame
     *   <li>The screenshot of the entire display containing the browser
     * </ol>
     *
     * @param {string} filePrefix The prefix used for the generated screenshot file.
     * @returns A promise that will be resolved to the path of the screenshot file.
     * @tutorial tutorial-screenshot
     */
    static async takeScreenshot(filePrefix) {
        return await new Promise((resolve, reject) => {
            const dir = path.join(process.cwd(), "Screenshots");
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            if (filePrefix) {
                filePrefix = filePrefix.replace(/[|&;$%@"<>()+,: ]/g, "_");
            }
            const fileName = path.join(dir, filePrefix
                ? String.format("{0}_{1}.png", filePrefix, Date.now().toString())
                : String.format("{0}.png", Date.now().toString()));
            this.getDriver()
                .takeScreenshot()
                .then((data) => {
                return fs.writeFile(fileName, data, { encoding: "base64" }, (err) => {
                    if (!err) {
                        resolve(fileName);
                    }
                    else {
                        reject(err);
                    }
                });
            })
                .catch((err) => {
                reject(err);
            });
        });
    }
    /**
     * Accepts an alert if one is present
     *
     * @returns a promise when the alert has been accepted
     */
    static async acceptAlert() {
        return await new Promise((resolve) => {
            this.getDriver()
                .switchTo()
                .alert()
                .accept()
                .then(() => resolve(null))
                .catch(() => {
                resolve(null);
            });
        });
    }
    /**
     * Gets the text from an alert if one is present
     *
     * @returns a promise that will be resolved with the text of the alert.
     */
    static async getAlertText() {
        return this.getDriver()
            .switchTo()
            .alert()
            .getText()
            .then((text) => {
            return text;
        }, () => {
            return "";
        });
    }
    /**
     * Gets the browser logs for the specified level.
     *
     * @param {LogLevel} level The level of logs to get.
     * @returns A promise that resolves to the array of logs.
     */
    static async getBrowserLogs(level) {
        const levelString = LogLevel_1.LogLevel[level].toUpperCase();
        const values = await this.getDriver().manage().logs().get(webdriver.logging.Type.BROWSER);
        let filteredValues = values;
        if (level !== LogLevel_1.LogLevel.All) {
            filteredValues = values.filter((value) => {
                return value.level.name === levelString;
            });
        }
        return filteredValues.map((value) => {
            return value.message;
        });
    }
    /**
     * Schedules a command to close the window (tab) at the specified index.
     *
     * @param {number} index Index of the window (tab) to close.
     * @returns A promise that resolves when the window (tab) has been closed.
     */
    static async closeWindow(index) {
        const handle = await this.getDriver().getWindowHandle();
        const handles = await this.getDriver().getAllWindowHandles();
        await this.getDriver().switchTo().window(handles[index]);
        await this.getDriver().close();
        return await this.getDriver().switchTo().window(handle);
    }
    /**
     * Resizes the browser to a specified width and height
     *
     * @param {number} width New width to be set, defaults to current width
     * @param {number} height New height to be set, defaults to current height
     * @returns A promise that resolves when the window has been resized.
     */
    static async resizeWindow(width, height) {
        if (width !== undefined || height !== undefined) {
            const size = await this.getDriver().manage().window().getSize();
            return await this.getDriver()
                .manage()
                .window()
                .setSize(width || size.width, height || size.height);
        }
    }
    /**
     * Schedules a command to quit the current session. After calling quit, this
     * instance will be invalidated and may no longer be used to issue commands
     * against the browser.
     *
     * @param closeAlert When true will close any active alerts.
     * @returns A promise that will be resolved when the command has completed.
     */
    static async quit(closeAlert) {
        if (this.driver) {
            try {
                try {
                    closeAlert && (await this.acceptAlert());
                }
                catch (err) {
                    Logger_1.default.warning(`Failed to accept alerts. ${err}`);
                }
                try {
                    await this.driver.close();
                }
                catch (err) {
                    Logger_1.default.warning(`Failed to close webdriver. ${err}`);
                }
                try {
                    await this.driver.quit();
                }
                catch (err) {
                    Logger_1.default.warning(`Failed to quit webdriver. ${err}`);
                }
                try {
                    if (this.wdservice) {
                        await this.wdservice.kill();
                    }
                }
                catch (err) {
                    Logger_1.default.warning(`Failed to kill wdservice. ${err}`);
                }
            }
            finally {
                this.driver = null;
                this.wdservice = null;
            }
        }
    }
    /**
     * Creates a webDriver to control the browser window.
     * Called by Portal.ts. Usually not necessary for test implementers.
     *
     * @param context PortalContext options to create the webDriver.
     */
    static async createWebDriver(context) {
        if (this.driver) {
            throw new Error("The PortalWebDriver is initialized already! You need to call quit before calling this method again.");
        }
        this.portalContext = context;
        const caps = this.portalContext.capabilities;
        switch (caps.browserName) {
            case "chrome": {
                Logger_1.default.information("Starting the ChromeDriver process...");
                // Prevent Windows Integrated Authentication
                const authServerAllowListArg = "auth-server-allowlist=";
                caps.chromeOptions = caps.chromeOptions || { args: [] };
                if (caps.chromeOptions.args === null || caps.chromeOptions.args === undefined) {
                    caps.chromeOptions.args = [];
                }
                const chromeArgs = caps.chromeOptions.args;
                if (!chromeArgs.some((arg) => arg.startsWith(authServerAllowListArg))) {
                    chromeArgs.push(authServerAllowListArg + `""`);
                }
                const capabilities = new webdriver.Capabilities(caps);
                if (this.portalContext.browserStackUrl) {
                    this.driver = new webdriver.Builder()
                        .usingServer(this.portalContext.browserStackUrl)
                        .withCapabilities(new webdriver.Capabilities(capabilities))
                        .build();
                }
                else {
                    const loggingPrefs = new webdriver.logging.Preferences();
                    loggingPrefs.setLevel(webdriver.logging.Type.BROWSER, webdriver.logging.Level.ALL);
                    capabilities.setLoggingPrefs(loggingPrefs);
                    let driverPath = this.portalContext.chromeDriverPath;
                    if (!driverPath) {
                        driverPath = path.resolve(findup("node_modules\\chromedriver\\lib\\chromedriver\\chromedriver.exe"));
                    }
                    else {
                        driverPath = path.resolve(driverPath);
                    }
                    let builder;
                    // eslint-disable-next-line @typescript-eslint/no-require-imports
                    const chrome = require("selenium-webdriver/chrome");
                    if (!fs.existsSync(driverPath)) {
                        // Use the machine's PATH
                        builder = new chrome.ServiceBuilder();
                    }
                    else {
                        builder = new chrome.ServiceBuilder(driverPath);
                    }
                    this.wdservice = builder.build();
                    chrome.setDefaultService(this.wdservice);
                    this.driver = new webdriver.Builder()
                        .withCapabilities(new webdriver.Capabilities(capabilities))
                        .build();
                }
                const chromeDriverVersion = (await this.driver.getCapabilities())
                    .get("chrome")
                    .chromedriverVersion.split(" ")[0];
                Logger_1.default.information(`ChromeDriver version: ${chromeDriverVersion}`);
                // Set the timeout for async scripts to run to 5 seconds (does not affect sync script running)
                await this.getDriver()
                    .manage()
                    .timeouts()
                    .setScriptTimeout(PortalConfigurationManager_1.default.portalContext.timeouts.timeout);
                break;
            }
        }
        // If start-maximized is specified, don't try to set the resolution
        if (!caps?.chromeOptions?.args?.includes("start-maximized")) {
            const width = caps?.browserResolution?.width || 1280;
            const height = caps?.browserResolution?.height || 960;
            await this.resizeWindow(width, height);
        }
        return true;
    }
}
exports.PortalWebDriver = PortalWebDriver;
//# sourceMappingURL=PortalWebDriver.js.map