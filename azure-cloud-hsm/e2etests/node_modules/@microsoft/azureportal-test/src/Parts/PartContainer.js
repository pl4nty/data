"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartContainer = void 0;
const PortalElement_1 = require("../PortalElement");
const Tile_1 = require("../Parts/Tile");
const Part_1 = require("./Part");
const Lens_1 = require("../Lens");
const BrowserAutomation_1 = require("../BrowserAutomation");
const Logger_1 = require("../Logger");
const String = require("../Utils/String");
const diagnosticsLog = Logger_1.default.diagnostics.extend("ElementArrayFinder");
class PartContainer extends PortalElement_1.default {
    /**
     * Gets the tiles by providing tile size.
     *
     * @param size the tile size.
     * @returns a collection of matched tiles.
     */
    async findTilesBySize(size) {
        const allTiles = this.all(Tile_1.default);
        const filteredTiles = allTiles.filter((tile) => {
            const promise = this.checkTilehasSizeClass(tile, size);
            return promise;
        });
        return await filteredTiles.asPortalElements();
    }
    async checkTilehasSizeClass(tile, size) {
        return (await tile.part.getSizeClass()).toLocaleLowerCase() === tile.part.mapPartSizeToClassName(size);
    }
    /**
     * Gets the Part by provided title and type.
     *
     * @param {string} elementType The type of the part that is expected to open.
     * @param {string} title the title of part.
     * @returns A part if a single part is found or undefined if no part is found
     * @throws Error if more then one part is found
     */
    async findSinglePartByTitle(elementType, title) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allParts = this.all(elementType);
            const filteredElements = allParts.filter((part) => {
                const promise = satisfiesTitle(part, title);
                return promise;
            });
            const filterElementArray = await filteredElements.asPortalElements();
            if (filterElementArray.length > 1) {
                throw new Error("More than one elements found.");
            }
            return filterElementArray && filterElementArray[0];
        }, null, 
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Could not find a part of type ${elementType} with title ${title} in this blade. Does the part exist on the startboard? Are you looking for the correct part type?`);
        async function satisfiesTitle(part, title) {
            const partTitle = await part.getPartTitle();
            return partTitle.toLocaleUpperCase() === title.toLocaleUpperCase();
        }
    }
    /**
     * Finds the only lens that has the specified title.
     *
     * @param title The title of the lens to be found. Not case sensitive.
     * @returns A Lens with the specified title.
     */
    async findSingleLensByTitle(title) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allParts = await this.all(Lens_1.default).asPortalElements();
            let selectedRows;
            let lensTitle;
            for (const lens of allParts) {
                try {
                    lensTitle = await lens.title();
                    if (lensTitle.toLocaleUpperCase() === title.toLocaleUpperCase()) {
                        selectedRows = lens;
                        break;
                    }
                }
                catch (ex) {
                    const errMsg = String.format("An error occured while trying to find a single lens by title: {0}.\nContinuing...\n", ex);
                    diagnosticsLog(errMsg);
                }
            }
            return selectedRows;
        }, null, `Could not find a lens with title '${title}' in this blade.`);
    }
    async findSingleTileByTitle(title) {
        const allTiles = this.all(Tile_1.default);
        await allTiles.each(async (tile) => {
            const partTitle = await tile.part.getPartTitle();
            if (partTitle.toLocaleUpperCase() === title.toLocaleUpperCase()) {
                const tileWithSpecifiedTitle = tile;
                return tileWithSpecifiedTitle;
            }
        });
        return null;
    }
    /**
     * Waits until all blade tiles are loaded. If the tiles have not finished loading after the specified timeout is reached, an error is thrown.
     *
     * @param {number} timeout The time, in milliseconds, to wait for the tiles to load.
     * @returns A promise that resolves when all tiles are loaded.
     */
    async waitForAllTilesLoad(timeout) {
        let allTiles;
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            allTiles = this.all(Tile_1.default);
            if ((await allTiles.count()) > 0) {
                return true;
            }
        }, timeout, "No tiles found");
        await allTiles.map(async (tile) => {
            await tile.waitUntilLoaded();
        });
    }
    /**
     * Gets all the parts contained in this blade.
     */
    async getAllParts() {
        return await this.all(Part_1.default).asPortalElements();
    }
}
exports.PartContainer = PartContainer;
//# sourceMappingURL=PartContainer.js.map