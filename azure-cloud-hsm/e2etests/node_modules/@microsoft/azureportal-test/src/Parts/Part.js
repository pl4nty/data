"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BrowserAutomation_1 = require("../BrowserAutomation");
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
const String = require("../Utils/String");
const ContextMenu_1 = require("../Commands/ContextMenu");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const PortalFxResources = require("../PortalFxResources");
const TileSize_1 = require("./TileSize");
const Tile_1 = require("./Tile");
const ConfirmationAlertAction_1 = require("../ConfirmationAlertAction");
/**
 * Represents a Part.
 */
class Part extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.partCss = ".fxs-part";
        this.tileSizeClassPrefix = "fxs-tilesize-";
        this.partTitleElementClass = "fxs-part-title";
        this.partTitleTextClass = "fxs-part-titleText";
        this.titleViewModelProperty = "partTitle";
        this.assetNameViewModelProperty = "assetName";
        this.noAccessMessageClassName = "fxs-part-noaccessmessage";
        this.tileLoadingClassName = "fxs-tile-progress";
        this.uiBlockingShieldClassName = "fxs-part-blockui-shield";
        this.noDataMessage = "fxs-part-nodatamessage";
        this.progressIndicator = "fxs-tile-progress-transparent";
        this.errorClassName = "fxs-part-error";
        this.contentErrorClassName = "fxs-part-error-content";
        this.notFoundClassName = "fxs-part-notfound";
        this.notFoundMessageClassName = "fxs-part-notfoundmessage";
        this.resizeHandleClassName = "fxs-flowlayout-resizehandle";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.css(this.partCss);
    }
    /**
     * Gets the asset name element.
     */
    get assetNameElement() {
        const titleElement = this.all(By_1.default.className(this.partTitleElementClass)).first();
        if (titleElement) {
            const selector = `[data-bind*=${this.assetNameViewModelProperty}]`;
            return titleElement.element(By_1.default.css(selector));
        }
        return null;
    }
    /**
     * Gets the asset name.
     */
    async getAssetName() {
        return this.assetNameElement === null ? "" : await this.assetNameElement.getText();
    }
    /**
     * Builds a Part locator using the specified options.
     *
     * @param options The options used to build the locator.
     * @returns A Locator instance.
     */
    buildLocator(options) {
        return options.innerText
            ? By_1.default.content(this.locator, By_1.default.xpath(`${By_1.default.currentNodeXPathPrefix()}*[contains(text(),'${options.innerText}')]`))
            : this.locator;
    }
    /**
     * Get a value that indicates whether the part is selected.
     *
     * @returns A promise that resolves with a value that indicates whether the part is selected.
     */
    async isSelected() {
        const value = await this.getAttribute("class");
        return value.includes("fxs-part-selected");
    }
    /**
     * Get a value that indicates whether the part is loaded.
     *
     * @returns A promise that resolves with a value that indicates whether the part is loaded.
     */
    async isLoaded() {
        const loading = await this.isLoading();
        return !loading;
    }
    /**
     * Get a value that indicates whether the part can be clicked.
     *
     * @returns A promise that resolves with a value that indicates whether the part can be clicked.
     */
    async isClickable() {
        const value = await this.getAttribute("class");
        return value.includes("fxs-part-clickable");
    }
    /**
     * Get a value that indicates whether the part is in an error state.
     *
     * @returns A promise that resolves with a value that indicates whether the part is in an error state.
     */
    async hasError() {
        const value = await this.getAttribute("class");
        return value.includes("fxs-part-error");
    }
    /**
     * Clicks the part.
     *
     * @returns A promise that resolves when the part has been clicked.
     */
    async click() {
        await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.isClickable();
        }, null, "Part was not clickable within the allotted timeout.");
        return await super.click();
    }
    /**
     * Waits until the part has been loaded. Throws an error if the part is not loaded when it reaches the timeout.
     *
     * @param {number} timeout Time, in milliseconds, to wait for the part to load.
     * @returns A promise that resolves to this Part instance when the part has been loaded.
     */
    async waitUntilLoaded(timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.isLoaded();
        }, timeout, String.format("Part did not finish loading after {0} ms.", timeout));
        return this;
    }
    /**
     * Gets the title of part.
     *
     * @returns  returns part Title or Returns null if the part has not defined a title..
     */
    async getPartTitle() {
        const partTitleElement = this.element(By_1.default.className(this.partTitleElementClass));
        const partTitleText = partTitleElement.tryFindElement(By_1.default.className(this.partTitleTextClass));
        return await partTitleText?.getText();
    }
    /**
     * @deprecated partTitle instance method is deprecated. Instead, use getPartTitle instance method.
     */
    async partTitle() {
        const titleElement = this.element(By_1.default.className(this.partTitleElementClass));
        if (titleElement) {
            const selector = By_1.default.dataBindContains(this.titleViewModelProperty);
            return await titleElement.element(selector).getText();
        }
        return null;
    }
    /**
     * Pin the part, if the Pin command is available.
     *
     * @returns A promise that resolves when Pin command has been clicked.
     */
    async pin() {
        const contextMenu = new ElementArrayFinder_1.default().all(ContextMenu_1.default).toPortalElement();
        console.log("Trying to pin tile...");
        await this.rightClick();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return await contextMenu.isActive();
        }, null, `ContextMenu part is inactive`);
        await contextMenu.clickItem(PortalFxResources.pinToDashboard);
        console.log("pinned");
    }
    /**
     * Pins the part from the StartBoard.
     */
    async pinToStartboard() {
        await ContextMenu_1.default.openContextMenuAndClickCommand(this, PortalFxResources.pinToDashboard);
    }
    /**
     * Unpins the part from the StartBoard.
     */
    async unpinFromStartboard(action = ConfirmationAlertAction_1.ConfirmationAlertAction.None) {
        await ContextMenu_1.default.openContextMenuAndClickCommand(this, PortalFxResources.removeFromDashboard, null, action);
    }
    /**
     * Opens the child blade for the part in a new tab.
     */
    async openInNewTab() {
        const Key = (0, BrowserAutomation_1.getBrowser)().Key;
        await this.sendKeys(Key.CONTROL, Key.ENTER);
    }
    /**
     * Resizes the part.
     *
     * @returns void
     */
    async resize(size) {
        const commandName = this.mapPartSizeToCommandName(size);
        await ContextMenu_1.default.openContextMenuAndClickCommand(this, commandName, { x: 1, y: 1 });
        if ((await this.getSizeClass()).toLocaleLowerCase() !== this.mapPartSizeToClassName(size)) {
            throw new Error("Tile did not resize to the expected size.");
        }
    }
    /**
     * Resizes the tile using resize handle, only if the part supports user resize mode.
     *
     * @param xOffset x offset to resize.
     * @param yOffset y offset to resize.
     */
    async resizeCustom(xOffset, yOffset) {
        const ancestorTile = await this.getAncestorTile();
        const resizeHandle = ancestorTile.element(By_1.default.className(this.resizeHandleClassName));
        if (!resizeHandle) {
            throw new Error("The resize handle is not found or the part does not support user resizing.");
        }
        const source = await resizeHandle.getWebElements();
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => {
            await wd.driver
                .actions()
                .mouseMove(source[0].element)
                .mouseDown()
                .mouseMove({ x: xOffset, y: yOffset })
                .mouseUp()
                .perform();
        }, async (pw) => {
            const { x, y } = await source[0].getLocation();
            await pw.mouse.move(x, y);
            await pw.mouse.down();
            await pw.mouse.move(x + xOffset, y + yOffset);
            await pw.mouse.up();
        });
    }
    /**
     * Get the size of the part (example: normal, hero-wide, etc)
     *
     * @returns  A promise that resolves with size class of tile.
     */
    async getSizeClass() {
        const ancestorTile = await this.getAncestorTile();
        const sizeClasses = await ancestorTile.getAttribute("class");
        const sizeClass = sizeClasses
            .trim()
            .split(" ")
            .find((className) => className.startsWith(this.tileSizeClassPrefix));
        if (!sizeClass) {
            throw new Error("Unable to find size class with prefix '" +
                this.tileSizeClassPrefix +
                "' for part.  Classes found: " +
                sizeClasses);
        }
        return sizeClass;
    }
    /**
     * Executes the context menu command.
     *
     * @param commandText The command text.
     */
    async executeContextMenuCommand(commandText, action = ConfirmationAlertAction_1.ConfirmationAlertAction.None) {
        await ContextMenu_1.default.openContextMenuAndClickCommand(this, commandText, null, action);
    }
    /**
     * Gets the ancestor Tile of current part.
     */
    async getAncestorTile() {
        const element = await this.getAncestor(async (element) => (await element.hasClass("fxs-tile")) === true);
        return element.asType(Tile_1.default);
    }
    /**
     * Returns the command name corresponding to the specified part size.
     *
     * @param size :The part size
     * @returns The command name.
     */
    mapPartSizeToCommandName(size) {
        let sizeText = null;
        switch (size) {
            case TileSize_1.TileSize.Mini:
                sizeText = PortalFxResources.ShellCommands.partSizeMini;
                break;
            case TileSize_1.TileSize.Small:
                sizeText = PortalFxResources.ShellCommands.partSizeSmall;
                break;
            case TileSize_1.TileSize.Normal:
                sizeText = PortalFxResources.ShellCommands.partSizeNormal;
                break;
            case TileSize_1.TileSize.Wide:
                sizeText = PortalFxResources.ShellCommands.partSizeWide;
                break;
            case TileSize_1.TileSize.Tall:
                sizeText = PortalFxResources.ShellCommands.partSizeTall;
                break;
            case TileSize_1.TileSize.HeroWide:
                sizeText = PortalFxResources.ShellCommands.partSizeHeroWide;
                break;
            case TileSize_1.TileSize.HeroTall:
                sizeText = PortalFxResources.ShellCommands.partSizeHeroTall;
                break;
            case TileSize_1.TileSize.Hero:
                sizeText = PortalFxResources.ShellCommands.partSizeHero;
                break;
            case TileSize_1.TileSize.Large:
                sizeText = PortalFxResources.ShellCommands.partSizeLarge;
                break;
        }
        return sizeText;
    }
    /**
     *  Returns the class name corresponding to the specified part.
     *
     * @returns The command name.
     */
    mapPartSizeToClassName(size) {
        return this.tileSizeClassPrefix.toLocaleLowerCase() + TileSize_1.TileSize[size].toLocaleLowerCase();
    }
    /**
     *  Returns the part size corresponding to the specified part.
     *
     * @returns The part size.
     */
    async getPartSize() {
        const tileSizeClass = (await this.getSizeClass()).toLocaleLowerCase().replace("fxs-tilesize-", "");
        return await parseEnum(tileSizeClass);
        async function parseEnum(value) {
            if (!value) {
                return undefined;
            }
            for (const property in TileSize_1.TileSize) {
                const enumMember = TileSize_1.TileSize[property];
                if (typeof enumMember === "string") {
                    if (enumMember.toUpperCase() === value.toUpperCase()) {
                        const key = enumMember;
                        return TileSize_1.TileSize[key];
                    }
                }
            }
            return undefined;
        }
    }
    /**
     * Clicks this element with the CONTROL key pressed down.
     */
    async clickWithCtrlKey() {
        await this.scrollIntoView();
        const ctrlKey = (0, BrowserAutomation_1.getBrowser)().Key.CONTROL;
        await (0, BrowserAutomation_1.runAutomation)(async (wd) => {
            await wd.driver
                .actions()
                .keyDown(ctrlKey)
                .click(this.webElement.element)
                .keyUp(ctrlKey)
                .perform();
        }, async (pw) => {
            await pw.keyboard.down(ctrlKey);
            await this.webElement.element.click();
            await pw.keyboard.up(ctrlKey);
        });
    }
    /**
     * Gets a value indicating whether the part is in an error state or not.
     *
     * @returns  true if part is in an error state otherwise false.
     */
    async isUnauthorized() {
        const element = this.element(By_1.default.className(this.noAccessMessageClassName));
        return await element.isPresent();
    }
    /**
     * Gets the part's size.
     *
     * @returns enum object fo TileSize.
     */
    async partSize() {
        const stringSize = (await this.getSizeClass()).replace(this.tileSizeClassPrefix, "");
        let val = null;
        for (const key in TileSize_1.TileSize) {
            const isValueProperty = parseInt(key, 10) >= 0;
            if (isValueProperty) {
                if (TileSize_1.TileSize[key].toLowerCase() === stringSize) {
                    val = TileSize_1.TileSize[key];
                }
            }
        }
        const enumValue = TileSize_1.TileSize[val];
        return enumValue;
    }
    /**
     * Gets a value indicating whether <see cref="Part"/> is still loading or not.
     *
     * @returns true if <see cref="Part"/> is still loading otherwise, false.
     */
    async isLoading() {
        return ((await this.all(By_1.default.className(this.tileLoadingClassName)).some((c) => c.isDisplayed())) ||
            ((await this.all(By_1.default.className(this.uiBlockingShieldClassName)).some((e) => e.isDisplayed())) &&
                !(await this.all(By_1.default.className(this.noDataMessage)).some((e) => e.isDisplayed())) &&
                !(await this.all(By_1.default.className(this.noAccessMessageClassName)).some((e) => e.isDisplayed()))) ||
            (await this.all(By_1.default.className(this.progressIndicator)).some((c) => c.isDisplayed())));
    }
    /**
     * Gets a value indicating whether the part is in an error state or not.
     *
     * @returns a promise that resolves with true if Part is in an error state otherwise false.
     */
    async isErrorState() {
        return ((await this.all(By_1.default.className(this.errorClassName)).count()) > 0 ||
            (await this.all(By_1.default.className(this.contentErrorClassName)).count()) > 0);
    }
    /**
     * Gets a value indicating whether the asset is not found.
     */
    async isAssetNotFound() {
        return ((await this.all(By_1.default.className(this.notFoundClassName)).some((c) => c.isDisplayed())) &&
            (await this.all(By_1.default.className(this.notFoundMessageClassName)).some((e) => e.isDisplayed())));
    }
}
exports.default = Part;
//# sourceMappingURL=Part.js.map