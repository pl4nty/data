"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webdriver = require("selenium-webdriver");
var WebdriverBy = webdriver.By;
const SimpleLocator_1 = require("./SimpleLocator");
const ChainedLocator_1 = require("./ChainedLocator");
const ContentLocator_1 = require("./ContentLocator");
const BrowserAutomation_1 = require("../BrowserAutomation");
const BrowserAutomationType_1 = require("../BrowserAutomationType");
/**
 * Represents a collection of functions that can create locators based on different criteria.
 */
class By {
    /**
     * Locates elements that have a specific class name. The returned locator
     * is equivalent to searching for elements with the CSS selector ".class".
     *
     * @param {string} value The class name to search for.
     * @returns The new locator.
     */
    static className(value) {
        return new SimpleLocator_1.default(WebdriverBy.className(value || ""));
    }
    /**
     * Locates elements using a CSS selector. For browsers that do not support
     * CSS selectors, WebDriver implementations may return an
     * {@linkplain bot.Error.State.INVALID_SELECTOR invalid selector} error. An
     * implementation may, however, emulate the CSS selector API.
     *
     * @param {string} value The CSS selector to use.
     * @returns The new locator.
     */
    static css(value) {
        return new SimpleLocator_1.default(WebdriverBy.css(value));
    }
    /**
     * Locates elements using knockout data-bind attribute. For browsers that do not support
     * CSS selectors, WebDriver implementations may return an
     * {@linkplain bot.Error.State.INVALID_SELECTOR invalid selector} error. An
     * implementation may, however, emulate the CSS selector API.
     *
     * @param {string} value The partial data-bind attribute value to use.
     * @returns The new locator.
     */
    static dataBindContains(value) {
        return new SimpleLocator_1.default(WebdriverBy.css(`[data-bind*='${value}']`));
    }
    /**
     * Locates an element by its ID.
     *
     * @param {string} value The ID to search for.
     * @returns The new locator.
     */
    static id(value) {
        return new SimpleLocator_1.default(WebdriverBy.id(value));
    }
    /**
     * Locates an elements by evaluating a
     * {@linkplain webdriver.WebDriver#executeScript JavaScript expression}.
     * The result of this expression must be an element or list of elements.
     *
     * @param {any} script The script to execute.
     * @param {any[]} ...var_args The arguments to pass to the script.
     * @returns A new, JavaScript-based locator function.
     */
    static js(script, ...var_args) {
        return new SimpleLocator_1.default(WebdriverBy.js(script, var_args));
    }
    /**
     * Locates link elements whose {@linkplain webdriver.WebElement#getText visible
     * text} matches the given string.
     *
     * @param {string} value The link text to search for.
     * @returns The new locator.
     */
    static linkText(value) {
        if ((0, BrowserAutomation_1.getBrowser)().library === BrowserAutomationType_1.BrowserAutomationType.Playwright) {
            return By.xpath(`${By.currentNodeXPathPrefix()}a[text()='${value}']`);
        }
        return new SimpleLocator_1.default(WebdriverBy.linkText(value));
    }
    /**
     * Locates elements whose {@code nameAttribute} attribute has the given value.
     *
     * @param {string} value The name attribute to search for.
     * @returns The new locator.
     */
    static nameAttribute(value) {
        return new SimpleLocator_1.default(WebdriverBy.name(value));
    }
    /**
     * Locates link elements whose {@linkplain webdriver.WebElement#getText visible
     * text} contains the given substring.
     *
     * @param {string} value The substring to check for in a link's visible text.
     * @returns The new locator.
     */
    static partialLinkText(value) {
        return new SimpleLocator_1.default(WebdriverBy.partialLinkText(value));
    }
    /**
     * Locates elements with a given tag name. The returned locator is
     * equivalent to using the
     * [getElementsByTagName](https://developer.mozilla.org/en-US/docs/Web/API/Element.getElementsByTagName)
     * DOM function.
     *
     * @param {string} value The substring to check for in a link's visible text.
     * @returns The new locator.
     */
    static tagName(value) {
        // eslint-disable-next-line deprecation/deprecation
        return new SimpleLocator_1.default(WebdriverBy.tagName(value));
    }
    /**
     * Locates elements matching a XPath selector. Care should be taken when
     * using an XPath selector with a {@link webdriver.WebElement} as WebDriver
     * will respect the context in the specified in the selector. For example,
     * given the selector {@code "//div"}, WebDriver will search from the
     * document root regardless of whether the locator was used with a
     * WebElement.
     *
     * @param {string} value The XPath selector to use.
     * @returns The new locator.
     */
    static xpath(value) {
        return new SimpleLocator_1.default(WebdriverBy.xpath(value));
    }
    /**
     * Locates elements with the given text.
     *
     * @param {string} value The text to check for.
     * @returns The new locator.
     */
    static text(value) {
        return By.xpath(`${By.currentNodeXPathPrefix()}*[translate(.,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')="${value.toUpperCase()}"]`);
    }
    /**
     * Locates elements that contain the given text.
     *
     * @param {string} value The text to check for.
     * @returns The new locator.
     */
    static textContains(value) {
        return By.xpath(`${By.currentNodeXPathPrefix()}*[text()[contains(translate(.,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'), "${value.toUpperCase()}")]]`);
    }
    /**
     * Locates elements that match the given class name starts with the given text.
     *
     * @param {string} classNamePrefix The class name prefix to search for.
     * @returns The new locator.
     */
    static classStartsWith(classNamePrefix) {
        return By.xpath(`${By.currentNodeXPathPrefix()}*[starts-with(@class, '${classNamePrefix}')]`);
    }
    /**
     * Locates elements that match the given class name and text.
     *
     * @param {string} className The class name to search for.
     * @param {string} text The text to check for.
     * @returns The new locator.
     */
    static classAndText(className, text) {
        const escapedText = text.includes("'") ? `"${text.toUpperCase()}"` : `'${text.toUpperCase()}'`;
        return By.xpath(`${By.currentNodeXPathPrefix()}*[contains(@class, '${className}') and translate(.,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')=${escapedText}]`);
    }
    /**
     * Locates elements that match the given class name and has a descendent with matching text.
     *
     * @param {string} className The class name to search for.
     * @param {string} text The text to check for.
     * @returns The new locator.
     */
    static classAndDescendentText(className, text) {
        const escapedText = text.includes("'") ? `"${text.toUpperCase()}"` : `'${text.toUpperCase()}'`;
        return By.xpath(`${By.currentNodeXPathPrefix()}*[translate(.,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')=${escapedText}]/ancestor::*[contains(@class, '${className}')]`);
    }
    /**
     * Locates elements that match the given class name and the text starts with a prefix.
     *
     * @param {string} className The class name to search for.
     * @param {string} text The text to check for.
     * @returns The new locator.
     */
    static classAndTextStartsWith(className, text) {
        return By.xpath(`${By.currentNodeXPathPrefix()}*[contains(@class, '${className}') and starts-with(translate(.,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ'), "${text.toUpperCase()}")]`);
    }
    /**
     * Locates elements that match all the specified locators. The returned locator will find the element(s) that match the last of the provided locators.
     *
     * @param {Locator[]} ...values The locators to search for.
     * @returns The new locator.
     */
    static chained(...values) {
        return new ChainedLocator_1.default(values);
    }
    /**
     * Locates elements that match all the specified locators. The returned locator will find the element(s) that match the first of the provided locators.
     *
     * @param {Locator[]} ...values The locators to search for.
     * @returns The new locator.
     */
    static content(...values) {
        return new ContentLocator_1.default(values);
    }
    /**
     * The xPath prefix for current element, based on current IBrowserAutomation
     */
    static currentNodeXPathPrefix() {
        return `${(0, BrowserAutomation_1.getBrowser)().library === BrowserAutomationType_1.BrowserAutomationType.Playwright ? "" : "."}//`;
    }
    static tagNameAndNameAttribute(tagName, nameAttribute) {
        return By.xpath(`${By.currentNodeXPathPrefix()}${tagName}[@name='${nameAttribute}']`);
    }
    static tagNameAndNameAttributePattern(tagName, nameAttribute) {
        return By.xpath(`${By.currentNodeXPathPrefix()}${tagName}[matches(@name, '${nameAttribute}')]`);
    }
}
exports.default = By;
//# sourceMappingURL=By.js.map