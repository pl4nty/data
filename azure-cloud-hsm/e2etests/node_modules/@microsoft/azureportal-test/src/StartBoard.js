"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const By_1 = require("./Locators/By");
const PortalElement_1 = require("./PortalElement");
const Tile_1 = require("./Parts/Tile");
const ContextMenu_1 = require("./Commands/ContextMenu");
const BrowserAutomation_1 = require("./BrowserAutomation");
const Parts_1 = require("./Parts");
const PortalShell_1 = require("./PortalShell");
const TopBar_1 = require("./TopBar/TopBar");
const PortalFxResources = require("./PortalFxResources");
const DashboardHeader_1 = require("./Dashboard/DashboardHeader");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const DashboardFilters_1 = require("./Dashboard/DashboardFilters");
const ExpectedConditions = require("./ExpectedConditions");
const Logger_1 = require("./Logger");
const Portal_1 = require("./Portal");
/**
 * Represents the Portal StartBoard.
 */
class StartBoard extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.webContainerClassName = "fxs-portal";
        this.showJourneyClassName = "fxs-show-journey";
        this.startButtonClassName = "fxs-topbar-home";
        this.layoutClassName = "fxs-startboard-layout";
        this.messageContainerClassName = "fxs-startboard-message-container";
        this.messageTitleClassName = "fxs-startboard-message-title";
        /**
         * Represents the array of tiles currently pinned to the StartBoard.
         */
        this.tiles = this.all(Tile_1.default);
        /**
         * Gets the "Add tiles" button.
         */
        this.addTilesButton = this.element(By_1.default.className("fxs-startboard-addTiles"));
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className("fxs-startboard");
    }
    /**
     * Gets all the parts contained in this blade.
     */
    async getParts() {
        return (await this.all(Parts_1.Part)).concat(await this.all(Parts_1.ButtonPart));
    }
    /**
     * Gets the Tile for provided title.
     *
     * @param title title of the tile.
     * @returns A Tile.
     */
    async getTileByText(title) {
        // ensure all tiles are loaded
        await this.waitForAllTilesLoaded();
        const allTiles = this.all(Tile_1.default);
        let filteredTiles = null;
        await allTiles.each(async (tile) => {
            const partTitle = await tile.part.getPartTitle();
            if (partTitle.toLocaleUpperCase() === title.toLocaleUpperCase()) {
                filteredTiles = tile;
            }
        });
        return filteredTiles;
    }
    /**
     * Finds the only tile that is of the specified type and has the specified title.
     *
     * @param {T} elementType The part type required.
     * @param {string} title The title.
     * @param {function} predicate The predicate callback to test the tile.
     * @param {string} additionalErrorMessage Extra error message string to append to the error for WaitUntil.
     * @param {boolean} showDashboard Show the StartBoard first if hidden
     * @param {number} timeout The optional timeout (uses default timeout if not specified).
     * @returns A Tile with the specified type and title.
     */
    async findSingleTileByTitleAndPredicate(elementType, title, predicate, additionalErrorMessage = "", showDashboard = true, timeout = PortalConfigurationManager_1.default.portalContext.timeouts.timeout) {
        const singleTile = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (showDashboard) {
                await Portal_1.portal.getTopBar().showStartBoard();
            }
            const allTiles = this.all(elementType);
            const filteredElements = allTiles.filter((tile) => {
                const promise = checkTileHasTitleAndSatisfiesPredicate(tile, title, predicate);
                return promise;
            });
            const filteredElementsAsPortalElements = await filteredElements.asPortalElements();
            if (filteredElementsAsPortalElements.length === 1) {
                return filteredElementsAsPortalElements[0];
            }
            if (filteredElementsAsPortalElements.length === 0) {
                return null;
            }
            if (filteredElementsAsPortalElements.length > 1) {
                throw new Error("More than one elements found.");
            }
        }, timeout, `Could not find Tile with title '${title}' '${additionalErrorMessage}' in the StartBoard.`);
        return singleTile;
        async function checkTileHasTitleAndSatisfiesPredicate(tile, title, predicate) {
            return (await tile.getPartTitle()) === title && predicate(tile);
        }
    }
    /**
     * Enters the organize mode.
     *
     * @returns a promise when the portal enters in OrganizeMode.
     */
    async enterOrganizeMode() {
        // make sure starboard is being displayed
        if (!(await this.isDisplayed())) {
            throw new Error("Cannot enter organize mode in a journey, as startboard isnt displayed");
        }
        const editButton = this.element(By_1.default.css(".fxs-startboard-button-edit"));
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await editButton.isDisplayed(), null, "Edit button is not displayed");
        await editButton.click();
        // wait for the portal to enter organize mode
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await PortalShell_1.default.getPortalShell().isInOrganizeMode(), null, "Portal did not enter organize mode", "Waiting for Portal to enter organize mode");
    }
    /**
     * Waits until all tiles on startboard are loaded. If the tiles have not finished loading after the specified timeout is reached, an error is thrown.
     *
     * @param {number} timeout The time, in milliseconds, to wait for the tiles to load.
     * @returns A promise that resolves when all tiles are loaded.
     */
    async waitForAllTilesLoaded(timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const allTiles = this.all(Tile_1.default);
            const tilesCount = await allTiles.count();
            return tilesCount > 0;
        }, timeout);
        const allTiles = await this.all(Tile_1.default);
        await allTiles.reduce(async (last, tile) => {
            await last;
            await tile.waitUntilLoaded(timeout);
        }, Promise.resolve());
    }
    /**
     * Enters organize mode and resets the dashboard and exits organize mode
     *
     * @returns A promise that resolves when reset is complete
     */
    async reset() {
        await this.enterOrganizeMode();
        const header = this.element(By_1.default.className("fxs-startboard-header"));
        await header.rightClick();
        const portalElement = PortalShell_1.default.getPortalShell();
        const contextMenu = portalElement.element(ContextMenu_1.default);
        const useResetToDefaultState = await contextMenu.hasItem(PortalFxResources.dashboard.resetToDefaultState);
        await contextMenu.clickItem(useResetToDefaultState
            ? PortalFxResources.dashboard.resetToDefaultState
            : PortalFxResources.dashboard.restoreDefaultLayout);
        const messageBox = portalElement.element(By_1.default.className("fxs-messagebox"));
        await messageBox.element(By_1.default.css(".fxs-button-primary, .fxs-portal-button-primary")).click();
        await this.exitOrganizeMode();
    }
    async enterOrganizeModeUsingContextMenu() {
        const header = this.element(By_1.default.className("fxs-startboard-header"));
        await header.rightClick();
        const portalElement = PortalShell_1.default.getPortalShell();
        const contextMenu = portalElement.element(ContextMenu_1.default);
        await contextMenu.clickItem(PortalFxResources.dashboard.edit);
        // wait for the portal to enter organize mode
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await PortalShell_1.default.getPortalShell().isInOrganizeMode(), null, "Portal did not enter organize mode", "Waiting for Portal to enter organize mode");
    }
    /**
     * Exits organize mode
     *
     * @param {boolean} skipSave If true, skips saving the dashboard.
     * @returns A promise that resolves when organize mode exits
     */
    async exitOrganizeMode(skipSave = false) {
        const topBar = PortalShell_1.default.getPortalShell().element(TopBar_1.default);
        const [saveButton, discardButton, exitButton] = await Promise.all([
            topBar.saveDashboardButton(),
            topBar.discardDashboardButton(),
            topBar.exitOrganizeModeButton(),
        ]);
        const areButtonsDisplayed = async () => {
            const isDisplayedCallbacks = () => [saveButton, discardButton, exitButton].map((button) => button.isDisplayed().catch(() => false));
            return await Promise.all(isDisplayedCallbacks());
        };
        const clickButton = async (button) => await button.click({ remainingAttempts: 3, delay: 500, scriptClick: true }, async () => { });
        const areDisplayed = await areButtonsDisplayed();
        if (!areDisplayed.some((isDisplayed) => isDisplayed)) {
            return;
        }
        const [isSaveDisplayed, isDiscardDisplayed, isExitDisplayed] = areDisplayed;
        Logger_1.default.information(`Save displayed: ${isSaveDisplayed}, discard displayed: ${isDiscardDisplayed}, exit displayed: ${isExitDisplayed}`);
        if (isSaveDisplayed && !skipSave) {
            Logger_1.default.information("Clicking save to exit dashboard organize mode");
            await clickButton(saveButton);
        }
        else if (isDiscardDisplayed) {
            Logger_1.default.information("Clicking discard to exit dashboard organize mode");
            await clickButton(discardButton);
        }
        else if (isExitDisplayed) {
            Logger_1.default.information("Clicking done cutsomizing to exit dashboard organize mode");
            await clickButton(exitButton);
        }
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            return (await areButtonsDisplayed()).every((isDisplayed) => !isDisplayed);
        }, PortalConfigurationManager_1.default.portalContext.timeouts.timeout, "Organize mode did not exit", "Checking whether organize mode exited");
        await (0, BrowserAutomation_1.getBrowser)().sendKeys((0, BrowserAutomation_1.getBrowser)().Key.TAB);
    }
    /**
     * Saves the dashboard.
     *
     * @returns A promise that resolves when the dashboard is saved
     */
    async saveDashboard() {
        const topBar = Portal_1.portal.getTopBar();
        const saveButton = await topBar.saveDashboardButton();
        if (await saveButton.isDisplayed()) {
            await topBar.saveDashboard();
            // The caller could refresh the browser as soon as it exits this method, placing a racing condition on saving settings.
            // Let's give it some time so settings can be saved.
            await (0, PortalElement_1.delay)(2000);
        }
    }
    /**
     * Finds the only part that is of the specified type and has the specified title.
     *
     * @param {T} elementType The type of the part that is expected to open.
     * @param {string} title The title of part.
     * @param {boolean} show Show the StartBoard first if hidden.
     * @param {number} timeout The optional timeout (uses default timeout if not specified).
     * @returns a part if a single part is found or undefined if no part is found.
     * @throws error if more then one part is found.
     */
    async findSinglePartByTitle(elementType, title, show, timeout = PortalConfigurationManager_1.default.portalContext.timeouts.timeout) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (show) {
                const startBoard = await Portal_1.portal.getTopBar().showStartBoard();
                await startBoard.waitForAllTilesLoaded();
            }
            const allParts = this.all(elementType);
            const filteredElements = allParts.filter((part) => {
                const promise = satisfiesTitle(part, title);
                return promise;
            });
            const filterElementArray = await filteredElements.asPortalElements();
            if (filterElementArray.length > 1) {
                throw new Error("More than one element found.");
            }
            if (filterElementArray.length === 1) {
                return filterElementArray[0];
            }
            if (filterElementArray.length === 0) {
                throw new Error(`Part with title ${title} not found`);
            }
        }, timeout, 
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Could not find a part of type ${elementType} with title ${title} in this blade. Does the part exist on the startboard? Are you looking for the correct part type?`);
        async function satisfiesTitle(part, title) {
            return (await part.getPartTitle()).toUpperCase() === title.toUpperCase();
        }
    }
    /**
     * Finds the only tile that is of the specified type and has the specified title.
     *
     * @param {T} elementType The part type required.
     * @param {string} title The title.
     * @param {function} predicate The predicate callback to test the tile.
     * @param {string} additionalErrorMessage Extra error message string to append to the error for WaitUntil.
     * @param {boolean} showDashboard Show the StartBoard first if hidden
     * @param {number} timeout The optional timeout (uses default timeout if not specified).
     * @returns A Tile with the specified type and title.
     */
    async findSinglePartByTitleAndPredicate(elementType, title, predicate, additionalErrorMessage = "", showDashboard = true, timeout = PortalConfigurationManager_1.default.portalContext.timeouts.timeout) {
        const singleTile = await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (showDashboard) {
                const startBoard = await Portal_1.portal.getTopBar().showStartBoard();
                await startBoard.waitForAllTilesLoaded();
            }
            const allParts = this.all(elementType);
            const filteredElements = allParts.filter((part) => {
                const promise = checkPartHasTitleAndSatisfiesPredicate(part, title, predicate);
                return promise;
            });
            const filteredElementsAsPortalElements = await filteredElements.asPortalElements();
            if (filteredElementsAsPortalElements.length === 1) {
                return filteredElementsAsPortalElements[0];
            }
            if (filteredElementsAsPortalElements.length === 0) {
                return null;
            }
            if (filteredElementsAsPortalElements.length > 1) {
                throw new Error("More than one element found.");
            }
        }, timeout, `Could not find Part with title '${title}' '${additionalErrorMessage}' in the StartBoard.`);
        return singleTile;
        async function checkPartHasTitleAndSatisfiesPredicate(part, title, predicate) {
            return (await part.getPartTitle()) === title && predicate(part);
        }
    }
    /**
     * Gets the DashboardHeader.
     *
     * @param {number} timeout The optional timeout (uses default timeout if not specified).
     */
    async getDashboardHeader(timeout = PortalConfigurationManager_1.default.portalContext.timeouts.timeout) {
        const dashboardHeader = this.element(DashboardHeader_1.default);
        await (0, BrowserAutomation_1.getBrowser)().wait(ExpectedConditions.isPresent(dashboardHeader), timeout, "DashboardHeader not found.");
        await dashboardHeader.waitUntilReady();
        return dashboardHeader;
    }
    /**
     * Finds the only part that is of the specified type and has the specified AssetName.
     *
     * @param {T} elementType The type of the part that is expected to open.
     * @param {string} assetName the assetName.
     * @param {boolean} show Show the StartBoard first if hidden.
     * @returns a part if a single part is found or undefined if no part is found.
     * @throws error if more than one part is found.
     */
    async findSinglePartByAssetName(elementType, assetName, show) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (show) {
                await Portal_1.portal.openDashboard();
                const startBoard = await Portal_1.portal.getDashboard();
                await startBoard.waitForAllTilesLoaded();
            }
            const allParts = this.all(elementType);
            const filteredElements = allParts.filter((part) => {
                const promise = satisfiesTitle(part, assetName);
                return promise;
            });
            const filterElementArray = await filteredElements.asPortalElements();
            if (filterElementArray.length > 1) {
                throw new Error("More than one elements found.");
            }
            return filterElementArray && filterElementArray[0];
        }, null, `Could not find a part with asset name '${assetName}' in the StartBoard.`);
        async function satisfiesTitle(part, assetName) {
            const partAssetName = await part.getAssetName();
            return partAssetName.toLocaleUpperCase() === assetName.toLocaleUpperCase();
        }
    }
    /**
     * Check if the StartBoard is visible.
     *
     * @returns Promise which resolves visibility of StartBoard.
     */
    async isVisible() {
        const portalElement = PortalShell_1.default.getPortalShell();
        return !(await portalElement
            .element(By_1.default.className(this.webContainerClassName))
            .hasClass(this.showJourneyClassName));
    }
    /**
     * Show the StartBoard.
     *
     * @returns Promise which resolves when StartBoard is visible.
     */
    async show() {
        if (await this.isVisible()) {
            return;
        }
        await this.clickStartButton();
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => this.isVisible(), null, "The startboard should be visible.");
    }
    /**
     * Get all parts from StartBoard.
     *
     * @returns Promise which resolves parts from StartBoard.
     */
    async parts() {
        return (await this.all(Parts_1.Part)).concat(await this.all(Parts_1.ButtonPart));
    }
    async clickStartButton() {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const portalElement = PortalShell_1.default.getPortalShell();
            const button = portalElement.element(By_1.default.className(this.startButtonClassName));
            await button.click();
            return true;
        }, null, "Could not find the start button.");
    }
    /**
     * Unpin all parts from dashboard.
     *
     * @param exceptions Array of parts (by text) to leave pinned to the dashboard.
     */
    async unpinAllParts(exceptions) {
        // in back compat it's not stable to unpin all  Repeatly unpin all parts until the count of parts is 0.
        const startBoard = await Portal_1.portal.getDashboard();
        await startBoard.show();
        const parts = await startBoard.all(Parts_1.Part);
        for (let i = 0; i < parts.length; i++) {
            if (exceptions && exceptions.length) {
                const text = await parts[i].getText();
                if (exceptions.includes(text)) {
                    continue;
                }
            }
            await parts[i].unpinFromStartboard();
        }
        const topBar = Portal_1.portal.getTopBar();
        await topBar.saveDashboard();
        await startBoard.show();
        const currentParts = await startBoard.all(Parts_1.Part);
        let count = 0;
        for (const part of currentParts) {
            if (exceptions && exceptions.length) {
                const text = await part.getText();
                if (exceptions.includes(text)) {
                    continue;
                }
            }
            count++;
        }
        return count === 0;
    }
    /**
     * Adds part from tile gallery to startboard.
     *
     * @param galleryPartTitle Title of the part in tile gallery.
     * @param dashboardPartTitle Title of the part in dashboard.
     */
    async addGalleryPart(galleryPartTitle, dashboardPartTitle) {
        const isInOrganizeMode = await PortalShell_1.default.getPortalShell().isInOrganizeMode();
        if (!isInOrganizeMode) {
            await this.enterOrganizeMode();
        }
        const portalElement = PortalShell_1.default.getPortalShell();
        const partGallery = await (0, BrowserAutomation_1.getBrowser)().wait(() => portalElement.element(Parts_1.PartGallery2), null, "Could not find the tile gallery");
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => !(await partGallery.isLoading()), null, "The tile gallery should stop loading");
        await partGallery.searchItems(galleryPartTitle);
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => (await partGallery.getItems()).length === 1, null, "Expected 1 item in the PartGallery after searching by title.");
        const item = await partGallery.findSingleItemByTitle(galleryPartTitle);
        await Portal_1.portal.dragAndDrop(item, (await this.getLocation()).x, (await this.getLocation()).y);
        console.log("Waiting for tiles to load...");
        await this.waitForAllTilesLoaded();
        console.log("Waiting for the part to be added to the dashboard...");
        const part = await this.findSinglePartByTitle(Parts_1.Part, dashboardPartTitle);
        console.log("Waiting for the part to be loaded...");
        await part.waitUntilLoaded();
    }
    /**
     * Wait until all parts are loaded.
     *
     * @param {number} timeout Timeout to wait till all parts to be loaded.
     * @returns Promise which resolves when all parts are loaded.
     */
    async waitUntilAllPartsAreLoaded(timeout = PortalConfigurationManager_1.default.portalContext.timeouts.timeout) {
        const allParts = await this.parts();
        for (const part of allParts) {
            await (0, BrowserAutomation_1.getBrowser)().wait(async () => await part.isLoaded(), timeout, async () => {
                const partTitle = await part.getPartTitle();
                return `The Part ${partTitle} on the StartBoard took longer than ${timeout} seconds to load.`;
            });
        }
    }
    /**
     * Check if StartBoard is not found.
     *
     * @returns Promise which resolves to true if StartBoard is not found. False otherwise.
     */
    async isNotFound() {
        return (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const startboardLayout = await this.startboardLayout();
            const messageContainer = await this.messageContainer();
            const messageTitle = await (await this.messageTitle()).getText();
            return (!(await startboardLayout.isDisplayed()) &&
                (await messageContainer.isDisplayed()) &&
                messageTitle.includes(PortalFxResources.dashboard.notFoundTitle));
        }, null, "The startboard is expected to show not found UI.");
    }
    /**
     * Check if StartBoard is found.
     *
     * @returns Promise which resolves to true if StartBoard is found. False otherwise.
     */
    async isFound() {
        return (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            const startboardLayout = await this.startboardLayout();
            const messageContainer = await this.messageContainer();
            return (await startboardLayout.isDisplayed()) && !(await messageContainer.isDisplayed());
        }, null, "The startboard is expected to show found UI.");
    }
    /**
     * Gets the Dashboard Filter Collection.
     */
    async dashboardFilters() {
        return await (0, BrowserAutomation_1.getBrowser)().wait(() => {
            return this.element(DashboardFilters_1.default);
        }, null, "Unable to find the dashboard filter control");
    }
    async startboardLayout() {
        return this.element(By_1.default.className(this.layoutClassName));
    }
    async messageContainer() {
        return this.element(By_1.default.className(this.messageContainerClassName));
    }
    async messageTitle() {
        return this.element(By_1.default.className(this.messageTitleClassName));
    }
    /**
     * Finds the only part that is of the specified type and has content that starts with the specified text.
     *
     * @param elementType The part type required.
     * @param startsWith The startswith text.
     * @param show Show the StartBoard first if hidden.
     * @returns a promise that resolves with a Part with the specified type and content.
     */
    async findSinglePartWhereContentStartsWith(elementType, startsWith, show = true) {
        return await (0, BrowserAutomation_1.getBrowser)().wait(async () => {
            if (show) {
                await this.show();
            }
            const allParts = await this.all(elementType);
            const filteredElements = [];
            for (const p of allParts) {
                const partContent = p.element(By_1.default.className("fxs-part-content"));
                if ((await partContent.getText()).toLowerCase().startsWith(startsWith.toLowerCase())) {
                    filteredElements.push(p);
                }
            }
            if (filteredElements.length === 1) {
                return filteredElements[0];
            }
            if (filteredElements.length > 1) {
                throw new Error("More than one element found");
            }
        }, null, `Could not find a part with content that starts with '${startsWith}' in the StartBoard.`);
    }
}
exports.default = StartBoard;
//# sourceMappingURL=StartBoard.js.map