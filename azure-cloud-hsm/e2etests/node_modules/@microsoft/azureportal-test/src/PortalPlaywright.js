"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortalPlaywright = exports.PlaywrightElement = void 0;
const playwright_1 = require("playwright");
const fs = require("fs");
const path = require("path");
const PortalElement_1 = require("./PortalElement");
const LogLevel_1 = require("./LogLevel");
const BrowserAutomationType_1 = require("./BrowserAutomationType");
const Constants_1 = require("./Constants");
const Logger_1 = require("./Logger");
const PlaywrightKeys = require("./PlaywrightKeys");
const PlaywrightErrors_1 = require("./PlaywrightErrors");
const RunScripts_1 = require("./Utils/RunScripts");
const ContextMode_1 = require("./ContextMode");
const PortalConfigurationManager_1 = require("./PortalConfigurationManager");
const Findup_1 = require("./Utils/Findup");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const v8ToIstanbul = require("v8-to-istanbul");
const playwrightLogger = Logger_1.default.diagnostics.extend("PortalPlaywright");
class PlaywrightElement {
    constructor(element, browser) {
        this.element = element;
        this.browser = browser;
        this.getAttribute = async (name) => {
            return ((await this.element.getAttribute(name)) ??
                (await this.element.evaluate((htmlElem, name) => {
                    return htmlElem[name];
                }, name)));
        };
        this.findElement = async (locator) => {
            const locatorValue = locator.value ?? locator.locator.value;
            const elementHandle = await this.element.$(locatorValue);
            return elementHandle && new PlaywrightElement(elementHandle, this.browser);
        };
        this.findElements = async (locator) => {
            const locatorValue = locator.value ?? locator.locator.value;
            const elementHandles = await this.element.$$(locatorValue);
            const elements = [];
            for (let i = 0; i < elementHandles.length; i++) {
                elements.push(new PlaywrightElement(elementHandles[i], this.browser));
            }
            return elements;
        };
        this.click = async (button, dialogCb) => {
            dialogCb =
                dialogCb ||
                    (async (dialog) => {
                        await new Promise((resolve) => setTimeout(resolve, PortalConfigurationManager_1.default.portalContext.timeouts.timeout));
                        if (!finished) {
                            await dialog.dismiss();
                        }
                    });
            const normalClick = async () => {
                await this.element.click({
                    button: button || "left",
                    force: true,
                    timeout: PortalConfigurationManager_1.default.portalContext.timeouts.timeout,
                });
            };
            const scriptClick = async () => {
                const selector = await this.getSelectorPath();
                await (0, RunScripts_1.runScript)(`
                let el = document.querySelector('${selector}');
                if(!el || !"click" in el){
                    throw new Error("Element not found");
                }
                el.click && setTimeout(() => document.querySelector('${selector}').click(), 100);
            `, {
                    element: this.element,
                    timeout: PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout,
                });
                await new Promise((resolve) => setTimeout(resolve, 100));
            };
            this.browser.page.once("dialog", dialogCb);
            let finished = false;
            const isScriptClick = "clickScript" in dialogCb;
            try {
                isScriptClick ? await scriptClick() : await normalClick();
            }
            catch {
                isScriptClick ? await normalClick() : await scriptClick();
            }
            finally {
                finished = true;
                this.browser.page.off("dialog", dialogCb);
            }
        };
        this.getCss = async (property) => {
            return await this.element.evaluate((htmlElem, property) => {
                return window.getComputedStyle(htmlElem).getPropertyValue(property);
            }, property);
        };
        this.getSelectorPath = async () => {
            return await this.executeScript(`(htmlElem) => {
            const path = [];
            while (htmlElem.nodeType === Node.ELEMENT_NODE) {
                let selector = htmlElem.nodeName.toLowerCase();
                let sib = htmlElem;
                let nth = 1;
                while ((sib = sib.previousSibling)) {
                    if (sib.nodeName.toLowerCase() === selector) { nth++; }
                }
                if (nth !== 1) { selector += ":nth-of-type(" + nth + ")"; }
                path.unshift(selector);
                htmlElem = htmlElem.parentNode;
            }
            return path.slice(1).join(" > ");
        }`);
        };
        this.sendKeys = async (...texts) => {
            await this.element.focus();
            await this.browser.sendKeys(...texts);
        };
        this.clear = async () => {
            return await this.element.fill("", {
                timeout: PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout,
            });
        };
        this.getText = async () => {
            return await this.element.innerText();
        };
        this.getTagName = async () => {
            const tagName = await this.element.getProperty("tagName");
            return tagName.toString().toLowerCase();
        };
        this.getSize = async () => {
            const boundingBox = await this._boundingBox();
            return boundingBox ? { width: boundingBox.width, height: boundingBox.height } : null;
        };
        this.getLocation = async () => {
            const boundingBox = await this._boundingBox();
            return boundingBox ? { x: boundingBox.x, y: boundingBox.y } : null;
        };
        this.isDisplayed = async () => {
            return await this.checkState("visible");
        };
        this.moveMouseAndClick = async (opt_offset, clickType) => {
            // If any of the option fields are passed as null, Playwright throws an error. For that reason, explicitly defining position and button options as undefined when they are not defined or defined as null.
            return await this.element.click({
                position: opt_offset || undefined,
                button: clickType || "left",
                force: true,
                timeout: PortalConfigurationManager_1.default.portalContext.timeouts.timeout,
            });
        };
        this.isSelected = async () => {
            const ariaSelectedAttribute = await this.getAttribute(Constants_1.CssClassNames.attributes.ariaSelectedItemClassName);
            if (ariaSelectedAttribute.toLowerCase() === "true") {
                return true;
            }
            const ariaExpandedAttribute = await this.getAttribute(Constants_1.CssClassNames.attributes.ariaExpandedItemClassName);
            if (ariaExpandedAttribute.toLowerCase() === "true") {
                return true;
            }
            const ariaCurrentAttribute = await this.getAttribute(Constants_1.CssClassNames.attributes.ariaCurrentItemClassName);
            if (ariaCurrentAttribute.toLowerCase() === "true") {
                return true;
            }
            return false;
        };
        this.isEnabled = async () => {
            return await this.checkState("enabled", PortalConfigurationManager_1.default.portalContext.timeouts.internalWaitForElementLocatedTimeout);
        };
        this.checkState = async (state, timeout = 500) => {
            try {
                await this.element.waitForElementState(state, { timeout: timeout });
                return true;
            }
            catch {
                return false;
            }
        };
        this.getInputValue = async () => {
            return await this.element.inputValue();
        };
        this._boundingBox = async () => {
            const boundingBox = await this.element.boundingBox();
            return boundingBox
                ? { x: boundingBox.x, y: boundingBox.y, width: boundingBox.width, height: boundingBox.height }
                : null;
        };
        this.executeScript = async (script) => {
            const page = this.browser.page;
            const functionHandle = await page.evaluateHandle(script);
            return await this.element.evaluate((htmlElem, functionHandle) => functionHandle(htmlElem), functionHandle);
        };
    }
}
exports.PlaywrightElement = PlaywrightElement;
class PortalPlaywright {
    constructor() {
        //#region IBrowserAutomation
        this.library = BrowserAutomationType_1.BrowserAutomationType.Playwright;
        this.reload = async () => {
            await this.page.reload({ waitUntil: "load" });
        };
        this.hasBrowser = () => {
            return !!this.browser || !!this.context;
        };
        this.getActiveElement = async () => {
            // In some instances, playwright is unable to properly detect active element.
            // The hack is to retrieve active element, get it's class attribute and retrieve active element again.
            let activeElementHandle = await (this._currentFrame || this.page).evaluateHandle(() => {
                return document.activeElement || document.body;
            });
            await activeElementHandle.getAttribute("class");
            activeElementHandle = await (this._currentFrame || this.page).evaluateHandle(() => {
                return document.activeElement || document.body;
            });
            const activeElement = new PlaywrightElement(activeElementHandle, this);
            return activeElement;
        };
        this.moveMouse = async (location, offset) => {
            location instanceof PlaywrightElement
                ? await location.element.hover({ position: offset })
                : await this.mouse.move(location.x + offset?.x, location.y + offset?.y);
        };
        this.getWindowTitle = async () => {
            return await this.page.title();
        };
        this.sendKeys = async (...texts) => {
            const textPromises = texts.map((arg) => {
                if (arg instanceof Promise) {
                    return arg;
                }
                return Promise.resolve(arg);
            });
            const allTexts = (await Promise.all(textPromises)).filter((value) => !!value && value.length > 0);
            const releaseInput = [];
            // Press down the passed key or type in text if not a special key.
            for (let i = 0; i < allTexts.length; i++) {
                try {
                    await this.keyboard.down(allTexts[i]);
                    releaseInput.push(i);
                }
                catch {
                    await this.keyboard.type(allTexts[i]);
                }
            }
            // Release the special keys
            for (let i = 0; i < releaseInput.length; i++) {
                await this.keyboard.up(allTexts[releaseInput[i]]);
            }
        };
        this._observedPages = [];
        this._logs = [];
        this.goto = (0, PortalElement_1.retry)(this, async (url, timeout) => {
            await this.page.goto(url, { timeout: timeout ?? 0 });
        }, "PortalPlaywright.goto()");
        this.findElement = async (locator) => {
            const locatorValue = locator.value ?? locator.locator.value;
            const elementHandle = await (this._currentFrame || this.page)?.$(locatorValue);
            return elementHandle && new PlaywrightElement(elementHandle, this);
        };
        this.findElements = async (locator) => {
            const locatorValue = locator.value ?? locator.locator.value;
            const elements = [];
            const elementHandles = (await (this._currentFrame || this.page)?.$$(locatorValue)) || [];
            for (let i = 0; i < elementHandles.length; i++) {
                elements.push(new PlaywrightElement(elementHandles[i], this));
            }
            return elements;
        };
        this._switchCurrentFrame = (frame) => {
            this._currentFrame = frame;
        };
        this._allPages = async () => {
            try {
                await this.context.waitForEvent("page", {
                    timeout: PortalConfigurationManager_1.default.portalContext.timeouts.pageEventTimeout,
                }); // A hack that forces browser to update its page handles
            }
            catch (e) {
                Logger_1.default.diagnostics("No new pages were created");
            }
            return this.browser.contexts().reduce((last, ctx) => [...last, ...ctx.pages()], []);
        };
        this.wait = async (condition, timeout, opt_messageOrTimeoutErrorFunction, name) => {
            // eslint-disable-next-line prefer-const
            let result;
            timeout = (timeout || PortalConfigurationManager_1.default.portalContext.timeouts.timeout) * (this.codeCoverage ? 2 : 1);
            let countTimeout = timeout;
            playwrightLogger(`Wait info '${name || (typeof opt_messageOrTimeoutErrorFunction === "string" ? opt_messageOrTimeoutErrorFunction : "")}'`);
            let unexpectedError;
            const pollInterval = 100;
            const captureStack = (e) => Error.captureStackTrace(e, this.wait);
            const timeoutPromise = async () => {
                while (countTimeout > 0 && !result) {
                    await (0, PortalElement_1.delay)(pollInterval);
                    countTimeout -= pollInterval;
                }
            };
            const execPromise = async () => {
                while (countTimeout > 0) {
                    try {
                        const val = condition instanceof Promise ? await condition : await condition();
                        if (val) {
                            return val;
                        }
                    }
                    catch (e) {
                        if (typeof e === "string") {
                            unexpectedError = new PlaywrightErrors_1.PlaywrightUnexpectedError(e);
                            captureStack(unexpectedError);
                        }
                        else {
                            unexpectedError = e;
                        }
                    }
                    await (0, PortalElement_1.delay)(pollInterval);
                }
                return null;
            };
            result = await Promise.race([execPromise(), timeoutPromise()]);
            if (result) {
                return result;
            }
            let error;
            if (unexpectedError) {
                error = unexpectedError;
            }
            else {
                error = new PlaywrightErrors_1.PlaywrightTimeoutError(`Wait timeout after ${timeout} ms`);
                captureStack(error);
            }
            if (!(opt_messageOrTimeoutErrorFunction === undefined || opt_messageOrTimeoutErrorFunction === null)) {
                error.message += `\n\t${typeof opt_messageOrTimeoutErrorFunction === "string" ? opt_messageOrTimeoutErrorFunction : await opt_messageOrTimeoutErrorFunction()}`;
            }
            const stackDirtRegex = () => /\(node:|at(?: async)? Portal(?:Playwright)?.wait|at runMicrotasks|at(?: async)? execPromise/;
            error.stack = error.stack
                .split("\n")
                .filter((line) => !stackDirtRegex().test(line))
                .join("\n");
            Logger_1.default.warning(error.stack);
            throw error;
        };
        this.executeScript = async (script, ...var_args) => {
            const promises = var_args.map(async (i) => {
                if (i instanceof PortalElement_1.default) {
                    // Get the webdriver web element to pass down to webdriver's executeScript
                    return (await i.getWebElements())[0]; // take the first element (same behavior as PortalElement)
                }
                else {
                    return i;
                }
            });
            const args = await Promise.all(promises);
            return await this.executeAsyncScript(script, args);
        };
        this.executeAsyncScript = async (script, ...var_args) => {
            const result = await this.page.evaluate(script, var_args);
            return result;
        };
        this.getCurrentUrl = async () => {
            let url;
            this.listener && this.page.off("requestfailed", this.listener);
            this.listener = (request) => {
                if (request.isNavigationRequest()) {
                    this.failedRequestUrl = request.url();
                }
            };
            this.page.on("requestfailed", this.listener);
            await new Promise((resolve) => setTimeout(resolve, 100));
            url = this.page.url();
            // This is a workaround for a bug in Playwright where the page.url() returns "chrome-error://chromewebdata/" when the page is not loaded
            // window.location.href in chrome dev tools also returns "chrome-error://chromewebdata/" in this case
            // We've listened to the requestfailed event and saved the url of the failed request, so we can use it as a fallback
            if ("chrome-error://chromewebdata/" === url) {
                await (0, RunScripts_1.waitUntilScriptsCanExecute)();
                Logger_1.default.information("Page url is chrome-error://chromewebdata/, retrying or getting the url from the failed request");
                url = this.page.url();
                url = url === "chrome-error://chromewebdata/" ? this.failedRequestUrl || url : url;
                Logger_1.default.information(`Page url is ${url}`);
            }
            else {
                this.failedRequestUrl = "";
            }
            return url;
        };
        this.takeScreenshot = async (filePrefix) => {
            const dir = path.join(process.cwd(), "Screenshots");
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
            if (filePrefix) {
                filePrefix = filePrefix.replace(/[|&;$%@"<>()+,: ]/g, "_");
            }
            const fileName = path.join(dir, `${filePrefix ? `${filePrefix}_` : ""}${Date.now().toString()}.png`);
            await this.page.screenshot({
                path: fileName,
                type: "png",
            });
            return fileName;
        };
        this.acceptAlert = async () => {
            try {
                const dialog = await new Promise((res) => {
                    const interval = setInterval(() => this._dialog && res(this._dialog), 100);
                    setTimeout(() => {
                        clearInterval(interval);
                        res(this._dialog);
                    }, 1000);
                });
                await dialog?.accept();
            }
            catch (e) {
                Logger_1.default.warning("No alert found to accept");
            }
        };
        this.dismissAlert = async () => {
            await this.wait(() => this._dialog).catch(() => {
                /*ignore*/
            });
            await this._dialog?.dismiss();
        };
        this.getAlertText = async () => {
            await this.wait(() => this._dialog).catch(() => {
                /*ignore*/
            });
            return await Promise.resolve(this._dialog?.message() || "");
        };
        this.getBrowserLogs = async (level) => {
            let filteredValues = this._logs.filter((value) => value.page === this.page);
            if (level !== LogLevel_1.LogLevel.All) {
                filteredValues = filteredValues.filter((value) => {
                    return value.level === level;
                });
            }
            return await Promise.resolve(filteredValues.map((value) => {
                return value.message;
            }));
        };
        this.closeWindow = async (index) => {
            return await this.context.pages()[index].close();
        };
        this.resizeWindow = async (width, height) => {
            const size = this.page.viewportSize();
            await this.page.setViewportSize({ width: width || size.width, height: height || size.height });
        };
        this._writeCodeCoverage = async () => {
            const coverageDir = path.join(process.cwd(), "coverage");
            const coverageSourceDir = path.join(coverageDir, "source");
            const coverageJsonDir = path.join(coverageDir, "json");
            const nodeModules = "\\node_modules\\";
            let { exclude, includeJsOnly, onlySources, sources } = PortalConfigurationManager_1.default.portalContext
                .codeCoverageOptions || { exclude: [], onlySources: false, sources: null };
            exclude = exclude ? (Array.isArray(exclude) ? exclude : [exclude]) : [];
            exclude.push(nodeModules);
            includeJsOnly = sources ? (includeJsOnly ?? true) : true;
            onlySources = sources ? (onlySources ?? true) : false;
            sources = sources ? (Array.isArray(sources) ? sources : [sources]) : null;
            const checkExclude = (filePath) => exclude.some((filter) => filePath.includes(filter.replace(/\//g, "\\")));
            const sourceData = PortalConfigurationManager_1.default.portalContext.coveredSourceFiles ?? [];
            if (!PortalConfigurationManager_1.default.portalContext.coveredSourceFiles) {
                const sourceFiles = [];
                const sourceDirs = sources &&
                    sources
                        .filter((value) => {
                        const currPath = path.resolve(process.cwd(), value);
                        const pathExists = fs.existsSync(currPath);
                        if (!pathExists) {
                            Logger_1.default.warning(`Code coverage source path doesn't exist: '${currPath}'`);
                            return false;
                        }
                        const isDirectory = fs.lstatSync(currPath).isDirectory();
                        if (!isDirectory) {
                            sourceFiles.push(currPath);
                        }
                        return isDirectory;
                    })
                        .map((value) => path.resolve(process.cwd(), value));
                if (sourceDirs && sourceDirs.length > 0) {
                    sourceFiles.push(...(0, Findup_1.Scan)({
                        dir: sourceDirs,
                        exclude: { filter: [nodeModules] },
                        findAll: true,
                        match: { filter: /\.js$/ },
                    }));
                    sourceFiles.map((jsFile, index) => {
                        const jsMapFile = `${jsFile}.map`;
                        const jsMapFileExists = fs.existsSync(jsMapFile);
                        if (sourceFiles.indexOf(jsFile) !== index || !(includeJsOnly || jsMapFileExists)) {
                            return;
                        }
                        const tsRelative = jsMapFileExists
                            ? JSON.parse(fs.readFileSync(jsMapFile, { encoding: "utf8" })).sources[0]
                            : undefined;
                        const mapDir = path.dirname(jsMapFile);
                        const tsFile = jsMapFileExists ? path.resolve(mapDir, tsRelative) : undefined;
                        const tsFileExists = fs.existsSync(tsFile);
                        if (checkExclude(tsFileExists ? tsFile : jsFile)) {
                            return;
                        }
                        sourceData.push({
                            jsFile: jsFile,
                            tsFile: tsFileExists ? tsFile : undefined,
                            jsMapFile: jsMapFileExists ? jsMapFile : undefined,
                        });
                    });
                }
            }
            const urlPathArray = (url) => url
                .replace(/^(?:http|https):\/\//, "")
                .split("/")
                .filter((_value, index) => index !== 0);
            const v8CoverageEntries = (await this.page.coverage.stopJSCoverage()).filter((entry) => {
                const urlPath = "/" + urlPathArray(entry.url).join("/").toLowerCase();
                return (urlPath.endsWith(".js") && // Non-js files
                    !urlPath.includes("_oss") && // OSS libraries
                    !urlPath.includes("_generated") && // CSS and SVGs
                    !urlPath.includes("@") && // Stuff from NPM
                    !urlPath.includes("/content/dynamic") && // Dynamically generated
                    !urlPath.includes("/?") && // Portal index page
                    !urlPath.includes("/content/scripts/office-ui-fabric-react/lib/") && // Fabric code
                    !urlPath.includes("/content/portalrequireconfig/") && // Sets required scripts
                    !urlPath.includes("/react/index?") && // React index page
                    !urlPath.includes("/content/scripts/msportalimpl/services/browsecuration/") && // Curration config
                    !urlPath.includes("/samplesextension") && // Extension setup/config
                    !urlPath.includes("webpack-internal:") // Webpack bundler
                );
            });
            let istanbulCoverage = {};
            const coveredSourceFiles = sourceData ?? [];
            await Promise.all(v8CoverageEntries.map(async (entry) => {
                try {
                    const urlPath = urlPathArray(entry.url);
                    let localFile = null;
                    if (sourceData.length > 0) {
                        for (let i = 0; i < urlPath.length; i++) {
                            const paths = sourceData.filter((value) => value.jsFile.endsWith(`\\${urlPath.slice(i).join("\\")}`));
                            if (paths.length > 0) {
                                localFile = paths[0];
                                break;
                            }
                        }
                        if ((onlySources && !localFile) ||
                            (!includeJsOnly && (!localFile?.jsMapFile || !localFile?.tsFile))) {
                            return;
                        } // Files with no local source code when 'onlySources' is enabled
                    }
                    const scriptPath = localFile.jsFile ?? path.join(coverageSourceDir, urlPath.join("\\"));
                    const doesSourceFileExist = localFile !== null || fs.existsSync(scriptPath);
                    if (!doesSourceFileExist) {
                        if (!entry.source) {
                            return;
                        } // Files with no local or captured source code
                        const dirPath = scriptPath.split("\\");
                        dirPath.pop();
                        const dirPathJoined = dirPath.join("\\");
                        if (!fs.existsSync(dirPathJoined)) {
                            fs.mkdirSync(dirPathJoined, { recursive: true });
                        }
                        fs.writeFileSync(scriptPath, entry.source);
                    }
                    const sourceCode = entry.source ?? fs.readFileSync(scriptPath, { encoding: "utf8" });
                    const converter = v8ToIstanbul(scriptPath, 0, {
                        source: localFile?.jsMapFile && localFile?.tsFile
                            ? sourceCode
                            : sourceCode.replace("# sourceMappingURL=", ""),
                    });
                    await converter.load();
                    converter.applyCoverage(entry.functions);
                    const cov = converter.toIstanbul();
                    Object.keys(cov).forEach((key) => {
                        if (checkExclude(cov[key].path)) {
                            delete cov[key];
                        }
                    });
                    istanbulCoverage = Object.assign(istanbulCoverage, cov);
                    if (!localFile) {
                        coveredSourceFiles.push({ jsFile: scriptPath, tsFile: undefined, jsMapFile: undefined });
                    }
                }
                catch (e) {
                    Logger_1.default.warning(`Failed to convert coverage for script "${entry.url}": ${e}`);
                }
            }));
            PortalConfigurationManager_1.default.portalContext.coveredSourceFiles = coveredSourceFiles;
            if (istanbulCoverage !== null) {
                const fileName = path.join(coverageJsonDir, `${Date.now().toString()}.json`);
                if (!fs.existsSync(coverageJsonDir)) {
                    fs.mkdirSync(coverageJsonDir, { recursive: true });
                }
                fs.writeFileSync(fileName, JSON.stringify(istanbulCoverage));
            }
        };
        this.quit = async (closeAlert, gracefullyClose = true) => {
            closeAlert && (await this.dismissAlert());
            if (this.codeCoverage && this.page) {
                try {
                    Logger_1.default.information("Writing code coverage");
                    await this._writeCodeCoverage();
                }
                catch (e) {
                    Logger_1.default.warning(`Failed to write code coverage:\n\t${e}`);
                }
            }
            try {
                await this.context?.close();
                gracefullyClose ? await this.browser?.close() : await this.browser?._channel?.killForTests();
            }
            finally {
                this.page = null;
                this.context = null;
                this.browser = null;
            }
        };
        this.create = async (portalContext) => {
            const config = portalContext.playwright;
            if (!config) {
                throw new Error("No playwright configuration found.");
            }
            const options = config.options ?? {};
            if (options.headless === null || options.headless === undefined) {
                options.headless = false;
            }
            config.options = options;
            let browser;
            const authServerAllowListArg = "--auth-server-allowlist=";
            switch (config.browser) {
                case "firefox":
                    browser = playwright_1.firefox;
                    break;
                case "webkit":
                    browser = playwright_1.webkit;
                    break;
                default:
                    browser = playwright_1.chromium;
                    // Prevent Windows Integrated Authentication
                    config.options.args = config.options.args ?? [];
                    if (!config.options.args.some((arg) => arg.startsWith(authServerAllowListArg))) {
                        config.options.args.push(authServerAllowListArg + `""`);
                    }
                    break;
            }
            if (config.contextMode === ContextMode_1.ContextMode.Persistent) {
                this.context = await browser.launchPersistentContext(config.userDataDir || "", config.options || {});
                this.page = this.context.pages()[0];
                Logger_1.default.warning("Creating context in persistent mode. NOTE: Browser object is unavailable in this mode. Use at your own discretion.");
            }
            else {
                this.browser = await browser.launch(config.options || {});
                this.context = await this.browser.newContext(config.options || {});
                this.page = await this.context.newPage();
                const browserVersion = this.browser.version();
                Logger_1.default.information(`${config.browser[0].toUpperCase()}${config.browser.substring(1).toLowerCase()} version: ${browserVersion}`);
            }
            this.page.setViewportSize({
                width: config.resolution?.width || 1280,
                height: config.resolution?.height || 960,
            });
            this.codeCoverage = portalContext.codeCoverage;
            if (this.codeCoverage && config.browser === "chrome") {
                Logger_1.default.information("Starting to collect code coverage. When using 'portal.wait()', all of the timeouts will be doubled to account for additional browser workload due code coverage data collection.");
                if (!portalContext.codeCoverageOptions?.sources) {
                    Logger_1.default.warning(`No code coverage source directories were passed to portal configuration. Collecting coverage for all browser scripts.`);
                }
                await this.page.coverage.startJSCoverage();
            }
            return true;
        };
    }
    async getWindowHandle() {
        return (await this._allPages()).findIndex((page) => page === this.page).toString();
    }
    async getAllWindowHandles() {
        return (await this._allPages()).map((_page, index) => index.toString());
    }
    async switchToWindow(handle) {
        let page = (await this._allPages())[parseInt(handle)];
        if (!page) {
            [page] = await this._allPages();
        }
        await page.bringToFront();
        await page.waitForLoadState("load");
        this.page = page;
    }
    get page() {
        return this._page;
    }
    set page(page) {
        this._page = page;
        this.observePage();
    }
    get keyboard() {
        return new Proxy(this.page.keyboard, {
            set: function () {
                return true;
            },
            get: function (target, key) {
                return target[key];
            },
        });
    }
    get mouse() {
        return this.page.mouse;
    }
    get Key() {
        return PlaywrightKeys;
    }
    observePage() {
        if (this._observedPages.includes(this.page) || !this.page) {
            return;
        }
        const onDialog = (dialog) => {
            this._dialog = dialog;
        };
        const onConsole = (msg) => {
            let level;
            const type = msg.type();
            switch (type) {
                case "debug":
                    level = LogLevel_1.LogLevel.Debug;
                    break;
                case "warning":
                    level = LogLevel_1.LogLevel.Warning;
                    break;
                case "error":
                    level = LogLevel_1.LogLevel.Severe;
                    break;
                default:
                    level = LogLevel_1.LogLevel.Info;
                    break;
            }
            this._logs.push({
                level: level,
                message: `[${type.toUpperCase()}]: ${msg.text()}`,
                page: this.page,
            });
        };
        const onClose = () => {
            page.off("dialog", onDialog);
            page.off("console", onConsole);
            page.off("close", onClose);
            this._observedPages = this._observedPages.filter((p) => p !== page);
        };
        const page = this._page;
        page.on("dialog", onDialog);
        page.on("console", onConsole);
        page.on("close", onClose);
        this._observedPages.push(this.page);
    }
}
exports.PortalPlaywright = PortalPlaywright;
//# sourceMappingURL=PortalPlaywright.js.map