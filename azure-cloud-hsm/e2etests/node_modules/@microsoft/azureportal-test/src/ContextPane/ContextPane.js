"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const By_1 = require("../Locators/By");
const PortalElement_1 = require("../PortalElement");
/**
 * Represents a context pane.
 */
class ContextPane extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.rootClassName = "fxs-contextpane";
        this.contextPaneVisibleClassName = "fxs-contextpane-visible";
        this.contextPaneLoadingClass = "fxs-contextpane-loading";
        this.contextPaneLoadingIndicatorClass = "fxs-contextpane-loadindicator";
        this.bladeCloseClass = "fxs-blade-close";
        this.contextPaneCloseButtonClass = "fxs-contextpane-close";
        this.bladeTitleTextClass = "fxs-blade-title-titleText";
        this.contentClassName = "fxs-contextpane-content";
        this.contextDockedPaneClass = "fxs-portal-contextpane-docked";
    }
    /**
     * Gets the locator associated to this element.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.rootClassName);
    }
    /**
     * Checks whether the element is visible or not.
     *
     * @returns a promise that resolves with a boolean value.
     */
    async isVisible() {
        return await this.hasClass(this.contextPaneVisibleClassName);
    }
    /**
     * Gets a value indicating whether this instance has content.
     */
    async hasContent() {
        return (await this.all(By_1.default.className(this.contentClassName))).length > 0;
    }
    /**
     * Checks whether this instance is in loading state.
     *
     * @returns A promise that resolves to the boolean that determines whether context Pane is Loading
     */
    async isLoading() {
        if (await this.hasClass(this.contextPaneLoadingClass)) {
            return true;
        }
        const items = await this.all(By_1.default.className(this.contextPaneLoadingIndicatorClass)).asPortalElements();
        for (const item of items) {
            if (await item.isDisplayed()) {
                return true;
            }
        }
    }
    /**
     * Gets the title of the context pane.
     */
    async getTitle() {
        const contextPaneTitle = this.element(By_1.default.className(this.bladeTitleTextClass));
        return contextPaneTitle.getText();
    }
    /**
     * Closes the context pane.
     *
     * @returns A promise that will resolve after closing the context pane.
     */
    async close() {
        await this.isPresent();
        let contextPane = ElementArrayFinder_1.default.element(By_1.default.className(ContextPane.contextPaneRightClass));
        if (await ElementArrayFinder_1.default.element(By_1.default.className(this.contextDockedPaneClass)).isDisplayed()) {
            contextPane = ElementArrayFinder_1.default.element(By_1.default.className(this.contextDockedPaneClass));
        }
        let closeElement;
        if (await contextPane.isElementPresent(By_1.default.className(this.bladeCloseClass))) {
            closeElement = contextPane.element(By_1.default.className(this.bladeCloseClass));
        }
        else {
            closeElement = contextPane.element(By_1.default.className(this.contextPaneCloseButtonClass));
        }
        return await closeElement.click();
    }
    /**
     * Checks whether context pane has 'fxs-portal-contextpane-right' class.
     *
     * @returns Boolean signifying if the context pane has the class.
     */
    async hasContextPaneRightClass() {
        return await this.hasClass(ContextPane.contextPaneRightClass);
    }
    /**
     * Gets a value indicating whether the context pane is opened.
     */
    async isOpened() {
        return await this.isVisible();
    }
}
ContextPane.contextPaneRightClass = "fxs-portal-contextpane-right";
exports.default = ContextPane;
//# sourceMappingURL=ContextPane.js.map