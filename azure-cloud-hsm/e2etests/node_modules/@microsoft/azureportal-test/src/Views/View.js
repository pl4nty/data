"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("../Constants");
const ElementArrayFinder_1 = require("../ElementArrayFinder");
const By_1 = require("../Locators/By");
const Logger_1 = require("../Logger");
const PortalElement_1 = require("../PortalElement");
const BrowserAutomation_1 = require("../BrowserAutomation");
class View extends PortalElement_1.default {
    constructor() {
        super(...arguments);
        this.bladeClass = "fxs-blade";
        this.subtitleClass = "fxs-blade-title-subtitleText";
        this.titleClass = "fxs-blade-title-titleText";
        this.closeBladeClass = "fxs-blade-close";
        this.pinBladeClass = "fxs-blade-pin";
        this.pinToDashboardPaneButtonClass = "fxs-pintodashboardpane-pinbutton";
        this.shareItBladeClass = "fxs-blade-shareit";
    }
    /**
     * Gets the title element text.
     *
     * @returns View title.
     */
    async getTitle() {
        return await this.element(By_1.default.className(this.titleClass)).getText();
    }
    /**
     * Gets the subtitle element text.
     *
     * @returns View subtitle.
     */
    async getSubtitle() {
        return await this.element(By_1.default.className(this.subtitleClass)).getText();
    }
    /**
     * Gets the locator associated to this view.
     *
     * @returns A Locator instance.
     */
    get locator() {
        return By_1.default.className(this.bladeClass);
    }
    /**
     * Builds a View locator using the specified options.
     *
     * @param options The options used to build the locator.
     * @returns A Locator instance.
     */
    buildLocator(options) {
        if ("title" in options) {
            return By_1.default.content(By_1.default.className(this.bladeClass), By_1.default.classAndText(this.titleClass, options.title));
        }
        else if ("subTitle" in options) {
            return By_1.default.content(By_1.default.className(this.bladeClass), By_1.default.classAndText(this.subtitleClass, options.subTitle));
        }
        return this.locator;
    }
    /**
     * Returns a value that indicates whether the view has been revealed.
     *
     * @returns A promise that resolves with a value that indicates whether the view has been revealed.
     */
    async isRevealed() {
        const present = await this.isPresent();
        if (!present) {
            return false;
        }
        const [bladeLoadingStatusIsDisplayed, bladeProgressIsDisplayed, bladeIsDisplayed] = await Promise.all([
            this.areElementsDisplayed(By_1.default.className(Constants_1.CssClassNames.Blades.bladeLoadingStatus), true),
            this.areElementsDisplayed(By_1.default.className(Constants_1.CssClassNames.Blades.bladeProgress), true),
            this.isDisplayed(),
        ]);
        return (0, Logger_1.logIfTrue)(Logger_1.default.diagnostics, !bladeLoadingStatusIsDisplayed && !bladeProgressIsDisplayed && bladeIsDisplayed, `View ${this.locator?.toString()} is revealed.`);
    }
    /**
     * Returns a value that indicates whether the view has finished loading.
     *
     * @returns A promise that resolves with a value that indicates whether the view has finished loading.
     */
    async isLoaded() {
        const revealed = await this.isRevealed();
        if (!revealed) {
            return false;
        }
        const [bladeProgressBarIsDisplayed, bladeContentProgressIsDisplayed] = await Promise.all([
            this.areElementsDisplayed(By_1.default.className(Constants_1.CssClassNames.Blades.bladeProgressBar), true),
            this.areElementsDisplayed(By_1.default.className(Constants_1.CssClassNames.Blades.bladeContentProgress), true),
        ]);
        return (0, Logger_1.logIfTrue)(Logger_1.default.diagnostics, !bladeProgressBarIsDisplayed && !bladeContentProgressIsDisplayed, `View ${this.locator?.toString()} is loaded.`);
    }
    /**
     * Waits until the view has been revealed.
     *
     * @param {number} timeout? The time, in milliseconds, to wait for the view to load.
     * @returns A promise that resolves with this view instance when it has been revealed.
     */
    async waitUntilRevealed(timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.isRevealed(), timeout, "The view did not finish revealing within the specified timeout.");
        return this;
    }
    /**
     * Waits until the view has finished loading.
     *
     * @param {number} timeout?  The time, in milliseconds, to wait for the view to load.
     * @returns A promise that resolves with this view instance when it has finished loading.
     */
    async waitUntilLoaded(timeout) {
        await (0, BrowserAutomation_1.getBrowser)().wait(async () => await this.isLoaded(), timeout, "The view did not finish loading within the specified timeout.");
        return this;
    }
    /**
     * Clicks the close button on the view.
     *
     * @returns A promise that results once the close button is clicked.
     */
    async clickClose(dialogCb) {
        Logger_1.default.information("Clicking close button on view");
        await this.element(By_1.default.className(this.closeBladeClass)).click(undefined, dialogCb);
    }
    /**
     * Clicks the pin button on the view.
     *
     * @returns A promise that results once the pin button is clicked.
     */
    async clickPin() {
        Logger_1.default.information("Clicking pin button on view");
        await this.element(By_1.default.className(this.pinBladeClass)).click();
    }
    /**
     * Pins the view to dashboard.
     *
     * @returns A promise that results once the pin to dashboard button is clicked.
     */
    async pinToDashboard() {
        await this.clickPin();
        const pinToDashboardButton = await (0, BrowserAutomation_1.getBrowser)().wait(() => ElementArrayFinder_1.default.element(By_1.default.className(this.pinToDashboardPaneButtonClass)));
        await pinToDashboardButton.click();
    }
    /**
     * Clicks the ShareIt button on the view.
     *
     * @returns A promise that results once the button is clicked.
     */
    async clickShareIt() {
        Logger_1.default.information("Clicking ShareIt button");
        await this.element(By_1.default.className(this.shareItBladeClass)).click();
    }
    /**
     * Returns a boolean that indicates if there is an error in this view.
     *
     * @returns A promise that resolves to a boolean value that indicates if an error is present.
     */
    async hasError() {
        const part = await this.isElementPresent(By_1.default.className(Constants_1.CssClassNames.Parts.errorPart));
        if (part) {
            return await this.isElementPresent(By_1.default.className(Constants_1.CssClassNames.Parts.errorPartIcon));
        }
        return false;
    }
    /**
     * Gets the text of the error message of a view where View.hasError() returns true.
     *
     * @returns A promise which returns a string, or null if there is no error.
     */
    async getErrorText() {
        try {
            return await this.element(By_1.default.className(Constants_1.CssClassNames.Parts.errorPartReason)).getText();
        }
        catch {
            return null;
        }
    }
}
exports.default = View;
//# sourceMappingURL=View.js.map