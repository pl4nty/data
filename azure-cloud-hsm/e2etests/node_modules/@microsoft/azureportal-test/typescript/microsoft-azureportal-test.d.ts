// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../debug
//   ../selenium-webdriver
//   ../playwright
//   ../selenium-webdriver/remote
//   ../nconf
//   ../@azure/arm-resources
//   ../assert
//   ../fs
//   ../axe-core

declare module '@microsoft/azureportal-test' {
    export * as Locators from "@microsoft/azureportal-test/Locators";
    export * as ActionBars from "@microsoft/azureportal-test/ActionBars";
    export * as Blades from "@microsoft/azureportal-test/Blades";
    export * as Browse from "@microsoft/azureportal-test/Browse";
    export * as ContextPanes from "@microsoft/azureportal-test/ContextPanes";
    export * as ConfirmationAlertAction from "@microsoft/azureportal-test/ConfirmationAlertAction";
    export * as Constants from "@microsoft/azureportal-test/Constants";
    export * as Controls from "@microsoft/azureportal-test/Controls";
    export * as Parts from "@microsoft/azureportal-test/Parts";
    export * as Commands from "@microsoft/azureportal-test/Commands";
    export * as Utils from "@microsoft/azureportal-test/Utils";
    export * as Tests from "@microsoft/azureportal-test/Tests";
    export * as Notifications from "@microsoft/azureportal-test/Notifications";
    export * as PortalFxResources from "@microsoft/azureportal-test/PortalFxResources";
    export * as Settings from "@microsoft/azureportal-test/Settings";
    export * as Logger from "@microsoft/azureportal-test/Logger";
    export * as Views from "@microsoft/azureportal-test/Views";
    export * as PortalConfigurationManager from "@microsoft/azureportal-test/PortalConfigurationManager";
    export { IBrowserAutomation } from "@microsoft/azureportal-test/IBrowserAutomation";
    export { PortalPlaywright, PlaywrightElement } from "@microsoft/azureportal-test/PortalPlaywright";
    export { PortalWebDriver, WebDriverElement } from "@microsoft/azureportal-test/PortalWebDriver";
    export { BrowserAutomationType } from "@microsoft/azureportal-test/BrowserAutomationType";
    export { PortalElementOptionsType } from "@microsoft/azureportal-test/PortalElementOptions";
    export { LogLevel } from "@microsoft/azureportal-test/LogLevel";
    import Portal, * as PortalModule from "@microsoft/azureportal-test/Portal";
    import Feature from "@microsoft/azureportal-test/Feature";
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import SplashScreen from "@microsoft/azureportal-test/SplashScreen";
    import TextExtension from "@microsoft/azureportal-test/TestExtension";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import StartBoard from "@microsoft/azureportal-test/StartBoard";
    import TopBar from "@microsoft/azureportal-test/TopBar/TopBar";
    import CtrlAltDOperations from "@microsoft/azureportal-test/CtrlAltDOperations";
    import ErrorPage from "@microsoft/azureportal-test/ErrorPage";
    import Lens from "@microsoft/azureportal-test/Lens";
    import BladeActionBar from "@microsoft/azureportal-test/ActionBars/BladeActionBar";
    import CoBrandPage from "@microsoft/azureportal-test/CoBrandPage";
    import * as BrowserAutomation from "@microsoft/azureportal-test/BrowserAutomation";
    import * as PlaywrightKeys from "@microsoft/azureportal-test/PlaywrightKeys";
    export { Portal, Feature, PortalContext, PortalElement, SplashScreen, TextExtension, ElementArrayFinder, StartBoard, TopBar, CtrlAltDOperations, ErrorPage, Lens, BladeActionBar, CoBrandPage, BrowserAutomation, };
    /**
      * The global Portal object.
      */
    export let portal: typeof PortalModule.portal;
    export * as until from "@microsoft/azureportal-test/ExpectedConditions";
    export * as Search from "@microsoft/azureportal-test/Search";
    export * as Dashboard from "@microsoft/azureportal-test/Dashboard";
    export const Key: typeof PlaywrightKeys;
}

declare module '@microsoft/azureportal-test/Locators' {
    import By from "@microsoft/azureportal-test/Locators/By";
    import ChainedLocator from "@microsoft/azureportal-test/Locators/ChainedLocator";
    import ContentLocator from "@microsoft/azureportal-test/Locators/ContentLocator";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import SimpleLocator from "@microsoft/azureportal-test/Locators/SimpleLocator";
    export { By, ChainedLocator, ContentLocator, Locator, SimpleLocator };
}

declare module '@microsoft/azureportal-test/ActionBars' {
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    import CreateActionBar from "@microsoft/azureportal-test/ActionBars/CreateActionBar";
    import DeleteActionBar from "@microsoft/azureportal-test/ActionBars/DeleteActionBar";
    import FilterActionBar from "@microsoft/azureportal-test/ActionBars/FilterActionBar";
    import GenericActionBar from "@microsoft/azureportal-test/ActionBars/GenericActionBar";
    import PickerActionBar from "@microsoft/azureportal-test/ActionBars/PickerActionBar";
    import FormActionBar from "@microsoft/azureportal-test/ActionBars/FormActionBar";
    export { ActionBar, ActionBarButton, CreateActionBar, DeleteActionBar, FilterActionBar, GenericActionBar, PickerActionBar, FormActionBar, };
}

declare module '@microsoft/azureportal-test/Blades' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import BrowseResourceBlade from "@microsoft/azureportal-test/Blades/BrowseResourceBlade";
    import BrowseResourceBladeGrid from "@microsoft/azureportal-test/Blades/BrowseResourceBladeGrid";
    import CreateBlade from "@microsoft/azureportal-test/Blades/CreateBlade";
    import DeploymentDetailsOverviewBlade from "@microsoft/azureportal-test/Blades/DeploymentDetailsOverviewBlade";
    import GalleryInfoCreateBlade from "@microsoft/azureportal-test/Blades/GalleryInfoCreateBlade";
    import ResourceGroupCreateBlade from "@microsoft/azureportal-test/Blades/ResourceGroupCreateBlade";
    import MoveResourcesBlade from "@microsoft/azureportal-test/Blades/MoveResourcesBlade";
    import MenuBlade from "@microsoft/azureportal-test/Blades/MenuBlade";
    import TabMenuBlade from "@microsoft/azureportal-test/Blades/TabMenuBlade";
    import PickerBlade from "@microsoft/azureportal-test/Blades/PickerBlade";
    import PropertiesBlade from "@microsoft/azureportal-test/Blades/PropertiesBlade";
    import QuickStartBlade from "@microsoft/azureportal-test/Blades/QuickStartBlade";
    import ResourceFilterTextField from "@microsoft/azureportal-test/Blades/ResourceFilterTextField";
    import SpecPicker from "@microsoft/azureportal-test/Blades/SpecPicker";
    import SpecPickerBlade from "@microsoft/azureportal-test/Blades/SpecPickerBlade";
    import UsersBlade from "@microsoft/azureportal-test/Blades/UsersBlade";
    import BladeDialog from "@microsoft/azureportal-test/Blades/BladeDialog";
    import BladeStatusBar from "@microsoft/azureportal-test/Blades/BladeStatusBar";
    import { ContentState } from "@microsoft/azureportal-test/Blades/ContentState";
    import DeleteResourceGroupBlade from "@microsoft/azureportal-test/Blades/DeleteResourceGroupBlade";
    import AllResourcesBlade from "@microsoft/azureportal-test/Blades/AllResourcesBlade";
    import DefaultBladeContent from "@microsoft/azureportal-test/Blades/DefaultBladeContent";
    import DetailBladeContent from "@microsoft/azureportal-test/Blades/DetailBladeContent";
    import BrowseResourceGroupsBlade from "@microsoft/azureportal-test/Blades/BrowseResourceGroupsBlade";
    import AllResourcesArgBrowseBlade from "@microsoft/azureportal-test/Blades/AllResourcesArgBrowseBlade";
    import ResourceGroupsArgBrowseBlade from "@microsoft/azureportal-test/Blades/ResourceGroupsArgBrowseBlade";
    import ResourceArgBrowseBlade from "@microsoft/azureportal-test/Blades/ResourceArgBrowseBlade";
    import MergedResourceArgBrowseBlade from "@microsoft/azureportal-test/Blades/MergedResourceArgBrowseBlade";
    import ResourcePickerBlade from "@microsoft/azureportal-test/Blades/ResourcePickerBlade";
    import * as ArgBrowseBlade from "@microsoft/azureportal-test/Blades/ArgBrowseBlade";
    export { Blade, BrowseResourceBlade, BrowseResourceBladeGrid, CreateBlade, DeploymentDetailsOverviewBlade, GalleryInfoCreateBlade, ResourceGroupCreateBlade, MoveResourcesBlade, MenuBlade, TabMenuBlade, PickerBlade, PropertiesBlade, QuickStartBlade, ResourceFilterTextField, SpecPicker, SpecPickerBlade, UsersBlade, BladeDialog, BladeStatusBar, ContentState, DeleteResourceGroupBlade, AllResourcesBlade, DefaultBladeContent, DetailBladeContent, BrowseResourceGroupsBlade, AllResourcesArgBrowseBlade, ResourceGroupsArgBrowseBlade, ResourceArgBrowseBlade, MergedResourceArgBrowseBlade, ResourcePickerBlade, };
    export import BrowseResourceBladeGridRow = BrowseResourceBladeGrid.Row;
    export import ArgBrowseFilterPill = ArgBrowseBlade.BrowseFilterPill;
}

declare module '@microsoft/azureportal-test/Browse' {
    import * as Browse from "@microsoft/azureportal-test/Browse/BrowseBlade";
    export import BrowseBlade = Browse.BrowseBlade;
    export import getBrowseFromBlade = Browse.getBrowseFromBlade;
    export import BrowseGrid = Browse.BrowseGrid;
    export import BrowseGridColumn = Browse.BrowseGridColumn;
    export import BrowseColumnSort = Browse.BrowseColumnSort;
    export import BrowseSortDirection = Browse.BrowseSortDirection;
    export import BrowseGridRow = Browse.BrowseGridRow;
    export import BrowseGridCell = Browse.BrowseGridCell;
    export import BrowseCommands = Browse.BrowseCommands;
    export import BrowseCommand = Browse.BrowseCommand;
    export import BrowseFeatureCards = Browse.BrowseFeatureCards;
    export import BrowseFeatureCard = Browse.BrowseFeatureCard;
    export import BrowseSearch = Browse.BrowseSearch;
    export import BrowseFilters = Browse.BrowseFilters;
    export import BrowseFilter = Browse.BrowseFilter;
    export import BrowseFilterOperator = Browse.BrowseFilterOperator;
    export import BrowsePages = Browse.BrowsePager;
}

declare module '@microsoft/azureportal-test/ContextPanes' {
    import ContextPane from "@microsoft/azureportal-test/ContextPane/ContextPane";
    export { ContextPane };
}

declare module '@microsoft/azureportal-test/ConfirmationAlertAction' {
    /**
        * Specifies the action to perform when a confirmation alter is shown.
        */
    export enum ConfirmationAlertAction {
            /**
                * No action to be performed.
                */
            None = 0,
            /**
                * Clicks the OK button on the alert.
                */
            Accept = 1,
            /**
                * Clicks the Cancel button on the alert.
                */
            Dismiss = 2
    }
}

declare module '@microsoft/azureportal-test/Constants' {
    /**
        * enum to represent the validation state of a control
        */
    export enum ControlValidationState {
            invalid = 1,
            none = 2,
            pending = 3,
            valid = 4
    }
    /**
        * enum to represent the type of splash screen dialog
        */
    export enum SplashScreenDialogType {
            extension = 0,
            patch = 1
    }
    /**
        * enum to represent blade width
        */
    export enum BladeWidth {
            Small = 0,
            Medium = 1,
            Large = 2,
            XLarge = 3
    }
    /**
        * enum to represent Browser Operations
        */
    export enum BrowserOperations {
            openDebugHub = "fxopendebughub",
            saveSettings = "save",
            clearSettings = "clear"
    }
    /**
        * enum to represent common breakpoints, based on Fluent UI breakpoints
        * See https://developer.microsoft.com/en-us/fluentui#/styles/web/layout
        */
    export const enum ResponsiveWindowSizeBreakpoints {
            SmallMinWidthInPx = 320,
            SmallMaxWidthInPx = 479,
            MediumMinWidthInPx = 480,
            MediumMaxWidthInPx = 639,
            LargeMinWidthInPx = 640,
            LargeMaxWidthInPx = 1023,
            XLargeMinWidthInPx = 1024,
            XLargeMaxWidthInPx = 1365,
            XXLargeMinWidthInPx = 1366,
            XXLargeMaxWidthInPx = 1919,
            XXXLargeMinWidthInPx = 1920
    }
    /**
        * Css Class Names that can be used in locators
        */
    export const CssClassNames: {
            ActionBars: {
                    FilterActionBar: {
                            control: string;
                            resetButton: string;
                            updateButton: string;
                    };
            };
            Blades: {
                    bladeContentProgress: string;
                    bladeLoadingStatus: string;
                    bladeProgress: string;
                    bladeProgressBar: string;
                    bladeStatusBar: string;
                    bladeErrorContent: string;
            };
            Controls: {
                    buttonDisabled: string;
                    copyableLabel: string;
                    copyableLabelCopyButton: string;
                    editor: string;
                    editableCombo: string;
                    editableComboDropImage: string;
                    essentials: string;
                    essentialsAccordion: string;
                    essentialsItem: string;
                    essentialsLabel: string;
                    essentialsMove: string;
                    essentialsValue: string;
                    essentialsValueContainer: string;
                    essentialsViewAllButton: string;
                    essentialsViewAllContainer: string;
                    filterComboField: string;
                    infoBox: string;
                    infoBoxContainer: string;
                    infoBoxSizePrefix: string;
                    infoBoxStylePrefix: string;
                    inputField: string;
                    optionsGroupField: string;
                    edited: string;
                    ValidationState: {
                            invalid: string;
                            none: string;
                            pending: string;
                            valid: string;
                    };
                    pillList: string;
                    pillListContainer: string;
                    pillListItem: string;
                    pillListOverflowItem: string;
                    pillListActionButton: string;
                    monitorChart: string;
                    monitorChartMetric: string;
                    monitorChartValue: string;
                    monitorChartUnit: string;
                    monitorChartData: string;
                    recommendations: string;
                    summaryTitle: string;
                    summaryItemLabel: string;
                    summaryItemValue: string;
            };
            Forms: {
                    formControl: string;
                    disabledState: string;
                    dropDownFocusClass: string;
            };
            Grids: {
                    gridHeader: string;
                    rowCount: string;
            };
            Parts: {
                    collectionPart: string;
                    collectionPartRollupCount: string;
                    collectionPartRollupLabel: string;
                    collectionPartHasMoreData: string;
                    collectionPartTitle: string;
                    collectionSummary: string;
                    collectionSummaryCount: string;
                    collectionSummaryTitle: string;
                    errorPart: string;
                    errorPartIcon: string;
                    errorPartReason: string;
                    propertiesPart: string;
            };
            SearchMenu: {
                    clearElement: string;
                    dropMenu: string;
                    mruItems: string;
                    noResults: string;
                    resultDetails: string;
                    resultSubName: string;
                    resultTitle: string;
                    resultType: string;
                    searchBoxIcon: string;
                    searchCategories: string;
                    searchFlyout: string;
                    searchMenu: string;
                    searchResults: string;
            };
            attributes: {
                    ariaCurrentItemClassName: string;
                    ariaExpandedItemClassName: string;
                    ariaSelectedItemClassName: string;
            };
            AvatarMenu: {
                    avatarMenu: string;
            };
            Debugbox: {
                    stickyDebugBox: string;
            };
    };
}

declare module '@microsoft/azureportal-test/Controls' {
    import AccessHotSpot from "@microsoft/azureportal-test/Controls/AccessHotSpot";
    import AsyncFileUpload from "@microsoft/azureportal-test/Controls/AsyncFileUpload";
    import Button from "@microsoft/azureportal-test/Controls/Button";
    import CheckBoxField from "@microsoft/azureportal-test/Controls/CheckBoxField";
    import CopyableLabel from "@microsoft/azureportal-test/Controls/CopyableLabel";
    import CreatorAndSelectorField from "@microsoft/azureportal-test/Controls/CreatorAndSelectorField";
    import CreateComboBoxField from "@microsoft/azureportal-test/Controls/CreateComboBoxField";
    import DropDownField from "@microsoft/azureportal-test/Controls/DropDownField";
    import DropDownFieldOption from "@microsoft/azureportal-test/Controls/DropDownFieldOption";
    import EditableGrid from "@microsoft/azureportal-test/Controls/EditableGrid";
    import DataGrid from "@microsoft/azureportal-test/Controls/DataGrid";
    import Editor from "@microsoft/azureportal-test/Controls/Editor";
    import Essentials from "@microsoft/azureportal-test/Controls/Essentials";
    import EssentialsItem from "@microsoft/azureportal-test/Controls/EssentialsItem";
    import EssentialsItemProperty from "@microsoft/azureportal-test/Controls/EssentialsItemProperty";
    import { ItemPropertyType as EssentialsItemPropertyType } from "@microsoft/azureportal-test/Controls/EssentialsItemPropertyType";
    import FilterComboField from "@microsoft/azureportal-test/Controls/FilterComboField";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import FormSection from "@microsoft/azureportal-test/Controls/FormSection";
    import Grid from "@microsoft/azureportal-test/Controls/Grid";
    import HotSpot from "@microsoft/azureportal-test/Controls/HotSpot";
    import MonitorChart from "@microsoft/azureportal-test/Controls/MonitorChart";
    import OptionsGroupField from "@microsoft/azureportal-test/Controls/OptionsGroupField";
    import OptionsGroupFieldOption from "@microsoft/azureportal-test/Controls/OptionsGroupFieldOption";
    import PagedDataGrid from "@microsoft/azureportal-test/Controls/PagedDataGrid";
    import PasswordField from "@microsoft/azureportal-test/Controls/PasswordField";
    import Pill from "@microsoft/azureportal-test/Controls/Pill";
    import PillList from "@microsoft/azureportal-test/Controls/PillList";
    import PillListActionButton from "@microsoft/azureportal-test/Controls/PillListActionButton";
    import PillListItem from "@microsoft/azureportal-test/Controls/PillListItem";
    import PillListOverflowItem from "@microsoft/azureportal-test/Controls/PillListOverflowItem";
    import QuickStartHotSpot from "@microsoft/azureportal-test/Controls/QuickStartHotSpot";
    import RangeSlider from "@microsoft/azureportal-test/Controls/RangeSlider";
    import SelectorField from "@microsoft/azureportal-test/Controls/SelectorField";
    import SequentialDataGrid from "@microsoft/azureportal-test/Controls/SequentialDataGrid";
    import SideBar from "@microsoft/azureportal-test/Controls/SideBar";
    import SideBarBrowseFlyout from "@microsoft/azureportal-test/Controls/SideBarBrowseFlyout";
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    import MultiLineTextField from "@microsoft/azureportal-test/Controls/MultiLineTextField";
    import TextBox from "@microsoft/azureportal-test/Controls/TextBox";
    import NumericTextbox from "@microsoft/azureportal-test/Controls/NumericTextbox";
    import GroupDropDownField from "@microsoft/azureportal-test/Controls/GroupDropDownField";
    import GroupDropDownFieldOption from "@microsoft/azureportal-test/Controls/GroupDropDownFieldOption";
    import ResourceGroupDropDownField from "@microsoft/azureportal-test/Controls/ResourceGroupDropDownField";
    import ListView from "@microsoft/azureportal-test/Controls/List/ListView";
    import ListViewItem from "@microsoft/azureportal-test/Controls/List/ListViewItem";
    import ListViewGroup from "@microsoft/azureportal-test/Controls/List/ListViewGroup";
    import ListView2 from "@microsoft/azureportal-test/Controls/List/ListView2";
    import ListViewItem2 from "@microsoft/azureportal-test/Controls/List/ListViewItem2";
    import Toolbar from "@microsoft/azureportal-test/Controls/Toolbars/Toolbar";
    import ToolbarItem from "@microsoft/azureportal-test/Controls/Toolbars/ToolbarItem";
    import Recommendations from "@microsoft/azureportal-test/Controls/Recommendations";
    import ResourceFilter from "@microsoft/azureportal-test/Controls/ResourceFilter";
    import SimpleButton from "@microsoft/azureportal-test/Controls/SimpleButton";
    import CommandBar from "@microsoft/azureportal-test/Controls/CommandBar";
    import InfoBox from "@microsoft/azureportal-test/Controls/InfoBox";
    import ColumnChooser from "@microsoft/azureportal-test/Controls/ColumnChooser/ColumnChooser";
    import { ColumnChooserType } from "@microsoft/azureportal-test/Controls/ColumnChooser/ColumnChooserType";
    import Menu from "@microsoft/azureportal-test/Controls/Menu";
    import { SvgElement } from "@microsoft/azureportal-test/Controls/SvgElement";
    import PropertyItem from "@microsoft/azureportal-test/Parts/PartProperty";
    import MessageBoxBalloon from "@microsoft/azureportal-test/Controls/Balloon/MessageBoxBalloon";
    import Balloon from "@microsoft/azureportal-test/Controls/Balloon/Balloon";
    import MessageBox from "@microsoft/azureportal-test/Controls/Dialogs/MessageBox";
    import DialogBase from "@microsoft/azureportal-test/Controls/Dialogs/DialogBase";
    import TabList from "@microsoft/azureportal-test/Controls/TabList";
    import TagsByResource from "@microsoft/azureportal-test/Controls/TagsByResource";
    import TagEditor from "@microsoft/azureportal-test/Controls/TagEditor";
    import OAuthButtonField from "@microsoft/azureportal-test/Controls/OAuthButtonField";
    import OptionPicker from "@microsoft/azureportal-test/Controls/OptionPicker";
    import Password from "@microsoft/azureportal-test/Controls/Password";
    import TimePicker from "@microsoft/azureportal-test/Controls/TimePicker";
    import DatePicker from "@microsoft/azureportal-test/Controls/DatePicker";
    import DateTimePicker from "@microsoft/azureportal-test/Controls/DateTimePicker";
    export { AccessHotSpot, AsyncFileUpload, Button, CheckBoxField, CopyableLabel, CreatorAndSelectorField, CreateComboBoxField, DropDownField, DropDownFieldOption, EditableGrid, DataGrid, Editor, Essentials, EssentialsItem, EssentialsItemProperty, EssentialsItemPropertyType, FilterComboField, FormElement, FormSection, Grid, HotSpot, MonitorChart, OptionsGroupField, OptionsGroupFieldOption, PagedDataGrid, PasswordField, PillList, PillListActionButton, PillListItem, PillListOverflowItem, QuickStartHotSpot, RangeSlider, SelectorField, SequentialDataGrid, SideBar, SideBarBrowseFlyout, TextField, MultiLineTextField, TextBox, NumericTextbox, GroupDropDownField, GroupDropDownFieldOption, ResourceGroupDropDownField, ListView2, ListViewItem2, Toolbar, ToolbarItem, Recommendations, ResourceFilter, SimpleButton, CommandBar, InfoBox, Menu, SvgElement, ListView, ListViewItem, ListViewGroup, ColumnChooser, ColumnChooserType, PropertyItem, MessageBoxBalloon, Balloon, MessageBox, DialogBase, TabList, TagsByResource, TagEditor, Pill, OAuthButtonField, OptionPicker, Password, TimePicker, DatePicker, DateTimePicker, };
    export import GridRow = Grid.Row;
    export import GridCell = Grid.Cell;
}

declare module '@microsoft/azureportal-test/Parts' {
    import CollectionPart from "@microsoft/azureportal-test/Parts/CollectionPart";
    import CollectionSummaryPart from "@microsoft/azureportal-test/Parts/CollectionSummaryPart";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import PartProperty from "@microsoft/azureportal-test/Parts/PartProperty";
    import PropertiesPart from "@microsoft/azureportal-test/Parts/PropertiesPart";
    import PricingTierPart from "@microsoft/azureportal-test/Parts/PricingTierPart";
    import ResourceSummaryPart from "@microsoft/azureportal-test/Parts/ResourceSummaryPart";
    import Tile from "@microsoft/azureportal-test/Parts/Tile";
    import { TileSize } from "@microsoft/azureportal-test/Parts/TileSize";
    import ButtonPart from "@microsoft/azureportal-test/Parts/ButtonPart";
    import InfoListPart from "@microsoft/azureportal-test/Parts/InfoList/InfoListPart";
    import InfoListItem from "@microsoft/azureportal-test/Parts/InfoList/InfoListItem";
    import { PartContainer } from "@microsoft/azureportal-test/Parts/PartContainer";
    import AssetPart from "@microsoft/azureportal-test/Parts/AssetPart";
    import SpecCard from "@microsoft/azureportal-test/Parts/SpecCard";
    import PartGallery2 from "@microsoft/azureportal-test/PartManagement/PartGallery2";
    import PartGalleryItem2 from "@microsoft/azureportal-test/PartManagement/PartGalleryItem2";
    import ResourcePart from "@microsoft/azureportal-test/Parts/ResourcePart/ResourcePart";
    import ResourcePartProperty from "@microsoft/azureportal-test/Parts/ResourcePart/ResourcePartProperty";
    export { CollectionPart, CollectionSummaryPart, Part, PartProperty, PropertiesPart, PricingTierPart, ResourceSummaryPart, Tile, TileSize, ButtonPart, InfoListPart, InfoListItem, PartContainer, AssetPart, SpecCard, PartGallery2, PartGalleryItem2, ResourcePart, ResourcePartProperty, };
}

declare module '@microsoft/azureportal-test/Commands' {
    import CommandBarItem from "@microsoft/azureportal-test/Commands/CommandBarItem";
    import ContextMenu from "@microsoft/azureportal-test/Commands/ContextMenu";
    import ContextMenuItem from "@microsoft/azureportal-test/Commands/ContextMenuItem";
    import ListCommandPopup from "@microsoft/azureportal-test/Commands/ListCommandPopup";
    export { CommandBarItem, ContextMenu, ContextMenuItem, ListCommandPopup };
}

declare module '@microsoft/azureportal-test/Utils' {
    import DefaultTimeouts from "@microsoft/azureportal-test/Utils/DefaultTimeouts";
    import NConfWindowsCredentialManager from "@microsoft/azureportal-test/Utils/NConfWindowsCredentialManager";
    import WindowsCredentialManager from "@microsoft/azureportal-test/Utils/WindowsCredentialManager";
    /**
      * Provides Azure Resource Manager utilities
      */
    export * as Arm from "@microsoft/azureportal-test/Utils/Arm";
    export * as Array from "@microsoft/azureportal-test/Utils/Array";
    export * as Assert from "@microsoft/azureportal-test/Utils/Assert";
    export * as AssetTypes from "@microsoft/azureportal-test/Utils/AssetTypes";
    export * as ErrorHandling from "@microsoft/azureportal-test/Utils/ErrorHandling";
    export * as Findup from "@microsoft/azureportal-test/Utils/Findup";
    export * as Guid from "@microsoft/azureportal-test/Utils/Guid";
    export * as ReactView from "@microsoft/azureportal-test/Utils/ReactView";
    export * as String from "@microsoft/azureportal-test/Utils/String";
    export * as Timeouts from "@microsoft/azureportal-test/Utils/Timeouts";
    export * as UriBuilder from "@microsoft/azureportal-test/Utils/UriBuilder";
    export { DefaultTimeouts, NConfWindowsCredentialManager, WindowsCredentialManager };
}

declare module '@microsoft/azureportal-test/Tests' {
    export * as Parts from "@microsoft/azureportal-test/Tests/Parts";
    export * as Browse from "@microsoft/azureportal-test/Tests/Browse";
}

declare module '@microsoft/azureportal-test/Notifications' {
    import Notification from "@microsoft/azureportal-test/Notifications/Notification";
    import NotificationsMenu from "@microsoft/azureportal-test/Notifications/NotificationsMenu";
    import NotificationsPane from "@microsoft/azureportal-test/Notifications/NotificationsPane";
    import ToastNotification from "@microsoft/azureportal-test/Notifications/ToastNotification";
    export { Notification, NotificationsMenu, NotificationsPane, ToastNotification };
}

declare module '@microsoft/azureportal-test/PortalFxResources' {
    export const activityLog = "Activity log";
    export const abort = "Abort";
    export const allow = "Allow";
    export const browse = "Browse";
    export const browseAll = "Browse All";
    export const cancel = "Cancel";
    export const chooseColumns = "Choose columns";
    export const chooseColumnsV2 = "Edit columns";
    export const columns = "Edit columns";
    export const createANewGroup = "Create a new group";
    export const createNew = "Create new";
    export const ignore = "Ignore";
    export const localDevelopment = "Local Development";
    export const manageView = "Manage view";
    export const marketplace = "Marketplace";
    export const metrics = "Metrics";
    export const move = "Move";
    export const moveResources = "Move resources";
    export const movingResources = "Moving resources";
    export const movingResourcesComplete = "Moving resources complete";
    export const moveResourceConfirm = "I understand that tools and scripts associated with moved resources will not work until I update them to use new resource IDs";
    export const movingResourcesFailed = "Moving resources failed";
    export const nameLabel = "Name";
    export const no = "No";
    export const ok = "OK";
    export const overview = "Overview";
    export const pinnedToDashboard = "Pinned to dashboard.";
    export const pinToDashboard = "Pin to dashboard";
    export const removeFromDashboard = "Remove from dashboard";
    export const properties = "Properties";
    export const quickStart = "Quick start";
    export const quickStartMenu = "Quickstart";
    export const refresh = "Refresh";
    export const resourceGroup = "Resource group";
    export const resourceGroups = "Resource groups";
    export const retry = "Retry";
    export const searchPlaceholder = "Search resources";
    export const selectExistingResourceGroup = "Select existing resource group";
    export const settings = "Settings";
    export const signInPageTitle = "Sign in to Azure Portal";
    export const signInWithUserAndPasswordInstead = "Sign in with a username and password instead";
    export const signInWithPassword = "Password";
    export const subscription = "Subscription";
    export const users = "Users";
    export const usersMenu = "Access control (IAM)";
    export const yes = "Yes";
    export const untrustedExtension = "Untrusted Extensions!";
    export const untrustedPatch = "Untrusted Patch!";
    export const notifications = "Notifications";
    export const selectAll = "Select all";
    export const allResourcesBladeTitle = "All resources";
    export const browseResourceGroupsBladeTitle = "Resource groups";
    export const edit = "Edit";
    export const bladeTitleFormat = "{0} | {1}";
    export const listCommandDeleteListItem = "Delete";
    export const unsafeURLParamsDialogTitle = "This portal link is customized.";
    export const unsafeURLParamsDialogContinue = "Continue with overrides";
    export const dashboard: {
        resetToDefaultState: string;
        restoreDefaultLayout: string;
        create: string;
        blank: string;
        delete: string;
        share: string;
        edit: string;
        manageSharing: string;
        unshare: string;
        pinPane: {
            subscriptionLbl: string;
            dashboardNameLbl: string;
            createNew: string;
            sharedRadioBtnTxt: string;
            createAndPin: string;
            pin: string;
        };
        sharePane: {
            subscriptionLbl: string;
        };
        partGallery: {
            searchTiles: string;
        };
        clone: string;
        cloneTitleFormat: string;
        notFoundTitle: string;
        download: string;
        export: string;
        upload: string;
    };
    export const ShellCommands: {
        partSizeMini: string;
        partSizeSmall: string;
        partSizeNormal: string;
        partSizeWide: string;
        partSizeTall: string;
        partSizeHeroWide: string;
        partSizeHeroTall: string;
        partSizeHero: string;
        partSizeLarge: string;
    };
    export const debugHubResources: {
        addPart: {
            buttonText: string;
        };
    };
    export const hubsExtension: {
        extensionName: {
            name: string;
        };
        resourceGroups: {
            applyButton: string;
            cancelButton: string;
            createButton: string;
            createTitle: string;
            deleteButton: string;
            deleteConfirmation: string;
            locationLabel: string;
            nameLabel: string;
            nextReviewCreateButton: string;
            nextTagsButton: string;
            noneTags: string;
            resetButton: string;
            reviewCreateButton: string;
            tags: string;
            templateAutomationLink: string;
        };
        allResourcesBlade: {
            allResourcesBladeTitle: string;
            refreshButtonText: string;
        };
        resourceGroupsBlade: {
            resourceGroupsBladeTitle: string;
            refreshButtonText: string;
        };
        resourcePickerBlade: {
            resourcePickerBladeTitle: string;
            refreshButtonText: string;
        };
    };
    export const shellCommands: {
        unpinFromStartboard: string;
        bladeRestore: string;
    };
    export const tagsClientStrings: {
        resourceTagsCollectionPart: {
            partTitle: string;
        };
        resourceTagListsBlade: {
            bladeTitle: string;
        };
        part: {
            settingList: {
                tags: string;
            };
        };
        common: {
            save: string;
            applyLabel: string;
            deleteAll: string;
        };
        assetTypeNames: {
            tag: {
                plural: string;
            };
        };
        compoundFormat: string;
    };
    export const frameworkClientMsPortalFxResources: {
        editableGrid: {
            deleteCommandText: string;
        };
    };
    export const settingsFlyout: {
        appearanceAndStartupViewsTitle: string;
        contactInformation: string;
        directoriesTitle: string;
        filtersTitle: string;
        overviewTitle: string;
        languageAndRegionTitle: string;
        moreAzureResources: string;
        myInformationTitle: string;
        resetStateLabel: string;
        restore: string;
        signoutAndNotificationsTitle: string;
    };
}

declare module '@microsoft/azureportal-test/Settings' {
    export { SettingsFlyout, SettingsViews } from "@microsoft/azureportal-test/Settings/SettingsFlyout";
}

declare module '@microsoft/azureportal-test/Logger' {
    import * as debug from "debug";
    export interface LogData {
            message: string;
            timestamp: string;
    }
    const Log: {
            warning: debug.Debugger;
            information: debug.Debugger;
            diagnostics: debug.Debugger;
            quarantine: debug.Debugger;
            trace: debug.Debugger;
    };
    /**
        * Re-routes test framework logs to a custom logger.
        *
        * @param {(message: string) => void} func A function the logs will get re-routed to.
        */
    export function bind(func: (message: string) => void): void;
    /**
        * Enable log namespace.
        *
        * @param namespace A log namespace to enable.
        */
    export function enable(namespace: string): void;
    /**
        * Logs a message to a specified channel if a condition is true.
        *
        * @param {debug.Debugger} logger A log channel to output the message to.
        * @param {boolean} condition A condition to check.
        * @param {string} text A message to log.
        * @returns {boolean} Checked condition.
        */
    export function logIfTrue(logger: debug.Debugger, condition: boolean, text: string): boolean;
    /**
        * Starts capturing logs to flush them into a file later.
        */
    export function startLogCapture(): void;
    /**
        * Flushes logs into a file.
        *
        * @param {string} dirPrefix A relative path inside the "Log" directory that will be created inside the current working directory to store the "LogSnippet.md" file.
        * @param {{ [key: string]: string }} testMetadata Information about the test that will be displayed in `Test Case Details` section of the log (when using default template).
        * @param {string} error A message that will be displayed in `Error Message` section of the log (when using default template).
        * @param {string} templatePath A path to a template that will be used by `ejs` module to generate the log file. Inside your own template, you can use objects `metadata`, `error` and `logs`. Visit [https://ejs.co/](https://ejs.co/) for more info about templates.
        */
    export function flushLogs(dirPrefix: string, testMetadata?: {
            [key: string]: string;
    }, error?: string, templatePath?: string): void;
    export default Log;
}

declare module '@microsoft/azureportal-test/Views' {
    import ReactView from "@microsoft/azureportal-test/Views/ReactView";
    import DeploymentOverview from "@microsoft/azureportal-test/Views/DeploymentOverview";
    export { DeploymentOverview, ReactView };
}

declare module '@microsoft/azureportal-test/PortalConfigurationManager' {
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    import IPortalConfigurationManager from "@microsoft/azureportal-test/IPortalConfigurationManager";
    class PortalConfigurationManagerImpl implements IPortalConfigurationManager {
            portalContext: PortalContext;
            get configJsonPath(): string;
            set configJsonPath(filePath: string);
            constructor();
            /**
                * Gets the given config value
                *
                * @param key the name of the config value to retrieve
                * @returns the config value if its set, else undefined
                */
            get(key: string): any;
            /**
                * Sets the config value.
                * If the value was provided in argv or env, the config value will not be reset
                *
                * @param key the name of the value to set
                * @param value the value to set it to
                */
            set(key: string, value: any): void;
    }
    /**
        * The global PortalConfigurationManager object that contains configuration for the msportalfx-test framework Portal object to be used for tests.
        * The config hierarchy is args, environment variables, user set values via code, and config json file.
        */
    const PortalConfigurationManager: PortalConfigurationManagerImpl;
    export default PortalConfigurationManager;
}

declare module '@microsoft/azureportal-test/IBrowserAutomation' {
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    import * as webdriver from "selenium-webdriver";
    import { BrowserAutomationType } from "@microsoft/azureportal-test/BrowserAutomationType";
    import { Dialog, ElementHandle } from "playwright";
    import * as PlaywrightKeys from "@microsoft/azureportal-test/PlaywrightKeys";
    export type Button = "left" | "right";
    export interface FindElement {
        findElement(locator: webdriver.Locator, waitUntilLocated?: boolean, timeout?: number): Promise<IBrowserElement>;
        findElements(locator: webdriver.Locator, waitUntilLocated?: boolean, timeout?: number): Promise<IBrowserElement[]>;
    }
    export interface IBrowserElement extends FindElement {
        readonly element: webdriver.WebElement | ElementHandle;
        getAttribute(name: string): Promise<null | string>;
        click(button?: Button, dialogCb?: (dialog: Dialog | webdriver.AlertPromise) => Promise<void>): Promise<void>;
        getCss(property: string): Promise<string>;
        getSelectorPath(): Promise<string>;
        sendKeys(...var_args: Array<string | Promise<string>>): Promise<void>;
        clear(): Promise<void>;
        getText(): Promise<string>;
        getTagName(): Promise<string>;
        getSize(): Promise<{
            width: number;
            height: number;
        }>;
        getLocation(): Promise<{
            x: number;
            y: number;
        }>;
        isDisplayed(): Promise<boolean>;
        moveMouseAndClick(opt_offset: {
            x: number;
            y: number;
        }, clickType: Button): Promise<void>;
        isSelected(): Promise<boolean>;
        isEnabled(): Promise<boolean>;
        getInputValue(): Promise<string>;
    }
    export interface IBrowserAutomation extends FindElement {
        wait<T>(condition: PromiseLike<T> | Function, timeout?: number, opt_messageOrTimeoutErrorFunction?: string | (() => string | Promise<string>), name?: string): Promise<T>;
        executeScript<T>(script: string, ...var_args: any[]): Promise<T>;
        executeAsyncScript<T>(script: string, ...var_args: any[]): Promise<T>;
        getCurrentUrl(): Promise<string>;
        takeScreenshot(filePrefix?: string): Promise<string>;
        acceptAlert(): Promise<void>;
        dismissAlert(): Promise<void>;
        getAlertText(): Promise<string>;
        getBrowserLogs(level: any): Promise<string[]>;
        closeWindow(index: number): Promise<void>;
        resizeWindow(width?: number, height?: number): Promise<void>;
        quit(closeAlert?: boolean): Promise<void>;
        create(context: PortalContext): Promise<boolean>;
        reload(): Promise<void>;
        hasBrowser(): boolean;
        getActiveElement(): Promise<IBrowserElement>;
        moveMouse(location: IBrowserElement | {
            x: number;
            y: number;
        }, offset?: {
            x: number;
            y: number;
        }): Promise<void>;
        getWindowTitle(): Promise<string>;
        sendKeys(...var_args: Array<string | Promise<string>>): Promise<void>;
        getWindowHandle(): Promise<string>;
        getAllWindowHandles(): Promise<string[]>;
        switchToWindow(handle: string): Promise<void>;
        goto(url: string, timeout?: number): Promise<void>;
        readonly library: BrowserAutomationType;
        readonly Key: webdriver.IKey | typeof PlaywrightKeys;
    }
}

declare module '@microsoft/azureportal-test/PortalPlaywright' {
    import { Browser, Dialog, Frame, Page, Keyboard, BrowserContext, Mouse, ElementHandle } from "playwright";
    import { Button, IBrowserAutomation, IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    import { LogLevel } from "@microsoft/azureportal-test/LogLevel";
    import { BrowserAutomationType } from "@microsoft/azureportal-test/BrowserAutomationType";
    export class PlaywrightElement implements IBrowserElement {
        element: ElementHandle;
        browser: PortalPlaywright;
        constructor(element: ElementHandle, browser: PortalPlaywright);
        getAttribute: (name: string) => Promise<string>;
        findElement: (locator: Locator) => Promise<IBrowserElement>;
        findElements: (locator: Locator) => Promise<IBrowserElement[]>;
        click: (button?: Button, dialogCb?: (diag: Dialog) => Promise<void>) => Promise<void>;
        getCss: (property: string) => Promise<string>;
        getSelectorPath: () => Promise<string>;
        sendKeys: (...texts: (string | Promise<string>)[]) => Promise<void>;
        clear: () => Promise<void>;
        getText: () => Promise<string>;
        getTagName: () => Promise<string>;
        getSize: () => Promise<{
            width: number;
            height: number;
        }>;
        getLocation: () => Promise<{
            x: number;
            y: number;
        }>;
        isDisplayed: () => Promise<boolean>;
        moveMouseAndClick: (opt_offset?: {
            x: number;
            y: number;
        }, clickType?: Button) => Promise<void>;
        isSelected: () => Promise<boolean>;
        isEnabled: () => Promise<boolean>;
        checkState: (state: "disabled" | "enabled" | "hidden" | "stable" | "visible", timeout?: number) => Promise<boolean>;
        getInputValue: () => Promise<string>;
        executeScript: <T>(script: string) => Promise<T>;
    }
    export class PortalPlaywright implements IBrowserAutomation {
        library: BrowserAutomationType;
        reload: () => Promise<void>;
        hasBrowser: () => boolean;
        getWindowHandle(): Promise<string>;
        getAllWindowHandles(): Promise<string[]>;
        switchToWindow(handle: string): Promise<void>;
        getActiveElement: () => Promise<IBrowserElement>;
        moveMouse: (location: PlaywrightElement | {
            x: number;
            y: number;
        }, offset?: {
            x: number;
            y: number;
        }) => Promise<void>;
        getWindowTitle: () => Promise<string>;
        sendKeys: (...texts: (string | Promise<string>)[]) => Promise<void>;
        browser: Browser;
        context: BrowserContext;
        _page: Page;
        _observedPages: Page[];
        _currentFrame: Frame;
        _dialog: Dialog;
        _logs: {
            level: LogLevel;
            message: string;
            page: Page;
        }[];
        get page(): Page;
        set page(page: Page);
        get keyboard(): Keyboard;
        get mouse(): Mouse;
        get Key(): any;
        goto: (url: string, timeout?: number) => Promise<void>;
        findElement: (locator: Locator) => Promise<IBrowserElement>;
        findElements: (locator: Locator) => Promise<IBrowserElement[]>;
        _switchCurrentFrame: (frame: Frame | null) => void;
        wait: <T>(condition: () => T | PromiseLike<T>, timeout?: number, opt_messageOrTimeoutErrorFunction?: string | (() => string | Promise<string>), name?: string) => Promise<T>;
        executeScript: <T>(script: string, ...var_args: any[]) => Promise<T>;
        executeAsyncScript: <T>(script: string, ...var_args: any[]) => Promise<T>;
        getCurrentUrl: () => Promise<string>;
        takeScreenshot: (filePrefix?: string) => Promise<string>;
        acceptAlert: () => Promise<void>;
        dismissAlert: () => Promise<void>;
        getAlertText: () => Promise<string>;
        getBrowserLogs: (level: LogLevel) => Promise<string[]>;
        closeWindow: (index: number) => Promise<void>;
        resizeWindow: (width?: number, height?: number) => Promise<void>;
        quit: (closeAlert?: boolean, gracefullyClose?: boolean) => Promise<void>;
        create: (portalContext: PortalContext) => Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/PortalWebDriver' {
    import * as webdriver from "selenium-webdriver";
    import * as wdremote from "selenium-webdriver/remote";
    import { LogLevel } from "@microsoft/azureportal-test/LogLevel";
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    import { Button, IBrowserAutomation, IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    import { BrowserAutomationType } from "@microsoft/azureportal-test/BrowserAutomationType";
    export class WebDriverElement implements IBrowserElement {
            element: webdriver.WebElement;
            constructor(element: webdriver.WebElement);
            getAttribute: (name: string) => Promise<string>;
            findElement: (locator: webdriver.Locator, waitUntilLocated?: boolean, timeout?: number) => Promise<IBrowserElement>;
            findElements: (locator: webdriver.Locator, waitUntilLocated?: boolean, timeout?: number) => Promise<IBrowserElement[]>;
            click(button?: Button, dialogCb?: (dialog: webdriver.AlertPromise) => Promise<void>): Promise<void>;
            getCss: (property: string) => Promise<string>;
            getSelectorPath: () => Promise<string>;
            sendKeys(...var_args: (string | Promise<string>)[]): Promise<void>;
            clear(): Promise<void>;
            getText: () => Promise<string>;
            getTagName: () => Promise<string>;
            getSize: () => Promise<webdriver.ISize>;
            getLocation: () => Promise<webdriver.ILocation>;
            isDisplayed: () => Promise<boolean>;
            moveMouseAndClick(opt_offset: {
                    x: number;
                    y: number;
            }, clickType: Button): Promise<void>;
            isSelected: () => Promise<boolean>;
            isEnabled: () => Promise<boolean>;
            getInputValue(): Promise<string>;
    }
    export class PortalWebDriver implements IBrowserAutomation {
            library: BrowserAutomationType;
            get driver(): webdriver.WebDriver;
            get error(): typeof webdriver.error;
            get Key(): webdriver.IKey;
            findElement: (locator: webdriver.Locator, waitUntilLocated?: boolean, timeout?: number) => Promise<IBrowserElement>;
            findElements: (locator: webdriver.Locator, waitUntilLocated?: boolean, timeout?: number) => Promise<IBrowserElement[]>;
            goto(url: string): Promise<void>;
            wait<T>(condition: PromiseLike<T> | Function, timeout?: number, opt_messageOrTimeoutErrorFunction?: string | (() => string | Promise<string>), name?: string): Promise<T>;
            executeScript<T>(script: string, ...var_args: any[]): Promise<T>;
            executeAsyncScript<T>(script: string, ...var_args: any[]): Promise<T>;
            getCurrentUrl(): Promise<string>;
            takeScreenshot(filePrefix?: string): Promise<string>;
            acceptAlert(): Promise<void>;
            dismissAlert(): Promise<void>;
            getAlertText(): Promise<string>;
            getBrowserLogs(level: any): Promise<string[]>;
            closeWindow(index: number): Promise<void>;
            resizeWindow(width?: number, height?: number): Promise<void>;
            quit(closeAlert?: boolean): Promise<void>;
            create(context: PortalContext): Promise<boolean>;
            reload(): Promise<void>;
            hasBrowser(): boolean;
            getActiveElement(): Promise<IBrowserElement>;
            moveMouse(location: WebDriverElement | {
                    x: number;
                    y: number;
            }, offset?: {
                    x: number;
                    y: number;
            }): Promise<void>;
            getWindowTitle(): Promise<string>;
            sendKeys(...var_args: (string | Promise<string>)[]): Promise<void>;
            getWindowHandle(): Promise<string>;
            getAllWindowHandles(): Promise<string[]>;
            switchToWindow(handle: string): Promise<void>;
            static driver: webdriver.WebDriver;
            static wdservice: wdremote.DriverService;
            static portalContext: PortalContext;
            /**
                * Gets the internal WebDriver instance used by this Portal object.
                *
                * @returns The WebDriver instance.
                */
            static getDriver(): webdriver.WebDriver;
            /**
                * Schedules a command to wait for a condition to hold. The condition may be
                * specified by a promise or a custom function.
                *
                * For a function, the wait will repeatedly evaluate the condition until it returns a truthy value. If any errors occur
                * while evaluating the condition, they will be allowed to propagate. In the event a condition returns a promise, the
                * polling loop will wait for it to be resolved and use the resolved value for whether the condition has been satisified.
                *
                * @param condition The condition to wait on, defined as a promise or a function to evaluate as a condition.
                * @param {number} timeout How long to wait for the condition to be true.
                * @param {string} opt_messageOrTimeoutErrorFunction An optional message to use if the wait times out.
                * @param name The name of the wait.
                * @returns  A promise that will be fulfilled with the first truthy value returned by the condition function, or
                *     rejected if the condition times out.
                */
            static wait<T>(condition: PromiseLike<T> | Function, timeout?: number, opt_messageOrTimeoutErrorFunction?: string | (() => string | Promise<string>), name?: string): Promise<T>;
            /**
                * Schedules a command to execute JavaScript in the context of the currently
                * selected frame or window. The script fragment will be executed as the body
                * of an anonymous function. If the script is provided as a function object,
                * that function will be converted to a string for injection into the target
                * window.
                *
                * @param {string} script The script to execute.
                * @param {...*} var_args The arguments to pass to the script.
                * @returns A promise that will resolve to the scripts return value.
                */
            static executeScript<T>(script: string, ...var_args: any[]): Promise<T>;
            /**
                * dismiss an alert if one is present.
                *
                * @returns A promise that will be resolved when the alert is dismissed.
                */
            static dismissAlert(): Promise<void>;
            /**
                * Schedules a command to execute asynchronous JavaScript in the context of the
                * currently selected frame or window. The script fragment will be executed as
                * the body of an anonymous function. If the script is provided as a function
                * object, that function will be converted to a string for injection into the
                * target window.
                *
                * Any arguments provided in addition to the script will be included as script
                * arguments and may be referenced using the {@code arguments} object.
                * Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
                * Arrays and objects may also be used as script arguments as long as each item
                * adheres to the types previously mentioned.
                *
                * Unlike executing synchronous JavaScript with {@link #executeScript},
                * scripts executed with this function must explicitly signal they are finished
                * by invoking the provided callback. This callback will always be injected
                * into the executed function as the last argument, and thus may be referenced
                * with {@code arguments[arguments.length - 1]}. The following steps will be
                * taken for resolving this functions return value against the first argument
                * to the script's callback function:
                *
                * - For a HTML element, the value will resolve to a
                *     {@link webdriver.WebElement}
                * - Null and undefined return values will resolve to null
                * - Booleans, numbers, and strings will resolve as is
                * - Functions will resolve to their string representation
                * - For arrays and objects, each member item will be converted according to
                *     the rules above
                *
                * __Example #1:__ Performing a sleep that is synchronized with the currently
                * selected window:
                *
                *     var start = new Date().getTime();
                *     driver.executeAsyncScript(
                *         'window.setTimeout(arguments[arguments.length - 1], 500);').
                *         then(function() {
                *           Log.information(
                *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
                *         });
                *
                * __Example #2:__ Synchronizing a test with an AJAX application:
                *
                *     var button = driver.findElement(By.id('compose-button'));
                *     button.click();
                *     driver.executeAsyncScript(
                *         'var callback = arguments[arguments.length - 1];' +
                *         'mailClient.getComposeWindowWidget().onload(callback);');
                *     driver.switchTo().frame('composeWidget');
                *     driver.findElement(By.id('to')).sendKeys('dog@example.com');
                *
                * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
                * this example, the inject script is specified with a function literal. When
                * using this format, the function is converted to a string for injection, so it
                * should not reference any symbols not defined in the scope of the page under
                * test.
                *
                *     driver.executeAsyncScript(function() {
                *       var callback = arguments[arguments.length - 1];
                *       var xhr = new XMLHttpRequest();
                *       xhr.open("GET", "/resource/data.json", true);
                *       xhr.onreadystatechange = function() {
                *         if (xhr.readyState == 4) {
                *           callback(xhr.responseText);
                *         }
                *       }
                *       xhr.send('');
                *     }).then(function(str) {
                *       Log.information(JSON.parse(str)['food']);
                *     });
                *
                * @param {!(string|Function)} script The script to execute.
                * @param {...*} var_args The arguments to pass to the script.
                * @returns {!webdriver.promise.Promise.<T>} A promise that will resolve to the
                *    scripts return value.
                * @template T
                */
            static executeAsyncScript<T>(script: string, ...var_args: any[]): Promise<T>;
            /**
                * Schedules a command to retrieve the URL of the current page.
                *
                * @returns A promise that will be resolved with the current URL.
                */
            static getCurrentUrl(): Promise<string>;
            /**
                * Schedule a command to take a screenshot. The driver makes a best effort to return a screenshot of the following, in order of preference:
                * <ol>
                *   <li>Entire page
                *   <li>Current window
                *   <li>Visible portion of the current frame
                *   <li>The screenshot of the entire display containing the browser
                * </ol>
                *
                * @param {string} filePrefix The prefix used for the generated screenshot file.
                * @returns A promise that will be resolved to the path of the screenshot file.
                * @tutorial tutorial-screenshot
                */
            static takeScreenshot(filePrefix?: string): Promise<string>;
            /**
                * Accepts an alert if one is present
                *
                * @returns a promise when the alert has been accepted
                */
            static acceptAlert(): Promise<void>;
            /**
                * Gets the text from an alert if one is present
                *
                * @returns a promise that will be resolved with the text of the alert.
                */
            static getAlertText(): Promise<string>;
            /**
                * Gets the browser logs for the specified level.
                *
                * @param {LogLevel} level The level of logs to get.
                * @returns A promise that resolves to the array of logs.
                */
            static getBrowserLogs(level: LogLevel): Promise<string[]>;
            /**
                * Schedules a command to close the window (tab) at the specified index.
                *
                * @param {number} index Index of the window (tab) to close.
                * @returns A promise that resolves when the window (tab) has been closed.
                */
            static closeWindow(index: number): Promise<void>;
            /**
                * Resizes the browser to a specified width and height
                *
                * @param {number} width New width to be set, defaults to current width
                * @param {number} height New height to be set, defaults to current height
                * @returns A promise that resolves when the window has been resized.
                */
            static resizeWindow(width?: number, height?: number): Promise<void>;
            /**
                * Schedules a command to quit the current session. After calling quit, this
                * instance will be invalidated and may no longer be used to issue commands
                * against the browser.
                *
                * @param closeAlert When true will close any active alerts.
                * @returns A promise that will be resolved when the command has completed.
                */
            static quit(closeAlert?: boolean): Promise<void>;
            /**
                * Creates a webDriver to control the browser window.
                * Called by Portal.ts. Usually not necessary for test implementers.
                *
                * @param context PortalContext options to create the webDriver.
                */
            static createWebDriver(context: PortalContext): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/BrowserAutomationType' {
    export enum BrowserAutomationType {
        WebDriver = "webdriver",
        Playwright = "playwright"
    }
}

declare module '@microsoft/azureportal-test/PortalElementOptions' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    export type PortalElementOptionsType<TBase> = TBase extends PortalElement<infer TOptions> ? TOptions : never;
}

declare module '@microsoft/azureportal-test/LogLevel' {
    /**
      * Represents the level of logging to apply to the webdriver.
      */
    export enum LogLevel {
        All = 0,
        Debug = 1,
        Info = 2,
        Warning = 3,
        Severe = 4,
        Off = 5
    }
}

declare module '@microsoft/azureportal-test/Portal' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import BrowseResourceBlade from "@microsoft/azureportal-test/Blades/BrowseResourceBlade";
    import CreateBlade from "@microsoft/azureportal-test/Blades/CreateBlade";
    import MenuBlade from "@microsoft/azureportal-test/Blades/MenuBlade";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { LogLevel } from "@microsoft/azureportal-test/LogLevel";
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import SearchMenu from "@microsoft/azureportal-test/Search/SearchMenu";
    import SearchResult from "@microsoft/azureportal-test/Search/SearchResult";
    import Startboard from "@microsoft/azureportal-test/StartBoard";
    import { PortalMode } from "@microsoft/azureportal-test/PortalMode";
    import SideBar from "@microsoft/azureportal-test/Controls/SideBar";
    import NotificationsPane from "@microsoft/azureportal-test/Notifications/NotificationsPane";
    import { CustomNotificationsPane } from "@microsoft/azureportal-test/Notifications/NotificationsPane";
    import AvatarMenu from "@microsoft/azureportal-test/AvatarMenu/AvatarMenu";
    import TopBar from "@microsoft/azureportal-test/TopBar/TopBar";
    import ContextPane from "@microsoft/azureportal-test/ContextPane/ContextPane";
    import DebugFlyout from "@microsoft/azureportal-test/ContextPane/DebugFlyout";
    import View from "@microsoft/azureportal-test/Views/View";
    import { SettingsFlyout } from "@microsoft/azureportal-test/Settings";
    import ModalDialog from "@microsoft/azureportal-test/Controls/Dialogs/ModalDialog";
    import MessageBox from "@microsoft/azureportal-test/Controls/Dialogs/MessageBox";
    import { IBrowserAutomation } from "@microsoft/azureportal-test/IBrowserAutomation";
    /**
        * Represents an object that provides multiple operations to interact with the Portal.
        */
    export default class Portal {
            /**
                * The associated PortalContext object used to configure the Portal instance.
                */
            portalContext: PortalContext;
            /**
                * Creates a new instance of this class.
                */
            constructor();
            /**
                * Gets Searchmenu.
                *
                * @returns an instance of SearchMenu Class.
                */
            getSearchMenu(): Promise<SearchMenu>;
            /**
                * Gets Dashboard.
                *
                * @returns an instance of StartBoard Class.
                */
            getDashboard(): Promise<Startboard>;
            /**
                * Gets the ContextPane.
                *
                * @returns an instance of ContextPane Class.
                */
            getContextPane(): Promise<ContextPane>;
            /**
                * Optionally, sets sessionId. This is for tests to call, if a unique session is needed.
                *
                * @param {string} suffix optional suffix in sessionId. Generally, it could be some combination of test suite/test case names.
                */
            setSessionIdInPortalContext(suffix: string): void;
            /**
                * Gets SideBar.
                *
                * @returns an instance of SideBar Class.
                */
            getSideBar(): Promise<SideBar>;
            /**
                * Opens the gallery create blade for the specified gallery package. This function is only supported for
                * gallery packages deployed to the gallery service. When the package only exists locally use function openGalleryCreateBladeFromLocalPackage.
                *
                * @param {string} galleryPackageName The name of the gallery package.
                * @param {string} bladeTitle The title of the blade that is expected to open.
                * @param {number} timeout The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
                * @returns A promise that resolves with the gallery create blade.
                */
            openGalleryCreateBlade(galleryPackageName: string, bladeTitle: string, timeout?: number, waitForBladeLoadedOnly?: boolean): Promise<Blade>;
            /**
                * Opens the create blade from gallery package that is sideloaded from localhost.
                *
                * @param {string} galleryItemTitle The title of the gallery item in marketplace
                * @param {string} bladeTitle The title of the extensions create blade that is expected to open after clicking on the gallery item.
                * @param {number} [timeout] Optional time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @param {boolean} [waitForBladeLoadedOnly] If true waits for the blade only to load, but not all of its tiles, before resolving
                * @returns A promise that resolves with the gallery CreateBlade.
                */
            openGalleryCreateBladeFromLocalPackage(galleryItemTitle: string, bladeTitle: string, timeout?: number, waitForBladeLoadedOnly?: boolean): Promise<CreateBlade>;
            /**
                * Opens the browse blade for the given resource provider and resource type.
                *
                * @param {string} resourceProvider The resource provider.
                * @param {string} resourceType The resource type.
                * @param {string} bladeTitle The title of the blade that is expected to open.
                * @param {number} [timeout] The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
                * @returns A promise that resolves with the browse blade.
                */
            openBrowseBlade(resourceProvider: string, resourceType: string, bladeTitle: string, timeout?: number, waitForBladeLoadedOnly?: boolean): Promise<BrowseResourceBlade>;
            /**
                * Opens the ARG browse resource groups blade.
                *
                * @param {number} [timeout] Optional time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
                * @returns A promise that resolves with the browse resource groups blade.
                */
            openArgBrowseResourceGroupsBlade(timeout?: number, waitForBladeLoadedOnly?: boolean): Promise<BrowseResourceBlade>;
            /**
                * Opens the resource/summary blade associated to the specified resource id.
                *
                * @param {string} resourceId The resource id.
                * @param {string} bladeTitle The title of the blade that is expected to open.
                * @param {number} timeout The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
                * @returns A promise that resolves with the resource blade.
                */
            openResourceBlade(resourceId: string, bladeTitle: string, timeout?: number, waitForBladeLoadedOnly?: boolean): Promise<MenuBlade>;
            /**
                * Opens the blade associated to the specified URI fragment.
                *
                * @param {string} uriFragment The uri fragment of the blade to navigate to.
                * @param {string} bladeTitle The title of the blade that is expected to open.
                * @param {string} bladeType The type of the blade that is expected to open.
                * @param {number} timeout The time to wait, in milliseconds, for the blade to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @param {boolean} [waitForBladeLoadedOnly] if true waits for the blade only to load, but not all of its tiles, before resolving
                * @returns A promise that resolves with the blade.
                */
            openBlade<T extends Blade>(uriFragment: string, bladeTitle?: string, bladeType?: {
                    new (): T;
            }, timeout?: number, waitForBladeLoadedOnly?: boolean): Promise<T>;
            /**
                * Opens the view associated to the specified URI fragment.
                *
                * @param {string} uriFragment The uri fragment of the view to navigate to.
                * @param {string} viewTitle The title of the view that is expected to open.
                * @param {string} viewType The type of the view that is expected to open.
                * @param {number} timeout The time to wait, in milliseconds, for the view to show up. Defaults to DefaultTimeouts.extraLongTimeout.
                * @returns A promise that resolves with the view.
                */
            openView<T extends View>(uriFragment: string, viewTitle: string, viewType: {
                    new (): T;
            }, timeout?: number): Promise<T>;
            /**
                * Searches for the specified text in the portal top bar and returns search results.
                *
                * @param text The text to search for.
                * @returns A promise that resolves when there are search results.
                */
            search(text: string): Promise<SearchResult[]>;
            /**
                * Starts a move operation using the specified options.
                *
                * @param options The options used to populate the blade.
                * @returns A promise that resolves when the move operation has started.
                */
            startMoveResource(options: {
                    resourceId: string;
                    targetResourceGroup: string;
                    createNewGroup?: boolean;
                    subscriptionName?: string;
                    relatedResources?: string[];
                    timeout?: number;
                    listOptionText?: string;
            }): Promise<void>;
            /**
                * Resets the current dashboard to its default state.
                *
                * @deprecated Use `StartBoard.reset` instead.
                */
            resetDashboard(): Promise<void>;
            /**
                * Navigates to the home page.
                *
                * @param {number} timeout The time to wait, in milliseconds, for pages to load.
                * @param {boolean} waitForDashboardTilesToLoad whether to wait for all tiles on dashboard to load
                */
            goHome(timeout?: number, waitForDashboardTilesToLoad?: boolean): Promise<void>;
            /**
                * Navigates to the specified uri fragment. In most cases, use this.openBlade(...) instead.
                *
                * @param {string} fragment The uri fragment to navigate to.
                * @param {number} timeout The time to wait for pages to load.
                * @throws Will throw an error if the specified fragment is a falsy value.
                */
            navigateToUriFragment(fragment: string, timeout?: number): Promise<any>;
            /**
                * Gets a Blade object that represents the blade that matches the specified options.
                *
                * @param options The options used to find the blade.
                * @param bladeType The type of blade to return.
                * @returns A Blade object that represents the blade that matches the specified options.
                */
            blade<T extends Blade>(options: {
                    title?: string;
                    subTitle?: string;
                    bladeType?: {
                            new (): T;
                    };
            }): T;
            /**
                * Gets a View object that represents the view that matches the specified options.
                *
                * @param options The options used to find the view.
                * @returns A View object that represents the view that matches the specified options.
                */
            view<T extends View>(options: ({
                    title?: string;
            } | {
                    subTitle?: string;
            }) & {
                    viewType: {
                            new (): T;
                    };
            }): T;
            /**
                * Gets a PortalElement that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns A PortalElement that matches the specified sub locator or element type.
                */
            element<T extends PortalElement>(subLocatorOrElementType: Locator | {
                    new (): T;
            }): T;
            /**
                * Gets a PortalElement that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns A PortalElement that matches the specified sub locator or element type if found, or null.
                */
            elementOrDefaultAsync<T extends PortalElement>(subLocatorOrElementType: Locator | {
                    new (): T;
            }): Promise<T>;
            /**
                * Gets an ElementArrayFinder that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns An ElementArrayFinder that matches the specified sub locator or element type.
                */
            all<T extends PortalElement>(subLocatorOrElementType: Locator | {
                    new (): T;
            }): ElementArrayFinder<T>;
            /**
                * Schedules a command to wait for a condition to hold. The condition may be
                * specified by a promise or a custom function.
                *
                * For a function, the wait will repeatedly evaluate the condition until it returns a truthy value. If any errors occur
                * while evaluating the condition, they will be allowed to propagate. In the event a condition returns a promise, the
                * polling loop will wait for it to be resolved and use the resolved value for whether the condition has been satisified.
                *
                * @param condition The condition to wait on, defined as a promise or a function to evaluate as a condition.
                * @param {number} timeout How long to wait for the condition to be true.
                * @param {string | function} opt_messageOrTimeoutErrorFunction An optional message to use if the wait times out or an optional function that returns an error message.
                * @param name name to pass to the webdriver wait function
                * @returns A promise that will be fulfilled with the first truthy value returned by the condition function, or
                *     rejected if the condition times out.
                */
            wait<T>(condition: PromiseLike<T> | Function, timeout?: number, opt_messageOrTimeoutErrorFunction?: string | (() => string | Promise<string>), name?: string): Promise<T>;
            /**
                * Delays execution for the specified amount of time.
                *
                * @param ms The amount of time to delay, in milliseconds. Defaults to delayTimeout.
                * @returns A promise that will be resolved after the specified amount of time has passed.
                */
            delay(ms?: number): Promise<void>;
            /**
                * Schedule a command to take a screenshot. The driver makes a best effort to return a screenshot of the following, in order of preference:
                * <ol>
                *   <li>Entire page
                *   <li>Current window
                *   <li>Visible portion of the current frame
                *   <li>The screenshot of the entire display containing the browser
                * </ol>
                *
                * @param {string} filePrefix The prefix used for the generated screenshot file.
                * @returns A promise that will be resolved to the path of the screenshot file.
                * @tutorial tutorial-screenshot
                */
            takeScreenshot(filePrefix?: string): Promise<string>;
            /**
                * Accepts an alert if one is present
                *
                * @returns a promise when the alert has been accepted
                */
            acceptAlert(): Promise<void>;
            /**
                * dismiss an alert if one is present
                *
                * @returns a promise when the alert has been dismissed
                */
            dismissAlert(): Promise<void>;
            /**
                * Gets the text from an alert if one is present
                *
                * @returns a promise that will be resolved with the text of the alert.
                */
            getAlertText(): Promise<string>;
            /**
                * Gets the browser logs for the specified level.
                *
                * @param {LogLevel} level The level of logs to get.
                * @returns A promise that resolves to the array of logs.
                */
            getBrowserLogs(level: LogLevel): Promise<string[]>;
            /**
                * Schedules a command to execute JavaScript in the context of the currently
                * selected frame or window. The script fragment will be executed as the body
                * of an anonymous function. If the script is provided as a function object,
                * that function will be converted to a string for injection into the target
                * window.
                *
                * @param {string} script The script to execute.
                * @param {...*} var_args The arguments to pass to the script.
                * @returns A promise that will resolve to the scripts return value.
                */
            executeScript<T>(script: string, ...var_args: any[]): Promise<T>;
            /**
                * Schedules a command to execute asynchronous JavaScript in the context of the
                * currently selected frame or window. The script fragment will be executed as
                * the body of an anonymous function. If the script is provided as a function
                * object, that function will be converted to a string for injection into the
                * target window.
                *
                * Any arguments provided in addition to the script will be included as script
                * arguments and may be referenced using the {@code arguments} object.
                * Arguments may be a boolean, number, string, or {@code webdriver.WebElement}.
                * Arrays and objects may also be used as script arguments as long as each item
                * adheres to the types previously mentioned.
                *
                * Unlike executing synchronous JavaScript with {@link #executeScript},
                * scripts executed with this function must explicitly signal they are finished
                * by invoking the provided callback. This callback will always be injected
                * into the executed function as the last argument, and thus may be referenced
                * with {@code arguments[arguments.length - 1]}. The following steps will be
                * taken for resolving this functions return value against the first argument
                * to the script's callback function:
                *
                * - For a HTML element, the value will resolve to a
                *     {@link IBrowserElement}
                * - Null and undefined return values will resolve to null
                * - Booleans, numbers, and strings will resolve as is
                * - Functions will resolve to their string representation
                * - For arrays and objects, each member item will be converted according to
                *     the rules above
                *
                * __Example #1:__ Performing a sleep that is synchronized with the currently
                * selected window:
                *
                *     var start = new Date().getTime();
                *     driver.executeAsyncScript(
                *         'window.setTimeout(arguments[arguments.length - 1], 500);').
                *         then(function() {
                *           Log.information(
                *               'Elapsed time: ' + (new Date().getTime() - start) + ' ms');
                *         });
                *
                * __Example #2:__ Synchronizing a test with an AJAX application:
                *
                *     var button = driver.findElement(By.id('compose-button'));
                *     button.click();
                *     driver.executeAsyncScript(
                *         'var callback = arguments[arguments.length - 1];' +
                *         'mailClient.getComposeWindowWidget().onload(callback);');
                *     driver.switchTo().frame('composeWidget');
                *     driver.findElement(By.id('to')).sendKeys('dog@example.com');
                *
                * __Example #3:__ Injecting a XMLHttpRequest and waiting for the result. In
                * this example, the inject script is specified with a function literal. When
                * using this format, the function is converted to a string for injection, so it
                * should not reference any symbols not defined in the scope of the page under
                * test.
                *
                *     driver.executeAsyncScript(function() {
                *       var callback = arguments[arguments.length - 1];
                *       var xhr = new XMLHttpRequest();
                *       xhr.open("GET", "/resource/data.json", true);
                *       xhr.onreadystatechange = function() {
                *         if (xhr.readyState == 4) {
                *           callback(xhr.responseText);
                *         }
                *       }
                *       xhr.send('');
                *     }).then(function(str) {
                *       Log.information(JSON.parse(str)['food']);
                *     });
                *
                * @param {!(string|Function)} script The script to execute.
                * @param {...*} var_args The arguments to pass to the script.
                * @returns {Promise<T>} A promise that will resolve to the
                *    scripts return value.
                * @template T
                */
            executeAsyncScript<T>(script: string, ...var_args: any[]): Promise<T>;
            /**
                * Schedules a command to retrieve the URL of the current page.
                *
                * @returns A promise that will be resolved with the current URL.
                */
            getCurrentUrl(): Promise<string>;
            /**
                * Schedules a command to close the window (tab) at the specified index.
                *
                * @param {number} index Index of the window (tab) to close.
                * @returns A promise that resolves when the window (tab) has been closed.
                */
            closeWindow(index: number): Promise<void>;
            /**
                * Schedules a command to resize the window to the specified width and height.
                *
                * @param {number} width New width to be set, defaults to current width.
                * @param {number} height New height to be set, defaults to current height.
                * @returns A promise that resolves when the window has been resized.
                */
            resizeWindow(width?: number, height?: number): Promise<void>;
            /**
                * Schedules a command to quit the current session. After calling quit, this
                * instance will be invalidated and may no longer be used to issue commands
                * against the browser.
                *
                * @param closeAlert When true will close any active alerts.
                * @param gracefullyClose When true will close the browser gracefully. When false will close the browser immediately.
                * @returns A promise that will be resolved when the command has completed.
                */
            quit(closeAlert?: boolean, gracefullyClose?: boolean): Promise<any>;
            /**
                * Gets the internal BrowserAutomation instance used by this Portal object.
                *
                * @returns The BrowserAutomation instance.
                */
            getBrowser(): IBrowserAutomation;
            /**
                * Returns a boolean indicating whether the internal BrowserAutomation instance has been created.
                */
            hasBrowser(): boolean;
            /**
                * Returns a promise that resolves after the blade loading.
                *
                * @param {Blade} blade The blade object to open.
                * @param {boolean} waitForBladeLoadedOnly if true waits for the blade only to load, but not all of its tiles, before resolving.
                * @param {number} timeout The time to wait, in milliseconds, for the blade to show up.
                * @returns A promise that resolves with the loaded blade.
                */
            getBladeLoadPromise(blade: Blade, waitForBladeLoadedOnly?: boolean, timeout?: number): Promise<Blade>;
            /**
                * Enters the organize mode.
                *
                * @deprecated Use Startboard.enterOrganizeMode
                *  * @returns a promise when the portal enters in OrganizeMode.
                */
            enterOrganizeMode(): Promise<void>;
            /**
                * Exits the organize mode.
                *
                * @deprecated Use Startboard.exitOrganizeMode
                *  * @returns a promise when the portal enters in OrganizeMode.
                */
            exitOrganizeMode(): Promise<void>;
            /**
                * Returns the current PortalMode.
                */
            waitForMode(): Promise<PortalMode>;
            /**
                * Checks whether portal is in OrganizeMode or not
                *
                * @returns A promise that will be resolved when the portal is in OrganizeMode.
                */
            isInOrganizeMode(): Promise<boolean>;
            /**
                * Checks whether portal is in DefaultMode or not
                *
                * @returns A promise that will be resolved when the portal is in DefaultMode.
                */
            isInDefaultMode(): Promise<boolean>;
            /**
                * Get resource deeplink.
                *
                * @param {string} resourceId resource id.
                * @param {string} cloudName cloud name. Only used in framework tests.
                */
            getResourceDeepLink(resourceId: string, cloudName?: string): Promise<string>;
            /**
                * Wait for the portal to be ready to run scripts.
                *
                * @param timeout time to wait for scripts to run. Default is 10 seconds.
                * @param waitForBootstrap whether to wait for bootstrap to complete. Default is false.
                * @returns a promise that resolves when scripts can run.
                */
            waitUntilScriptsCanExecute({ timeout, waitForBootstrap, }?: {
                    timeout?: number;
                    waitForBootstrap?: boolean;
            }): Promise<boolean>;
            /**
                * Get Blade deeplink.
                *
                * @param {string} extensionName extension name. eg.:- "HubsExtension", "InternalSamplesExtension","SamplesExtension" etc.
                * @param {string} bladeName blade name. e.g. :- "Resources","BrowseAllResourcesBlade" etc.
                * @param {string} cloudName cloud name. Only used in framework tests.
                * @param {string} parametersWithLeadingSlash parameters with leading slash. e.g.:- `/resourceType/Microsoft.Test%2Fdesktops` etc.
                * @returns {Promise<string>} A promise that will be resolved with the Blade's deeplink. e.g.:- 'blade/HubsExtension/Resources/resourceType/Microsoft.Test%2Fdesktops'
                */
            getBladeDeepLink(extensionName: string, bladeName: string, cloudName?: string, parametersWithLeadingSlash?: string): Promise<string>;
            /**
                * Get Asset deeplink.
                *
                * @param {string} extensionName extension name.
                * @param {string} assetId asset id.
                * @param {string} cloudName cloud name. Only used in framework tests.
                */
            getAssetDeepLink(extensionName: string, assetId: string, cloudName?: string): Promise<string>;
            /**
                * check if it is MultiCloud
                */
            checkIfMultiCloud(): Promise<boolean>;
            /**
                * Browse to specified asset type.
                *
                * @param {string} assetTypePluralName asset type plural name.
                * @param {number} bladeLoadTimeout optional - the amount of time to wait for the blade to load
                */
            browseToAssetType(assetTypePluralName: string, bladeLoadTimeout?: number): Promise<void>;
            /**
                * Gets the Debug Pane.
                *
                * @returns DebugFlyout.
                */
            getDebugFlyout: () => Promise<DebugFlyout>;
            /**
                * Adds the specified part to the start board.
                *
                * @param {string} extensionName The name of the extension that contains the part type.
                * @param {string} partTypeName The part type to add.
                * @param {string} modelJson The JSON of the container model for the part.
                * @param {string} cloudName The cloud name of the part. Only used in framework tests.
                */
            addPart(extensionName: string, partTypeName: string, modelJson: string, cloudName?: string): Promise<void>;
            refreshExtensions(): Promise<void>;
            waitForSplashGone(timeout?: number): Promise<boolean>;
            /**
                * opens the dashboard.
                *
                * @param checkTiles flag to wait for tiles
                */
            openDashboard(checkTiles?: boolean): Promise<Startboard>;
            /**
                * Gets all the opened blades on the dashboard.
                */
            getAllBlades(): Promise<Blade[]>;
            /**
                * Go to specified asset type blade through All services button on Sidebar.
                *
                * @param {string} assetTypeName asset type name.
                * @param {string} bladeTitle optional - blade title, in case assetTypeName (item text on 'All Services' blade) and blade title are different.
                * @param {number} bladeLoadTimeout optional - the amount of time to wait for the blade to load
                */
            openAssetTypeBladeFromAllServicesOnSideBar(assetTypeName: string, bladeTitle?: string, bladeLoadTimeout?: number): Promise<void>;
            /**
                * Check if asset type exist.
                *
                * @param {string} assetTypePluralName asset type plural name.
                */
            checkIfAssetTypeExists(assetTypePluralName: string): Promise<Boolean>;
            /**
                * Gets TopBar.
                *
                * @returns an instance of TopBar Class.
                */
            getTopBar(): TopBar;
            /**
                * Browse to resource type using deep link.
                *
                * @param resourceType Resource type name
                * @param cloudName Cloud name. Only used in framework tests.
                */
            browseToResourceTypeUsingDeepLink(resourceType: string, cloudName?: string): Promise<void>;
            /**
                * Browse to asset type using deep link.
                *
                * @param assetTypePluralName Asset type plural name.
                * @param cloudName Cloud name. Only used in framework tests.
                */
            browseToAssetTypeUsingDeepLink(assetTypePluralName: string, cloudName?: string): Promise<void>;
            /**
                * Gets a value indicating whether there is a StartBoard in the Portal.
                */
            hasStartBoard(): Promise<boolean>;
            /**
                * waits for the portal to reload.
                *
                * @param actionToTriggerReload condition function which triggers reload
                */
            waitForPortalToReload(actionToTriggerReload: () => Promise<void>): Promise<void>;
            /**
                * waits for the page to reload,other than portal.
                *
                * @param actionToTriggerReload condition function which triggers the reload.
                */
            waitForPageToReload(actionToTriggerReload: () => Promise<void>): Promise<void>;
            /**
                * Finds the portal.
                *
                * @param checkIfPartsExist True if checking for existence of parts on start board is required.
                */
            findPortal(checkIfPartsExist?: boolean): Promise<void>;
            /**
                * Gets AvatarMenu.
                *
                * @returns an instance of AvatarMenu Class.
                */
            getAvatarMenu(): AvatarMenu;
            /**
                * Opens the Notifications Pane.
                *
                * @param findCustomPane flag to search for the Custom Notifications Pane rather than the portal default.
                * @returns A promise that will resolve to Notifications Pane.
                */
            openNotificationsPane(findCustomPane?: boolean): Promise<NotificationsPane | CustomNotificationsPane>;
            /**
                * Enabled or disables animations in the portal.
                *
                * @param enabled enable or disable the animations.
                */
            enableAnimations(enabled: boolean): Promise<void>;
            /**
                * Returns a value that indicates if the specified blade is closed.
                *
                * @param titleOfBladeToBeClosed Title of blade to be closed.
                * @param expectedCountAfterBladeClosure the number of expected blades after the blade is closed
                */
            waitForBladeClosure(titleOfBladeToBeClosed: string, expectedCountAfterBladeClosure: number): Promise<void>;
            /**
                * Resets all Portal user settings to the defaults.
                *
                * @param {boolean} clearAllUserSettings feature flag to clear all user settings.
                * @returns Promise which resolves when user settings are reset.
                */
            restoreDefaultSettings(clearAllUserSettings?: boolean): Promise<void>;
            /**
                * Get the settings flyout.
                *
                * @returns Promise which resolves to settings flyout.
                */
            getSettingsFlyout(): Promise<SettingsFlyout>;
            /**
                * Wait for Modal Dialog
                *
                * @param {string} title Title of modal dialog.
                * @returns Promise which resolves modal dialog.
                */
            waitForModalDialog(title?: string): Promise<ModalDialog>;
            /**
                * Share dashboard to session repository
                *
                * @param {string} dashboardTitle Title of dashboard to be shared.
                * @returns Promise which resolves when dashboard is shared to session repository.
                */
            shareDashboadToSessionRepository(dashboardTitle: string): Promise<void>;
            /**
                * Get names of loaded extensions.
                *
                * @returns Promise which resolves to names of loaded extensions.
                */
            getLoadedExtensionNames(): Promise<string[]>;
            /**
                * Clear dashboards from session repository
                *
                * @returns Promise which resolves when dashboards are cleared from session repository.
                */
            clearDashboardsFromSessionRepository(): Promise<void>;
            /**
                * Drag and drop a portal element to specified coordinates.
                *
                * @param {testFx.PortalElement} source Portal elment to be drag and dropped.
                * @param {number} x coordiate of drop location.
                * @param {number} y coordiate of drop location.
                * @returns Promise which resolves when portal element is drag and dropped to specified coordinates.
                */
            dragAndDrop(source: PortalElement, x: number, y: number): Promise<void>;
            /**
                * Finds a MessageBox within the Portal.
                *
                * @param title The title of the message box to find.
                * @returns the found MessageBox.
                */
            findMessageBox(title?: string): Promise<MessageBox>;
            /**
                * Drag and drop a portal element to a target element.
                *
                * @param {testFx.PortalElement} source Portal elment to be dragged.
                * @param {testFx.PortalElement} target Portal elment on which to drop.
                * @returns Promise which resolves when portal element is drag and dropped to specified coordinates.
                */
            dragAndDropByTargetElement(source: PortalElement, target: PortalElement): Promise<void>;
            /**
                * Waits for the provided element to be present in the Portal.
                *
                * @param element The element to wait for
                * @param timeout optional, the amount of time to wait in milliseconds.
                */
            waitForElementPresent(element: PortalElement, timeout?: number): Promise<void>;
            /**
                * Opens a new browser instance on an empty page.
                * NOTE: set any browser properties in portal configuration manager before opening a new browser instance.
                *
                * @throws Will throw an error if an instance of a browser already exists.
                * @returns A thruthful boolean after succesfully creating a new browser instance.
                */
            openBrowser(): Promise<boolean>;
            /**
                * Waits for url to settle and for the page to be ready.
                *
                * @param initialUrl Initial url that the page should navigate away from. Initial url should be retrieved before an action that redirects to a different url.
                * @param timeout Time to wait for url to settle before throwing a timeout error.
                * @returns {string} A url that has been settled.
                */
            waitForPageToSettle(initialUrl?: string, timeout?: number): Promise<string>;
    }
    /**
        * The global Portal object.
        */
    export let portal: Portal;
}

declare module '@microsoft/azureportal-test/Feature' {
    /**
        * Represents a Portal feature.
        */
    export default interface Feature {
            /**
                * The feature name.
                */
            name: string;
            /**
                * The feature value.
                */
            value: string;
    }
}

declare module '@microsoft/azureportal-test/PortalContext' {
    import TestExtension from "@microsoft/azureportal-test/TestExtension";
    import { BrowserAutomationType } from "@microsoft/azureportal-test/BrowserAutomationType";
    import Feature from "@microsoft/azureportal-test/Feature";
    import BrowserResolution from "@microsoft/azureportal-test/BrowserResolution";
    import SilentAuthConfig from "@microsoft/azureportal-test/SilentAuthConfig";
    import Timeout from "@microsoft/azureportal-test/Timeout";
    import { LaunchOptions } from "playwright";
    import { ContextMode } from "@microsoft/azureportal-test/ContextMode";
    import { CodeCoverageOptions } from "@microsoft/azureportal-test/ICodeCoverageOptions";
    export class AutomationConfiguration {
            /**
                * The name of the browser being used; should be one of {chrome}
                */
            browserName: string;
            /**
                * Chrome-specific supported capabilities.
                */
            chromeOptions: {
                    /**
                        * List of command-line arguments to use when starting Chrome.
                        */
                    args: string[];
            };
            /**
                * The desired starting browser's resolution in pixels.
                */
            browserResolution: BrowserResolution;
    }
    export class PlaywrightConfiguration {
            /**
                * The name of the browser being used
                */
            browser: "chrome" | "firefox" | "webkit";
            /**
                * Browser launch option (https://playwright.dev/docs/api/class-browsertype#browser-type-launch)
                */
            options: LaunchOptions;
            /**
                * The desired starting browser's resolution in pixels.
                */
            resolution: BrowserResolution;
            /**
                * The type of context that will be launched - incognito or persistent
                */
            contextMode: ContextMode;
            /**
                * Location of the user profile for persistent context mode
                */
            userDataDir: string;
    }
    export class PortalContextBase {
            /**
                * The set of setting for playwright browser automation.
                */
            playwright: PlaywrightConfiguration;
            /**
                * The set of capabilities enabled in the webdriver session.
                * For a list of available capabilities, see https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities
                */
            capabilities: AutomationConfiguration;
            /**
                * The browserstack url the tests should run on.
                * This field needs to be set if the tests are meant to run on browserstack
                * and should not be set if the tests are meant to run locally.
                */
            browserStackUrl?: string;
            /**
                * The path to the ChromeDriver binary.
                */
            chromeDriverPath?: string;
            /**
                * The url of the Portal.
                */
            portalUrl: string;
            /**
                * The url of the page where signin is performed.
                */
            signInUrl?: string;
            /**
                * A timeout for a user to manually sign in to the portal.
                */
            manualSignInTimeout?: number;
            /**
                * A user's email to manually sign in to the portal.
                */
            manualSignInEmail?: string;
            /**
                * Email of the user used to sign in to the Portal.
                */
            signInEmail?: string;
            /**
                * Password of the user used to sign in to the Portal.
                */
            signInPassword?: string;
            /**
                * Boolean indicating if silent auth should used to sign in to the Portal.
                */
            useSilentAuthLogin?: boolean;
            /**
                * Configuration for silent auth
                */
            silentAuthConfig?: SilentAuthConfig;
            /**
                * Configuration for cert-based auth
                */
            certBasedAuth?: boolean;
            /**
                * The set of features to enable while navigating within the Portal.
                */
            features?: Feature[];
            /**
                * The list of patch files to load within the Portal.
                */
            patches?: string[];
            /**
                * Flag to enable executing the provided patches in Portal shell in addition to the extensions
                */
            patchShell?: boolean;
            /**
                * The set of extensions to side load while navigating within the Portal.
                */
            testExtensions?: TestExtension[];
            /**
                * The set of timeouts used to override the default timeouts.
                * e.g.
                * timeouts: {
                *      timeout: 15000  //Overrides the default short timeout of 10000 (10 seconds).
                *      longTimeout: 70000 //Overrides the default long timetout of 60000 (60 seconds).
                * }
                */
            timeouts?: Timeout;
            /**
                * browser session Id
                */
            sessionId?: string;
            /**
                * fake user Id
                */
            fakeUser?: string;
            /**
                * Partner team running the tests.
                */
            partnerTeamEmail: string;
            /**
                * Browser automation type to use.
                */
            browserAutomation?: BrowserAutomationType;
            /**
                * Tenant id to navigate to.
                */
            tenantId?: string;
            /**
                * Flag to enable collection of code coverage data (Playwright only)
                */
            codeCoverage?: boolean;
            /**
                * Options for code coverage analysis (Playwright only)
                */
            codeCoverageOptions?: CodeCoverageOptions;
            /**
                * Flag indicating whether to initialize the directLine token during tests.
                */
            initializeDirectLine?: boolean;
    }
    /**
        * Represents The set of options used to configure a Portal instance.
        */
    export default interface PortalContext extends PortalContextBase {
            [x: string]: any;
    }
    type PortalContextPropsArray = Array<keyof PortalContext>;
    /**
        * Represents the set of keys for the default options.
        */
    export const PortalContextPropNames: PortalContextPropsArray;
    export {};
}

declare module '@microsoft/azureportal-test/PortalElement' {
    /**
        * ------------------------------------------- START OF THIRD PARTY NOTICE -----------------------------------------
        * This file is based on or incorporates material from the projects listed below (Third Party IP).The original copyright notice and the license under which Microsoft received such Third Party IP, are set forth below.Such licenses and notices are provided for informational purposes only.Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.
        *
        * angular - protractor v3.0
        * Copyright(c) 2010- 2015 Google, Inc.
        *
        * Provided for Informational Purposes Only
        * MIT License
        *
        * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        *
        * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        *
        * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        * NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
        * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
        * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        * ----------------------------------------------- END OF THIRD PARTY NOTICE ------------------------------------------
        */
    import * as webdriver from "selenium-webdriver";
    import { Options as AccessibilityOptions, AxeAnalysis } from "@microsoft/azureportal-test/Accessibility";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import IPortalElementRetryOptions from "@microsoft/azureportal-test/IPortalElementRetryOptions";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { PortalElementOptionsType } from "@microsoft/azureportal-test/PortalElementOptions";
    import { IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    import { Dialog } from "playwright";
    /**
        * Wrap a browser automation browser access call in a retry.
        *
        * @param webElem this to apply to the function
        * @param cb a function to wrap in a retry
        * @returns A function that will return a promise with a retry for a browser automation call
        */
    export const retry: <TElement, TResult, A extends any[]>(webElem: TElement, cb: (this: TElement, ...args: A) => Promise<TResult>, fnName?: string) => (...args: A) => Promise<TResult>;
    /**
        * Delays execution for the specified amount of time.
        *
        * @param ms The amount of time to delay, in milliseconds. Defaults to delayTimeout.
        * @returns A promise that will be resolved after the specified amount of time has passed.
        */
    export function delay(ms?: number): Promise<void>;
    /**
        * Represents a single element of an ElementArrayFinder.
        */
    export default class PortalElement<TOptions = never> {
            /**
                * The ElementArrayFinder used to locate elements.
                */
            parentElementArrayFinder: ElementArrayFinder<PortalElement>;
            webElement: IBrowserElement;
            /**
                * Creates a PortalElement from the specified IBrowserElement.
                *
                * @param {IBrowserElement} webElem The IBrowserElement.
                * @param {Locator} locator Reference locator originaly used to find the IBrowserElement.
                * @param {elementArrayFinder} elementType The type of PortalElement from which the locator was extracted.
                * @param frameId The frame identifier to look search from.
                * @returns The PortalElement.
                */
            static fromWebElement<T extends PortalElement>(webElem: IBrowserElement, locator: Locator, elementType: {
                    new (elementArrayFinder?: ElementArrayFinder<T>): T;
            }, frameId?: string): T;
            /**
                * Creates a new instance of this class.
                *
                * @param elementArrayFinder The ElementArrayFinder used to locate elements.
                */
            constructor(elementArrayFinder?: ElementArrayFinder<PortalElement>, frameId?: string);
            /**
                * Gets the name of the class constructor (typescript, not html class).  May not work if javascript is minified
                *
                * @returns The name of the class constrcutor
                */
            get constructorName(): string;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            buildLocator(_options: TOptions): Locator;
            /**
                * Gets a PortalElement that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns A PortalElement that matches the specified sub locator or element type.
                */
            find<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }, locatorOptions?: TElementOptions): Promise<TPortalElement>;
            /**
                * Gets PortalElements that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns An ElementArrayFinder that matches the specified sub locator or element type.
                */
            findAll<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }, locatorOptions?: TElementOptions): Promise<TPortalElement[]>;
            /**
                * Gets a PortalElement that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns A PortalElement that matches the specified sub locator or element type.
                */
            element<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }, locatorOptions?: TElementOptions): TPortalElement;
            /**
                * Gets a PortalElement that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns A PortalElement that matches the specified sub locator or element type if found, or null.
                */
            elementOrDefaultAsync<T extends PortalElement>(subLocatorOrElementType: Locator | {
                    new (): T;
            }): Promise<T>;
            /**
                * Gets an ElementArrayFinder that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns An ElementArrayFinder that matches the specified sub locator or element type.
                */
            all<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }, locatorOptions?: TElementOptions): ElementArrayFinder<TPortalElement>;
            /**
                * Transforms this PortalElement instance into the specified type. A new object is created as opposed to only casting to the specified type.
                *
                * @param targetType The type into which the PortalElement will be transformed.
                * @returns A PortalElement of the specified type.
                */
            asType<T extends PortalElement>(targetType?: {
                    new (elementArrayFinder: ElementArrayFinder<PortalElement>, frameId?: string): T;
            }): T;
            /**
                * Invokes the click function on the underlying web element.
                *
                * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
                * @param dialogCb Optional callback that will be invoked if a dialog is encountered.
                *                 The callback will be passed the dialog and should return a promise
                *                 that resolves when the dialog has been handled.
                * @returns A promise that resolves when the invoked function resolves.
                */
            click(retryOptions?: IPortalElementRetryOptions, dialogCb?: (dialog: Dialog | webdriver.AlertPromise) => Promise<void>): Promise<void>;
            /**
                * Invokes a right click on the underlying web element.
                *
                * @returns A promise that resolves when the right click resolves.
                */
            rightClick(): Promise<void>;
            /**
                * Invokes the getAttribute function on the underlying web element.
                *
                * @param {string} attributeName The attribute to retrieve.
                * @returns A promise that resolves when the invoked function resolves.
                */
            getAttribute(attributeName: string): Promise<string>;
            /**
                * Invokes the getCssValue function on the underlying web element.
                *
                * @param {string} propertyName The value to retrieve.
                * @returns A promise that resolves when the invoked function resolves.
                */
            getCssValue(propertyName: string): Promise<string>;
            /**
                * Returns a value that indicates whether this element has the specified attribute and value.
                *
                * @param {string} attributeName The name of the attribute.
                * @param {string} attributeValue The value of the attribute.
                * @returns A promise that resolves with the result of the evaluation.
                */
            hasAttributeValue(attributeName: string, attributeValue: string): Promise<boolean>;
            /**
                * Returns a value that indicates whether this element does not have the specified attribute and value.
                *
                * @param {string} attributeName The name of the attribute.
                * @param {string} attributeValue The value of the attribute.
                * @returns A promise that resolves with the result of the evaluation.
                */
            doesNotHaveAttributeValue(attributeName: string, attributeValue: string): Promise<boolean>;
            /**
                * Invokes the sendKeys function on the underlying web element.
                *
                * @param {string} var_args The text to send.
                * @returns A promise that resolves when the invoked function resolves.
                */
            sendKeys(...var_args: string[]): Promise<void>;
            /**
                * Schedules a command to clear the value of this element.
                *
                * @returns A promise that will be resolved when the element has been cleared.
                */
            clear(): Promise<void>;
            /**
                * Invokes the getText function on the underlying web element.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            getText(): Promise<string>;
            /**
                * Invokes the getSize function on the underlying web element.
                *
                * @returns {Promise<{ width: number, height: number }>} Size object wrapped in a promise.
                */
            getSize(): Promise<{
                    width: number;
                    height: number;
            }>;
            /**
                * Invokes the getLocation function on the underlying web element.
                *
                * @returns {Promise<{ x: number, y: number }>} Size object wrapped in a promise.
                */
            getLocation(): Promise<{
                    x: number;
                    y: number;
            }>;
            /**
                * Invokes the isEnabled function on the underlying web element.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isElementEnabled(): Promise<boolean>;
            /**
                * Invokes the isDisplayed function on the underlying web element.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isDisplayed(checkFxsDisplayNoneClass?: boolean): Promise<boolean>;
            /**
                * Opposite of isDisplayed.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isNotDisplayed(checkFxsDisplayNoneClass?: boolean): Promise<boolean>;
            /**
                * Determine whether the element is present on the Portal.
                *
                * @returns A promise that resolves with a value that indicates whether the element is present on the Portal.
                */
            isPresent(): Promise<boolean>;
            /**
                * Determine whether the element is not present on the Portal.
                *
                * @returns A promise that resolves with a value that indicates whether the element is not present on the Portal.
                */
            isNotPresent(): Promise<boolean>;
            /**
                * Same as PortalElement.isPresent(), except this checks whether the element identified by the subLocator
                * is present, rather than the current PortalElement.
                *
                * @param {Locator} subLocator Locator for element to look for.
                * @returns A promise that resolves with a value that indicates whether the element is present on the Portal.
                */
            isElementPresent(subLocator: Locator): Promise<boolean>;
            /**
                * Checks whether the element identified by the subLocator
                * is present and displayed, rather than the current PortalElement.
                *
                * @param {Locator} subLocator Locator for element to look for.
                * @returns A promise that resolves with a value that indicates whether the element is present and displayed on the Portal.
                */
            isElementDisplayed(subLocator: Locator, checkFxsDisplayNoneClass?: boolean): Promise<boolean>;
            /**
                * Checks whether the any of the multiple elements identified by the subLocator
                * are present and displayed, rather than the current PortalElement.
                *
                * @param {Locator} subLocator Locator for element to look for.
                * @returns A promise that resolves with a value that indicates whether the element is present and displayed on the Portal.
                */
            areElementsDisplayed(subLocator: Locator, checkFxsDisplayNoneClass?: boolean): Promise<boolean>;
            /**
                * Checks whether the element identified by the subLocator
                * is not present or not displayed, rather than the current PortalElement.
                *
                * @param {Locator} subLocator Locator for element to look for.
                * @returns A promise that resolves with a value that indicates whether the element is not present or not displayed on the Portal.
                */
            isElementNotDisplayed(subLocator: Locator): Promise<boolean>;
            /**
                * Returns a value to specify whether or not the element has a given CSS class.
                *
                * @param {string} className The CSS class name.
                * @returns True if the element has the class; false otherwise.
                */
            hasClass(className: string): Promise<boolean>;
            /**
                * Gets the text content from the element.
                */
            getTextContent(): Promise<string>;
            /**
                * Attempts to find the first PortalElement using the given Locator.
                *
                * @param by Locator to use.
                * @returns element or null if not found.
                */
            tryFindElement<TPortalElement extends PortalElement<any>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }): TPortalElement;
            /**
                * Returns the base webdriver WebElements for this element.
                *
                * @returns A promise that resolves with the webdriver WebElement
                */
            getWebElements(): Promise<IBrowserElement[]>;
            ensureAccessibilityIsAxeCoreClean(options?: AccessibilityOptions): Promise<AxeAnalysis>;
            /**
                * Invokes a right click on the underlying web element.
                *
                * @returns A promise that resolves when the right click on specific location resolves.
                */
            moveMouseAndRightClick(opt_offset?: {
                    x: number;
                    y: number;
            }): Promise<void>;
            /**
                * Invokes a click on the underlying web element.
                *
                * @returns A promise that resolves when the right click on specific location resolves.
                */
            moveMouseAndLeftClick(opt_offset?: {
                    x: number;
                    y: number;
            }): Promise<void>;
            /**
                * Clicks this element with the CONTROL key pressed down.
                */
            clickWithCtrlKey(): Promise<void>;
            /**
                * Invokes the getTagName function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            getTagName(): Promise<string>;
            /**
                * Walks up the ancestor tree of the element until the specified condition satisfies.  Returns null if the condition is never satisfied after reaching the top document level
                *
                * @param condition the condition to satisfy
                */
            getAncestor(condition: (element: PortalElement) => Promise<boolean>): Promise<PortalElement>;
            /**
                * Gets the immediate parent of the element.
                */
            getParent(): PortalElement;
            /**
                * Invokes the isSelected function on the underlying web element.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isElementSelected(): Promise<boolean>;
            /**
                * Scrolls the given element into view.This method should be run before using the
                * Actions API on any W3C spec compliant browser to ensure that the objects being
                * interacted with are in the viewport.
                */
            scrollIntoView(): Promise<void>;
            /**
                * Gets the content.
                *
                * @param elementType element type.
                */
            getContent<T extends PortalElement>(elementType: {
                    new (): T;
            }): Promise<T>;
            /**
                * Gets the data bound to the specified attribute.
                *
                * @param attribute The attribute name.
                * @returns The data bound to the attribute.
                */
            getBoundData(attribute: string): Promise<string>;
            /**
                * Gets the inner HTML from the element.
                */
            getInnerHtml(): Promise<string>;
            /**
                * Gets the input value from the element.
                */
            getInputValue(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/SplashScreen' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import * as Constants from "@microsoft/azureportal-test/Constants";
    /**
        * Represents the Portal Splash screen.
        */
    export default class SplashScreen extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            clickUntrustedDialogOkButton(dialogType: Constants.SplashScreenDialogType): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/TestExtension' {
    /**
        * Represents side loaded extension.
        */
    export default interface TestExtension {
            /**
                * Extension name.
                */
            name: string;
            /**
                * Extension url.
                */
            uri: string;
            /**
                * Bitmask determining which obsolete bundles are required by the extension.
                */
            obsoleteBundlesBitmask?: number;
    }
}

declare module '@microsoft/azureportal-test/ElementArrayFinder' {
    /**
        * ------------------------------------------- START OF THIRD PARTY NOTICE -----------------------------------------
        * This file is based on or incorporates material from the projects listed below (Third Party IP).The original copyright notice and the license under which Microsoft received such Third Party IP, are set forth below.Such licenses and notices are provided for informational purposes only.Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.
        *
        * angular - protractor v3.0
        * Copyright(c) 2010- 2015 Google, Inc.
        *
        * Provided for Informational Purposes Only
        * MIT License
        *
        * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        *
        * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        *
        * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        * NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
        * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
        * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        * ----------------------------------------------- END OF THIRD PARTY NOTICE ------------------------------------------
        */
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { PortalElementOptionsType } from "@microsoft/azureportal-test/PortalElementOptions";
    import { IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    import { Dialog } from "playwright";
    import { AlertPromise } from "selenium-webdriver";
    /**
        * Represents an object to be used for operations on an array of elements.
        */
    export default class ElementArrayFinder<TPortalElement extends PortalElement<TElementOptions>, TElementOptions = never> {
            /**
                * A function that returns a list of the underlying Web Elements.
                */
            getWebElements: (wait?: boolean) => Promise<IBrowserElement[]>;
            /**
                * The locator specified when creating this ElementArrayFinder instance.
                */
            locator: Locator;
            /**
                * An array of promises which will be retrieved with then. Resolves to the latest
                *  action result, or null if no action has been called.
                */
            actionResults: any;
            /**
                * Gets an ElementArrayFinder that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @param locatorOptions optional locator. Works, when first parameter, subLocatorOrElementType is an element type.
                * @returns An ElementArrayFinder that matches the specified sub locator or element type.
                */
            static all<T extends PortalElement, TElementOptions extends PortalElementOptionsType<T> = PortalElementOptionsType<T>>(subLocatorOrElementType: Locator | {
                    new (): T;
            }, locatorOptions?: TElementOptions): ElementArrayFinder<T>;
            /**
                * Gets a PortalElement that matches the specified sub locator or element type.
                *
                * @param subLocatorOrElementType The sub locator or element type.
                * @returns A PortalElement that matches the specified sub locator or element type.
                */
            static element<T extends PortalElement>(subLocatorOrElementType: Locator | {
                    new (): T;
            }): T;
            /**
                * Creates a new instance of this class.
                *
                * @param options The options used to create the new instance.
                * @param options.getWebElements A function that returns a list of the underlying Web Elements.
                * @param options.locator The locator specified when creating this ElementArrayFinder instance.
                * @param options.elementType The type of PortalElement that this ElementArrayFinder can produce.
                * @param options.actionResults An array of promises which will be retrieved with then. Resolves to the latest
                *  action result, or null if no action has been called.
                * @param options.frameId The id of the iframe that contains the web elements.
                */
            constructor(options?: {
                    getWebElements?: (wait?: boolean) => Promise<IBrowserElement[]>;
                    locator?: Locator;
                    elementType?: {
                            new (elementArrayFinder?: ElementArrayFinder<TPortalElement>, frameId?: string): TPortalElement;
                    };
                    actionResults?: any;
                    frameId?: string;
            });
            /**
                * Returns a new ElementArrayFinder which would contain the children elements found (and could also be empty).
                *
                * @param locatorOrElementType The sublocator or the type of element from which the sublocator will be extracted.
                * @param locatorOptions optional locator. Works, when first parameter, locatorOrElementType is an element type.
                * @returns A new ElementArrayFinder.
                */
            all<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(locatorOrElementType: Locator | {
                    new (elementArrayFinder?: ElementArrayFinder<TPortalElement>): TPortalElement;
            }, locatorOptions?: TElementOptions): ElementArrayFinder<TPortalElement, TElementOptions>;
            /**
                * Applies a filter function to each element within the ElementArrayFinder. This does not actually retrieve
                *      the underlying list of elements, so it can be used in page objects.
                *
                * @param filterFn Filter function that will test if an element should be returned. filterFn can either
                *      return a boolean or a promise that resolves to a boolean.
                * @returns A ElementArrayFinder that represents an array of elements that satisfy the filter function.
                */
            filter(filterFn: (portalElement: TPortalElement, index: number) => Promise<any>): ElementArrayFinder<TPortalElement>;
            /**
                * Determines whether the specified function returns true for any element within the ElementArrayFinder.
                *
                * @param fn Function that will be tested. fn can either return a boolean or a promise that resolves to a boolean.
                * @returns A promise that resolves with a value that determines if the function returned true for any element within the ElementArrayFinder.
                */
            some(fn: (portalElement: TPortalElement, index: number) => Promise<any>): Promise<boolean>;
            /**
                * Gets an element within the ElementArrayFinder by index. The index starts at 0.
                * Negative indices are wrapped (i.e. -i means ith element from last)
                * This does not actually retrieve the underlying element.
                *
                * @param {number} index Element index.
                * @returns The PortalElement that represents the element at the given index.
                */
            get(index: number | Promise<any>): TPortalElement;
            /**
                * Get the first matching element for the ElementArrayFinder. This does not actually retrieve the underlying element.
                *
                * @returns The PortalElement that represents the first matching element.
                */
            first(): TPortalElement;
            /**
                * Gets the only matching element for the ElementArrayFinder.
                *
                * @returns The PortalElement if there is only a single matching element found, otherwise null.
                */
            singleOrDefault(): Promise<TPortalElement>;
            /**
                * Returns a PortalElement representation of this ElementArrayFinder. It ensures
                * that the ElementArrayFinder resolves to one and only one underlying element.
                *
                * @returns A PortalElement representation.
                */
            toPortalElement(): TPortalElement;
            /**
                * Counts the number of elements represented by the ElementArrayFinder.
                *
                * @returns A promise which resolves to the number of elements matching the locator.
                */
            count(): Promise<number>;
            /**
                * Represents the ElementArrayFinder as an array of PortalElements.
                *
                * @returns A promise which resolves to a list of PortalElements specified by the locator.
                */
            asPortalElements(): Promise<TPortalElement[]>;
            /**
                * Retrieves the elements represented by the ElementArrayFinder. The input
                * function is passed to the resulting promise, which resolves to an
                * array of PortalElements.
                *
                * @param fn Function passed to the resulting promise.
                * @param errorFn Error function.
                * @returns A promise which will resolve to an array of ElementFinders represented by the ElementArrayFinder.
                */
            then<U>(fn: (portalElements: TPortalElement[]) => U | Promise<U>, errorFn?: (error: any) => any): Promise<U>;
            /**
                * Calls the input function on each PortalElement represented by the ElementArrayFinder.
                *
                * @param fn Input function.
                */
            each(fn: (portalElement: TPortalElement, index: number) => any): Promise<void>;
            /**
                * Applies a map function to each element within the ElementArrayFinder. The
                * callback receives the PortalElement as the first argument and the index as
                * a second arg.
                *
                * @param mapFn Map function that will be applied to each element.
                * @returns A promise that resolves to an array of values returned by the map function.
                */
            map(mapFn: (portalElement: TPortalElement, index: number) => any): Promise<any[]>;
            /**
                * Invokes the click function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            click(dialogCb?: (dialog: Dialog | AlertPromise) => Promise<void>): Promise<void[]>;
            /**
                * Invokes a right click on the underlying web elements.
                *
                * @returns A promise that resolves when the right click resolves.
                */
            rightClick(): Promise<void[]>;
            /**
                * Invokes the getAttribute function on the underlying web elements.
                *
                * @param {string} attributeName The attribute to retrieve.
                * @returns A promise that resolves when the invoked function resolves.
                */
            getAttribute(attributeName: string): Promise<string[]>;
            /**
                * Invokes the getCssValue function on the underlying web elements.
                *
                * @param {string} propertyName The attribute to retrieve.
                * @returns A promise that resolves when the invoked function resolves.
                */
            getCssValue(propertyName: string): Promise<string[]>;
            /**
                * Invokes the sendKeys function on the underlying web elements.
                *
                * @param {string} var_args The text to send.
                * @returns A promise that resolves when the invoked function resolves.
                */
            sendKeys(...var_args: string[]): Promise<void[]>;
            /**
                * Schedules a command to clear the value of this element.
                *
                * @returns A promise that will be resolved when the element has been cleared.
                */
            clear(): Promise<void[]>;
            /**
                * Invokes the getText function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            getText(): Promise<string[]>;
            /**
                * Invokes the getTagName function on the underlying web elements.
                *
                *  @returns A promise that resolves when the invoked function resolves
                */
            getTagName(): Promise<string[]>;
            /**
                * Invokes the getSize function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            getSize(): Promise<{
                    width: number;
                    height: number;
            }[]>;
            /**
                * Invokes the getLocation function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            getLocation(): Promise<{
                    x: number;
                    y: number;
            }[]>;
            /**
                * Invokes the isDisplayed function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isDisplayed(): Promise<boolean[]>;
            /**
                * Invokes the isEnabled function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isEnabled(): Promise<boolean[]>;
            /**
                * Move the mouse pointer to specified location and right click.
                *
                * @returns A promise that resolves when mouse moves resolves.
                */
            moveMouseAndRightClick(opt_offset?: {
                    x: number;
                    y: number;
            }): Promise<void[]>;
            /**
                * Move the mouse pointer to specified location and click.
                *
                * @returns A promise that resolves when mouse moves resolves.
                */
            moveMouseAndLeftClick(opt_offset?: {
                    x: number;
                    y: number;
            }): Promise<void[]>;
            /**
                * Invokes the isSelected function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            isSelected(): Promise<boolean[]>;
            /**
                * Invokes the getInputValue function on the underlying web elements.
                *
                * @returns A promise that resolves when the invoked function resolves.
                */
            getInputValue(): Promise<string[]>;
    }
}

declare module '@microsoft/azureportal-test/StartBoard' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Tile from "@microsoft/azureportal-test/Parts/Tile";
    import { Part } from "@microsoft/azureportal-test/Parts";
    import DashboardHeader from "@microsoft/azureportal-test/Dashboard/DashboardHeader";
    import DashboardFilters from "@microsoft/azureportal-test/Dashboard/DashboardFilters";
    import { Button } from "@microsoft/azureportal-test/Controls";
    /**
        * Represents the Portal StartBoard.
        */
    export default class StartBoard extends PortalElement {
            /**
                * Represents the array of tiles currently pinned to the StartBoard.
                */
            tiles: ElementArrayFinder<Tile, never>;
            /**
                * Gets the "Add tiles" button.
                */
            addTilesButton: Button;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets all the parts contained in this blade.
                */
            getParts(): Promise<Part[]>;
            /**
                * Gets the Tile for provided title.
                *
                * @param title title of the tile.
                * @returns A Tile.
                */
            getTileByText(title: string): Promise<Tile>;
            /**
                * Finds the only tile that is of the specified type and has the specified title.
                *
                * @param {T} elementType The part type required.
                * @param {string} title The title.
                * @param {function} predicate The predicate callback to test the tile.
                * @param {string} additionalErrorMessage Extra error message string to append to the error for WaitUntil.
                * @param {boolean} showDashboard Show the StartBoard first if hidden
                * @param {number} timeout The optional timeout (uses default timeout if not specified).
                * @returns A Tile with the specified type and title.
                */
            findSingleTileByTitleAndPredicate<T extends Part>(elementType: {
                    new (): T;
            }, title: string, predicate: (element: T) => Promise<boolean>, additionalErrorMessage?: string, showDashboard?: boolean, timeout?: number): Promise<T>;
            /**
                * Enters the organize mode.
                *
                * @returns a promise when the portal enters in OrganizeMode.
                */
            enterOrganizeMode(): Promise<void>;
            /**
                * Waits until all tiles on startboard are loaded. If the tiles have not finished loading after the specified timeout is reached, an error is thrown.
                *
                * @param {number} timeout The time, in milliseconds, to wait for the tiles to load.
                * @returns A promise that resolves when all tiles are loaded.
                */
            waitForAllTilesLoaded(timeout?: number): Promise<void>;
            /**
                * Enters organize mode and resets the dashboard and exits organize mode
                *
                * @returns A promise that resolves when reset is complete
                */
            reset(): Promise<void>;
            enterOrganizeModeUsingContextMenu(): Promise<void>;
            /**
                * Exits organize mode
                *
                * @param {boolean} skipSave If true, skips saving the dashboard.
                * @returns A promise that resolves when organize mode exits
                */
            exitOrganizeMode(skipSave?: boolean): Promise<void>;
            /**
                * Saves the dashboard.
                *
                * @returns A promise that resolves when the dashboard is saved
                */
            saveDashboard(): Promise<void>;
            /**
                * Finds the only part that is of the specified type and has the specified title.
                *
                * @param {T} elementType The type of the part that is expected to open.
                * @param {string} title The title of part.
                * @param {boolean} show Show the StartBoard first if hidden.
                * @param {number} timeout The optional timeout (uses default timeout if not specified).
                * @returns a part if a single part is found or undefined if no part is found.
                * @throws error if more then one part is found.
                */
            findSinglePartByTitle<T extends Part>(elementType: {
                    new (): T;
            }, title: string, show?: boolean, timeout?: number): Promise<T>;
            /**
                * Finds the only tile that is of the specified type and has the specified title.
                *
                * @param {T} elementType The part type required.
                * @param {string} title The title.
                * @param {function} predicate The predicate callback to test the tile.
                * @param {string} additionalErrorMessage Extra error message string to append to the error for WaitUntil.
                * @param {boolean} showDashboard Show the StartBoard first if hidden
                * @param {number} timeout The optional timeout (uses default timeout if not specified).
                * @returns A Tile with the specified type and title.
                */
            findSinglePartByTitleAndPredicate<T extends Part>(elementType: {
                    new (): T;
            }, title: string, predicate: (element: T) => Promise<boolean>, additionalErrorMessage?: string, showDashboard?: boolean, timeout?: number): Promise<T>;
            /**
                * Gets the DashboardHeader.
                *
                * @param {number} timeout The optional timeout (uses default timeout if not specified).
                */
            getDashboardHeader(timeout?: number): Promise<DashboardHeader>;
            /**
                * Finds the only part that is of the specified type and has the specified AssetName.
                *
                * @param {T} elementType The type of the part that is expected to open.
                * @param {string} assetName the assetName.
                * @param {boolean} show Show the StartBoard first if hidden.
                * @returns a part if a single part is found or undefined if no part is found.
                * @throws error if more than one part is found.
                */
            findSinglePartByAssetName<T extends Part>(elementType: {
                    new (): T;
            }, assetName: string, show?: boolean): Promise<T>;
            /**
                * Check if the StartBoard is visible.
                *
                * @returns Promise which resolves visibility of StartBoard.
                */
            isVisible(): Promise<boolean>;
            /**
                * Show the StartBoard.
                *
                * @returns Promise which resolves when StartBoard is visible.
                */
            show(): Promise<void>;
            /**
                * Get all parts from StartBoard.
                *
                * @returns Promise which resolves parts from StartBoard.
                */
            parts(): Promise<Part[]>;
            /**
                * Unpin all parts from dashboard.
                *
                * @param exceptions Array of parts (by text) to leave pinned to the dashboard.
                */
            unpinAllParts(exceptions?: string[]): Promise<boolean>;
            /**
                * Adds part from tile gallery to startboard.
                *
                * @param galleryPartTitle Title of the part in tile gallery.
                * @param dashboardPartTitle Title of the part in dashboard.
                */
            addGalleryPart(galleryPartTitle: string, dashboardPartTitle: string): Promise<void>;
            /**
                * Wait until all parts are loaded.
                *
                * @param {number} timeout Timeout to wait till all parts to be loaded.
                * @returns Promise which resolves when all parts are loaded.
                */
            waitUntilAllPartsAreLoaded(timeout?: number): Promise<void>;
            /**
                * Check if StartBoard is not found.
                *
                * @returns Promise which resolves to true if StartBoard is not found. False otherwise.
                */
            isNotFound(): Promise<boolean>;
            /**
                * Check if StartBoard is found.
                *
                * @returns Promise which resolves to true if StartBoard is found. False otherwise.
                */
            isFound(): Promise<boolean>;
            /**
                * Gets the Dashboard Filter Collection.
                */
            dashboardFilters(): Promise<DashboardFilters>;
            /**
                * Finds the only part that is of the specified type and has content that starts with the specified text.
                *
                * @param elementType The part type required.
                * @param startsWith The startswith text.
                * @param show Show the StartBoard first if hidden.
                * @returns a promise that resolves with a Part with the specified type and content.
                */
            findSinglePartWhereContentStartsWith<T extends Part>(elementType: {
                    new (): T;
            }, startsWith: string, show?: boolean): Promise<T>;
    }
}

declare module '@microsoft/azureportal-test/TopBar/TopBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { SettingsFlyout } from "@microsoft/azureportal-test/Settings";
    import StartBoard from "@microsoft/azureportal-test/StartBoard";
    import Button from "@microsoft/azureportal-test/Controls/Button";
    /**
        * Represents the Top bar.
        */
    export default class TopBar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the View Dashboard button.
                */
            viewDashboardButton(): Promise<Button>;
            /**
                * Gets the Save Dashboard button.
                */
            saveDashboardButton(): Promise<Button>;
            /**
                * Gets the Discard Dashboard button.
                *
                * @returns Promise which resolves to discard button.
                */
            discardDashboardButton(): Promise<Button>;
            /**
                * Clicks View Dashboard button.
                */
            viewDashboard(): Promise<void>;
            /**
                * Clicks Save Dashboard button.
                */
            saveDashboard(): Promise<void>;
            /**
                * Clicks Discard Dashboard button.
                *
                * @returns Promise which resolves when discard button click is done.
                */
            discardDashboard(): Promise<void>;
            /**
                * Returns exit organize mode button.
                *
                * @returns Promise which resolves to exit organize mode button.
                */
            exitOrganizeModeButton(): Promise<Button>;
            /**
                * Gets the unread notification count.
                *
                * @returns the count
                */
            getUnreadNotificationsCount(): Promise<number>;
            /**
                * Gets hamburger button.
                */
            getSideBarToggleButton(): Promise<PortalElement>;
            /**
                * Clicks the Directory and Subscriptions menu on the setting flyout.
                */
            clickDirectoryAndSubscriptions(): Promise<void>;
            /**
                *  Clicks the Notifications menu on the top bar.
                */
            clickNotifications(): Promise<void>;
            /**
                *  Clicks the Settings menu on the top bar.
                *
                * @returns Promise that resolves when settings button click is done.
                */
            clickSettings(): Promise<void>;
            /**
                * Clicks the Help button on the top bar.
                *
                * @returns Promise that resolves when the help button click is done.
                */
            clickHelp(): Promise<void>;
            /**
                * Opens the directory settings UX for the current Portal session.
                */
            openDirectorySettings(): Promise<SettingsFlyout>;
            /**
                * Opens the directories area of portal settings.
                *
                * @returns the settings element.
                * @deprecated Use `openDirectorySettings` instead.
                */
            openDirectoryPane(): Promise<SettingsFlyout>;
            /**
                * Shows the StartBoard
                *
                * @returns A StartBoard object
                */
            showStartBoard(): Promise<StartBoard>;
            /**
                * Checks if startboard is visible
                *
                * @returns True, if visible, otherwise false.
                */
            isStartBoardVisible(): Promise<boolean>;
            /**
                * Clicks the Start Button
                */
            clickStartButton(): Promise<void>;
            haveViewDashboardButton(): Promise<boolean>;
            haveSaveDashboardButton(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/CtrlAltDOperations' {
    /**
        * Represents ctrl+alt+D operations.
        */
    export default class CtrlAltDOperations {
            /**
                * Waits until the user settings saving operation is complete.
                *
                * @param delayUntilSaveMilliseconds time in milliseconds.
                */
            static saveSettings(delayUntilSaveMilliseconds?: number): Promise<void>;
            /**
                * Waits until the user settings clearing operation is complete.
                *
                * @param delayUntilSaveMilliseconds time in milliseconds.
                * @returns A promise that resolves when the clear settings operation is done.
                */
            static clearSettings(delayUntilSaveMilliseconds?: number): Promise<void>;
            /**
                * Opens debug hub by performing browser operation
                */
            static openDebugHub(): Promise<void>;
            /**
                * Close debug box using Ctrl+Alt+D
                *
                * @returns Promise when debug box is closed.
                */
            static closeDebugBox(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/ErrorPage' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents the Portal ErrorPage.
        */
    export default class ErrorPage extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the Try again link.
                */
            getTryAgainLink(): Promise<PortalElement>;
            /**
                * Gets the Sign out link.
                */
            getSignOutLink(): Promise<PortalElement>;
            /**
                * Gets the Show directories link.
                */
            showDirectoriesLink(): Promise<PortalElement>;
            /**
                * Gets the error message.
                */
            getMessage(): Promise<PortalElement>;
            /**
                * Gets the AAD error code.
                */
            getAadCode(): Promise<PortalElement>;
            /**
                * Gets the AAD error message.
                */
            getAadMessage(): Promise<PortalElement>;
            /**
                * Gets the Learn More link.
                */
            getLearnMoreLink(): Promise<PortalElement>;
            /**
                * Waits for the portal signout sequence to complete
                */
            waitForSignOut(): Promise<unknown>;
            /**
                * Navigates to the error page
                *
                * @param webDriver The web driver.
                * @param portalUrl The url to the portal
                * @returns The error page
                */
            static navigateToErrorPage(portalUrl: string, errorAction?: string): Promise<ErrorPage>;
    }
}

declare module '@microsoft/azureportal-test/Lens' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    /**
        * Represents a Lens.
        */
    export default class Lens extends PortalElement {
            readonly titleClassName = "fxs-lens-title";
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            title(): Promise<string>;
            /**
                * Gets the Part by provided title and type.
                *
                * @param {string} elementType The type of the part that is expected to open.
                * @param {string} title the title of part.
                * @returns A part if a single part is found or undefined if no part is found
                * @throws Error if more then one part is found
                */
            findSinglePartByTitle<T extends Part>(elementType: {
                    new (): T;
            }, title: string): Promise<T>;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/BladeActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        *  Defines the attributes of a blade's action bar.
        */
    export default class BladeActionBar extends ActionBar {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * The select button.
                */
            selectButton: ActionBarButton;
            /**
                *  Clicks the OK button in the blade action bar.
                */
            clickOk(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/CoBrandPage' {
    import { Locator } from "@microsoft/azureportal-test/Locators";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents the Portal Co branding Page.
        */
    export default class CoBrandPage extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the Try again link.
                */
            hasVSOnlineBackground(): Promise<boolean>;
            /**
                * Gets the Get help link.
                */
            hasPortalBackground(): Promise<boolean>;
            /**
                * Gets the Sign out link.
                */
            linksContainer(): Promise<PortalElement<never>>;
            /**
                * Navigates to the co branding page
                *
                * @param portalUrl The url to the portal</param>
                * <returns>The Co Brand page</returns>
                */
            static navigateToCoBrandPage(portalUrl: string, market?: string, callbackContext?: string, wait?: boolean): Promise<CoBrandPage>;
    }
}

declare module '@microsoft/azureportal-test/BrowserAutomation' {
    import { BrowserAutomationType } from "@microsoft/azureportal-test/BrowserAutomationType";
    import { IBrowserAutomation } from "@microsoft/azureportal-test/IBrowserAutomation";
    import { PortalPlaywright } from "@microsoft/azureportal-test/PortalPlaywright";
    import { PortalWebDriver } from "@microsoft/azureportal-test/PortalWebDriver";
    import { Page, BrowserContext, Browser, ElementHandle } from "playwright";
    import * as webdriver from "selenium-webdriver";
    export type PlaywrightPage = Page;
    export type PlaywrightContext = BrowserContext;
    export type PlaywrightBrowser = Browser;
    export type PlaywrightElementHandle = ElementHandle;
    export type WebDriverBrowser = webdriver.WebDriver;
    export type WebDriverElementHandle = webdriver.WebElement;
    /**
        * Function to use when in need to switch between automation frameworks. Calls a helper function that does the driver initialization
        *
        * @param {BrowserAutomationType} type The type of automation framework to use
        * @param {boolean} quitPrevious Flag to whether or not previously initialized driver should quit
        * @returns A promise that resolves when the quit operation is done.
        */
    export function setAutomation(type: BrowserAutomationType, quitPrevious?: boolean): Promise<void>;
    /**
        * This is a shim used to bridge gaps where there is no good way to implement a common interface/function between webdriver and playwright asynchronous actions
        *
        * @param {Promise<T>} webdriverCb The webdriver specific implementation of the asynchronous action
        * @param {Promise<T>} playwrightCb The playwright specific implementation of the asynchronous action
        * @returns A promise that resolves with the given type.
        */
    export function runAutomation<T>(webdriverCb: (wd: PortalWebDriver) => Promise<T>, playwrightCb: (pd: PortalPlaywright) => Promise<T>): Promise<T>;
    /**
        * This is a shim used to bridge gaps where there is no good way to implement a common interface/function between webdriver and playwright actions
        *
        * @param {T} webdriverCb The webdriver specific implementation of the action
        * @param {T} playwrightCb The playwright specific implementation of the action
        * @returns The given type.
        */
    export function runAutomationSync<T>(webdriverCb: (wd: PortalWebDriver) => T, playwrightCb: (pd: PortalPlaywright) => T): T;
    export function getBrowser(): IBrowserAutomation;
}

declare module '@microsoft/azureportal-test/PlaywrightKeys' {
    export const NULL = "";
    export const CANCEL = "Cancel";
    export const HELP = "Help";
    export const BACK_SPACE = "Backspace";
    export const TAB = "Tab";
    export const CLEAR = "Clear";
    export const RETURN = "Enter";
    export const ENTER = "Enter";
    export const SHIFT = "Shift";
    export const CONTROL = "Control";
    export const ALT = "Alt";
    export const PAUSE = "Pause";
    export const ESCAPE = "Escape";
    export const SPACE = " ";
    export const PAGE_UP = "PageUp";
    export const PAGE_DOWN = "PageDown";
    export const END = "End";
    export const HOME = "Home";
    export const ARROW_LEFT = "ArrowLeft";
    export const LEFT = "ArrowLeft";
    export const ARROW_UP = "ArrowUp";
    export const UP = "ArrowUp";
    export const ARROW_RIGHT = "ArrowRight";
    export const RIGHT = "ArrowRight";
    export const ARROW_DOWN = "ArrowDown";
    export const DOWN = "ArrowDown";
    export const INSERT = "Insert";
    export const DELETE = "Delete";
    export const SEMICOLON = ";";
    export const EQUALS = "=";
    export const NUMPAD0 = "0";
    export const NUMPAD1 = "1";
    export const NUMPAD2 = "2";
    export const NUMPAD3 = "3";
    export const NUMPAD4 = "4";
    export const NUMPAD5 = "5";
    export const NUMPAD6 = "6";
    export const NUMPAD7 = "7";
    export const NUMPAD8 = "8";
    export const NUMPAD9 = "9";
    export const MULTIPLY = "Multiply";
    export const ADD = "Add";
    export const SEPARATOR = "Separator";
    export const SUBTRACT = "Subtract";
    export const DECIMAL = "Decimal";
    export const DIVIDE = "Divide";
    export const F1 = "F1";
    export const F2 = "F2";
    export const F3 = "F3";
    export const F4 = "F4";
    export const F5 = "F5";
    export const F6 = "F6";
    export const F7 = "F7";
    export const F8 = "F8";
    export const F9 = "F9";
    export const F10 = "F10";
    export const F11 = "F11";
    export const F12 = "F12";
    export const COMMAND = "Meta";
    export const META = "Meta";
}

declare module '@microsoft/azureportal-test/ExpectedConditions' {
    /**
        * ------------------------------------------- START OF THIRD PARTY NOTICE -----------------------------------------
        * This file is based on or incorporates material from the projects listed below (Third Party IP).The original copyright notice and the license under which Microsoft received such Third Party IP, are set forth below.Such licenses and notices are provided for informational purposes only.Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.Microsoft reserves all other rights not expressly granted under this agreement, whether by implication, estoppel or otherwise.
        *
        * angular - protractor v3.0
        * Copyright(c) 2010- 2015 Google, Inc.
        *
        * Provided for Informational Purposes Only
        * MIT License
        *
        * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the Software), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        *
        * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        *
        * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
        * NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
        * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
        * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        * ----------------------------------------------- END OF THIRD PARTY NOTICE ------------------------------------------
        */
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * An expectation for checking that an element is present on the DOM
        * of a page. This does not necessarily mean that the element is visible.
        *
        * @param {PortalElement} portalElement The element to check.
        * @returns A promise representing whether the element is present.
        */
    export function isPresent(portalElement: PortalElement): () => Promise<boolean>;
    /**
        * An expectation for checking that an element is not present on the DOM
        * of a page.
        *
        * @param {PortalElement} portalElement The element to check.
        * @returns A promise representing whether the element is not present.
        */
    export function isNotPresent(portalElement: PortalElement): () => Promise<boolean>;
    /**
        * An expectation for checking that an element is visible
        * of a page.
        *
        * @param {PortalElement} portalElement The element to check.
        * @returns A promise representing whether the element is visible
        */
    export function isDisplayed(portalElement: PortalElement): () => Promise<boolean>;
    /**
        * An expectation for checking that an element is either invisible or not
        * present on the DOM.
        *
        * @param {PortalElement} portalElement The element to check.
        * @returns A promise representing whether the element is invisible.
        */
    export function isNotDisplayed(portalElement: PortalElement): () => Promise<boolean>;
    /**
        * An expectation for checking that the specified attribute has the specified value in an element.
        *
        * @param {PortalElement} portalElement The element to check.
        * @param {string} attributeName The name of the attribute.
        * @param {string} attributeValue The value of the attribute.
        * @returns A promise representing whether the specified attribute has the specified value in the element.
        */
    export function hasAttributeValue(portalElement: PortalElement, attributeName: string, attributeValue: string): () => Promise<boolean>;
    /**
        * An expectation for checking that the specified attribute does not have the specified value in an element.
        *
        * @param {PortalElement} portalElement The element to check.
        * @param {string} attributeName The name of the attribute.
        * @param {string} attributeValue The value of the attribute.
        * @returns A promise representing whether the specified attribute does not have the specified value in the element.
        */
    export function doesNotHaveAttributeValue(portalElement: PortalElement, attributeName: string, attributeValue: string): () => Promise<boolean>;
}

declare module '@microsoft/azureportal-test/Search' {
    import SearchMenu from "@microsoft/azureportal-test/Search/SearchMenu";
    import SearchResult from "@microsoft/azureportal-test/Search/SearchResult";
    export { SearchMenu, SearchResult };
}

declare module '@microsoft/azureportal-test/Dashboard' {
    import DashboardHeader from "@microsoft/azureportal-test/Dashboard/DashboardHeader";
    import DashboardPicker from "@microsoft/azureportal-test/Dashboard/DashboardPicker";
    import DashboardSharePane from "@microsoft/azureportal-test/Dashboard/DashboardSharePane";
    import DashboardPinPane from "@microsoft/azureportal-test/Dashboard/DashboardPinPane";
    import DashboardFilterPill from "@microsoft/azureportal-test/Dashboard/DashboardFilterPill";
    export { DashboardHeader, DashboardPicker, DashboardSharePane, DashboardPinPane, DashboardFilterPill };
}

declare module '@microsoft/azureportal-test/Locators/By' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a collection of functions that can create locators based on different criteria.
        */
    export default class By {
            /**
                * Locates elements that have a specific class name. The returned locator
                * is equivalent to searching for elements with the CSS selector ".class".
                *
                * @param {string} value The class name to search for.
                * @returns The new locator.
                */
            static className(value: string): Locator;
            /**
                * Locates elements using a CSS selector. For browsers that do not support
                * CSS selectors, WebDriver implementations may return an
                * {@linkplain bot.Error.State.INVALID_SELECTOR invalid selector} error. An
                * implementation may, however, emulate the CSS selector API.
                *
                * @param {string} value The CSS selector to use.
                * @returns The new locator.
                */
            static css(value: string): Locator;
            /**
                * Locates elements using knockout data-bind attribute. For browsers that do not support
                * CSS selectors, WebDriver implementations may return an
                * {@linkplain bot.Error.State.INVALID_SELECTOR invalid selector} error. An
                * implementation may, however, emulate the CSS selector API.
                *
                * @param {string} value The partial data-bind attribute value to use.
                * @returns The new locator.
                */
            static dataBindContains(value: string): Locator;
            /**
                * Locates an element by its ID.
                *
                * @param {string} value The ID to search for.
                * @returns The new locator.
                */
            static id(value: string): Locator;
            /**
                * Locates an elements by evaluating a
                * {@linkplain webdriver.WebDriver#executeScript JavaScript expression}.
                * The result of this expression must be an element or list of elements.
                *
                * @param {any} script The script to execute.
                * @param {any[]} ...var_args The arguments to pass to the script.
                * @returns A new, JavaScript-based locator function.
                */
            static js(script: any, ...var_args: any[]): Locator;
            /**
                * Locates link elements whose {@linkplain webdriver.WebElement#getText visible
                * text} matches the given string.
                *
                * @param {string} value The link text to search for.
                * @returns The new locator.
                */
            static linkText(value: string): Locator;
            /**
                * Locates elements whose {@code nameAttribute} attribute has the given value.
                *
                * @param {string} value The name attribute to search for.
                * @returns The new locator.
                */
            static nameAttribute(value: string): Locator;
            /**
                * Locates link elements whose {@linkplain webdriver.WebElement#getText visible
                * text} contains the given substring.
                *
                * @param {string} value The substring to check for in a link's visible text.
                * @returns The new locator.
                */
            static partialLinkText(value: string): Locator;
            /**
                * Locates elements with a given tag name. The returned locator is
                * equivalent to using the
                * [getElementsByTagName](https://developer.mozilla.org/en-US/docs/Web/API/Element.getElementsByTagName)
                * DOM function.
                *
                * @param {string} value The substring to check for in a link's visible text.
                * @returns The new locator.
                */
            static tagName(value: string): Locator;
            /**
                * Locates elements matching a XPath selector. Care should be taken when
                * using an XPath selector with a {@link webdriver.WebElement} as WebDriver
                * will respect the context in the specified in the selector. For example,
                * given the selector {@code "//div"}, WebDriver will search from the
                * document root regardless of whether the locator was used with a
                * WebElement.
                *
                * @param {string} value The XPath selector to use.
                * @returns The new locator.
                */
            static xpath(value: string): Locator;
            /**
                * Locates elements with the given text.
                *
                * @param {string} value The text to check for.
                * @returns The new locator.
                */
            static text(value: string): Locator;
            /**
                * Locates elements that contain the given text.
                *
                * @param {string} value The text to check for.
                * @returns The new locator.
                */
            static textContains(value: string): Locator;
            /**
                * Locates elements that match the given class name starts with the given text.
                *
                * @param {string} classNamePrefix The class name prefix to search for.
                * @returns The new locator.
                */
            static classStartsWith(classNamePrefix: string): Locator;
            /**
                * Locates elements that match the given class name and text.
                *
                * @param {string} className The class name to search for.
                * @param {string} text The text to check for.
                * @returns The new locator.
                */
            static classAndText(className: string, text: string): Locator;
            /**
                * Locates elements that match the given class name and has a descendent with matching text.
                *
                * @param {string} className The class name to search for.
                * @param {string} text The text to check for.
                * @returns The new locator.
                */
            static classAndDescendentText(className: string, text: string): Locator;
            /**
                * Locates elements that match the given class name and the text starts with a prefix.
                *
                * @param {string} className The class name to search for.
                * @param {string} text The text to check for.
                * @returns The new locator.
                */
            static classAndTextStartsWith(className: string, text: string): Locator;
            /**
                * Locates elements that match all the specified locators. The returned locator will find the element(s) that match the last of the provided locators.
                *
                * @param {Locator[]} ...values The locators to search for.
                * @returns The new locator.
                */
            static chained(...values: Locator[]): Locator;
            /**
                * Locates elements that match all the specified locators. The returned locator will find the element(s) that match the first of the provided locators.
                *
                * @param {Locator[]} ...values The locators to search for.
                * @returns The new locator.
                */
            static content(...values: Locator[]): Locator;
            /**
                * The xPath prefix for current element, based on current IBrowserAutomation
                */
            static currentNodeXPathPrefix(): string;
            static tagNameAndNameAttribute(tagName: string, nameAttribute: string): Locator;
            static tagNameAndNameAttributePattern(tagName: string, nameAttribute: string): Locator;
    }
}

declare module '@microsoft/azureportal-test/Locators/ChainedLocator' {
    import { IBrowserAutomation, IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Locator composed of other locators. The findElements function returns the elements found by the
        * last locator provided in the constructor.
        */
    export default class ChainedLocator extends Locator {
            /**
                * Creates a new instance of this class.
                *
                * @param {Locator[]} innerLocators The collection of locators used to find elements.
                */
            constructor(innerLocators: Locator[]);
            /**
                * Schedules a command to search for multiple elements on the page.
                *
                * @param {IBrowserAutomation | IBrowserElement} context The object used as a starting point for the search.
                * @returns An array of the webdriver.WebElement objects that were found.
                */
            findElements(context: IBrowserAutomation | IBrowserElement, waitUntilLocated?: boolean, timeout?: number): Promise<IBrowserElement[]>;
            /**
                * Gets the string representation of this locator.
                *
                * @returns The string representation of this locator.
                */
            toString(): string;
    }
}

declare module '@microsoft/azureportal-test/Locators/ContentLocator' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { IBrowserAutomation, IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    /**
        * Represents a Locator composed of other locators. The findElements function returns the elements found by the
        * first locator provided in the constructor.
        */
    export default class ContentLocator extends Locator {
            /**
                * Creates a new instance of this class.
                *
                * @param {Locator[]} innerLocators The collection of locators used to find elements.
                */
            constructor(innerLocators: Locator[]);
            /**
                * Schedules a command to search for multiple elements on the page.
                *
                * @param {IBrowserAutomation | IBrowserElement} context The object used as a starting point for the search.
                * @returns An array of the webdriver.WebElement objects that were found.
                */
            findElements(context: IBrowserAutomation | IBrowserElement, waitUntilLocated?: boolean, timeout?: number): Promise<IBrowserElement[]>;
            /**
                * Gets the string representation of this locator.
                *
                * @returns The string representation of this locator.
                */
            toString(): string;
    }
}

declare module '@microsoft/azureportal-test/Locators/Locator' {
    import { IBrowserAutomation, IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    /**
        * Represents locator of elements on a web page.
        */
    export default abstract class Locator {
            /**
                * Schedules a command to search for multiple elements on the page.
                *
                * @param {IBrowserAutomation | IBrowserElement} context The object used as a starting point for the search.
                * @returns An array of the webdriver.WebElement objects that were found.
                */
            abstract findElements(context: IBrowserAutomation | IBrowserElement, waitUntilLocated?: boolean, timeout?: number): Promise<IBrowserElement[]>;
            /**
                * Gets the string representation of this locator.
                *
                * @returns The string representation of this locator.
                */
            abstract toString(): string;
    }
}

declare module '@microsoft/azureportal-test/Locators/SimpleLocator' {
    import * as webdriver from "selenium-webdriver";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { IBrowserAutomation, IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    /**
        * Represents a Locator that is based on a single webdriver.Locator or webdriver.promise.Promise.
        */
    export default class SimpleLocator extends Locator {
            /**
                * Creates a new instance of this class.
                *
                * @param locator The locator strategy to use when searching for elements.
                */
            constructor(locator: webdriver.Locator | ((webDriver: webdriver.WebDriver) => webdriver.promise.Promise<any>));
            /**
                * Schedules a command to search for multiple elements on the page.
                *
                * @param {IBrowserAutomation | IBrowserElement} context The object used as a starting point for the search.
                * @returns An array of the webdriver.WebElement objects that were found.
                */
            findElements: (context: IBrowserAutomation | IBrowserElement, waitUntilLocated?: boolean, timeout?: number) => Promise<IBrowserElement[]>;
            /**
                * Gets the string representation of this locator.
                *
                * @returns The string representation of this locator.
                */
            toString(): string;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/ActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        * Represents an ActionBar.
        */
    export default class ActionBar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            protected button(options: {
                    locator: Locator;
            }): ActionBarButton;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/ActionBarButton' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a button contained in an ActionBar.
        */
    export default class ActionBarButton extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a value that indicates whether the button is enabled.
                *
                * @returns A promise that resolves with a value that indicates whether the button is enabled.
                */
            isEnabled(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/CreateActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    import CreateActionBarCheckBoxField from "@microsoft/azureportal-test/ActionBars/CreateActionBarCheckBoxField";
    import CreateActionBarFormElement from "@microsoft/azureportal-test/ActionBars/CreateActionBarFormElement";
    import CheckBoxField from "@microsoft/azureportal-test/Controls/CheckBoxField";
    /**
        * Represents a CreateActionBar.
        */
    export default class CreateActionBar extends ActionBar {
            /**
                * The create button.
                */
            createButton: ActionBarButton;
            /**
                * The pin to dashboard button.
                */
            pinToDashboardCheckbox: CreateActionBarCheckBoxField;
            /**
                * Add Startboard Part CheckBox.
                */
            addStartboardPartCheckBox: CheckBoxField;
            /**
                * Gets a field contained in this blade that matches the given options.
                *
                * @param fieldType The type of field.
                * @param options The options used to locate the field.
                * @returns An instance of the field.
                */
            field<T extends CreateActionBarFormElement>(fieldType: {
                    new (): T;
            }, options: {
                    label: string;
            }): T;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clicks the OK button in the create action bar.
                */
            clickOk(forceChecked?: boolean): Promise<void>;
            /**
                * Update the CheckBox.
                *
                * @param {boolean} check whether to update the checkbox or not.
                */
            updateCheckBox(check: boolean): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/DeleteActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        * Represents a DeleteActionBar.
        */
    export default class DeleteActionBar extends ActionBar {
            /**
                * The delete button.
                */
            deleteButton: ActionBarButton;
            /**
                * The cancel button.
                */
            cancelButton: ActionBarButton;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/FilterActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        * Represents a FilterActionBar.
        */
    export default class FilterActionBar extends ActionBar {
            /**
                * The update button.
                */
            updateButton: ActionBarButton;
            /**
                * The reset button.
                */
            resetButton: ActionBarButton;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/GenericActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        * Represents a GenericActionBar.
        */
    export default class GenericActionBar extends ActionBar {
            /**
                * The action button.
                */
            actionButton: ActionBarButton;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/PickerActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        * Represents a PickerActionBar.
        */
    export default class PickerActionBar extends ActionBar {
            /**
                * The select button.
                */
            selectButton: ActionBarButton;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                *  Clicks the OK button in the picker action bar.
                */
            clickOk(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/FormActionBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ActionBarButton from "@microsoft/azureportal-test/ActionBars/ActionBarButton";
    /**
        * Represents an FormActionBar.
        */
    export default class FormActionBar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the save button from Form Action Bar.
                *
                * @returns A Save button.
                */
            get saveButton(): ActionBarButton;
            /**
                * Gets the discard button from Form Action Bar.
                *
                * @returns A Discard button.
                */
            get discardButton(): ActionBarButton;
    }
}

declare module '@microsoft/azureportal-test/Blades/Blade' {
    import ActionBar from "@microsoft/azureportal-test/ActionBars/ActionBar";
    import CommandBarItem from "@microsoft/azureportal-test/Commands/CommandBarItem";
    import * as Constants from "@microsoft/azureportal-test/Constants";
    import CommandBar from "@microsoft/azureportal-test/Controls/CommandBar";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import Tile from "@microsoft/azureportal-test/Parts/Tile";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import BladeDialog from "@microsoft/azureportal-test/Blades/BladeDialog";
    import DefaultBladeContent from "@microsoft/azureportal-test/Blades/DefaultBladeContent";
    import { PartContainer } from "@microsoft/azureportal-test/Parts/PartContainer";
    import MessageBox from "@microsoft/azureportal-test/Controls/MessageBox";
    import { Dialog } from "playwright";
    import { AlertPromise } from "selenium-webdriver";
    /**
        * Represents a Blade.
        */
    export default class Blade extends PartContainer {
            protected bladeClass: string;
            protected titleClass: string;
            protected bladeTitleClass: string;
            protected subtitleClass: string;
            protected subtitleTextClass: string;
            protected titleContentClass: string;
            /**
                * The blade title element.
                */
            get title(): PortalElement;
            /**
                * Gets the title element displayed text.
                *
                * @returns Blade title.
                */
            titleAsync(): Promise<string>;
            /**
                * The blade subtitle element.
                */
            get subtitle(): PortalElement;
            /**
                * Gets the subtitle element text.
                *
                * @returns Blade subtitle.
                */
            subtitleAsync(): Promise<string>;
            /**
                * Gets the title element for the blade.
                */
            get titleElement(): PortalElement;
            /**
                * The blade status bar.
                */
            get statusBar(): PortalElement<any> | Promise<PortalElement<any>>;
            /**
                * The collection of tiles that belong to this blade.
                */
            get tiles(): ElementArrayFinder<Tile>;
            /**
                * The collection of command bar items that belong to this blade.
                */
            get commandBarItems(): ElementArrayFinder<CommandBarItem>;
            /**
                * Gets the subtitle element text.
                *
                * @returns Blade subtitle.
                */
            commandBarItemsAsync(): Promise<CommandBarItem[]>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets DefaultBladeContent.
                */
            defaultBladeContent: DefaultBladeContent;
            /**
                * Builds a Blade locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    title?: string;
            } | {
                    subTitle?: string;
            }): Locator;
            /**
                * Returns a value that indicates whether the Blade has a command with the specified text.
                *
                * @param {string} commandText The text of the command.
                * @returns A promise that resolves with a value that indicates whether the Blade has the specified command.
                */
            hasCommand(commandText: string): Promise<boolean>;
            /**
                * Clicks the Blade command that has the specified text.
                *
                * @param {string} commandText The text of the command.
                * @param {number} timeout? The time, in milliseconds, to wait for the command to be enabled
                * @returns A promise that resolves with this same Blade instance.
                */
            clickCommand(commandText: string, timeout?: number): Promise<Blade>;
            /**
                * Clicks the close button on the blade.
                *
                * @returns A promise that results once the close button is clicked.
                */
            clickClose(dialogCb?: (dialog: Dialog | AlertPromise) => Promise<void>): Promise<void>;
            /**
                * Clicks the pin button on the blade.
                *
                * @returns A promise that results once the pin button is clicked.
                */
            clickPin(): Promise<void>;
            /**
                * Clicks the ShareIt button on the blade.
                *
                * @returns A promise that results once the button is clicked.
                */
            clickShareIt(): Promise<void>;
            /**
                * Pins the element to dashboard.
                */
            pinToDashBoard(): Promise<void>;
            /**
                * Returns a value that indicates whether the blade has been revealed (blade may be "loading" additional data in the background)
                *
                * @returns A promise that resolves with a value that indicates whether the Blade has been revealed
                */
            isRevealed(): Promise<boolean>;
            /**
                * Returns a value that indicates whether the blade has finished loading.
                *
                * @returns A promise that resolves with a value that indicates whether the Blade has finished loading.
                */
            isLoaded(): Promise<boolean>;
            /**
                * Gets a dialog associated to this blade and that has matches the given options.
                *
                * @param options The options used to locate the dialog.
                * @returns A BladeDialog instance that matches the specified options.
                */
            dialog(options: {
                    title: string;
            }): BladeDialog;
            /**
                * Gets a Part contained in this blade that matches the given options.
                *
                * @param options The options used to locate the part.
                * @returns A Part instance that matches the specified options.
                */
            part(options: {
                    innerText?: string;
            }): Part;
            /**
                * Returns a boolean that indicates if there is an error message in this blade.
                * Typically this appears as a rain cloud
                *
                * @returns A promise that resolves to a boolean value that indicates if the error is present.
                */
            hasError(): Promise<boolean>;
            /**
                * Gets the text of the error message of a blade where blade.hasError() returns true.
                * The text retrieved is directly below the rain cloud icon.
                *
                * @returns A promise which returns a string, or null if there is no error
                */
            getErrorText(): Promise<string>;
            /**
                * Gets a field contained in this blade that matches the given options.
                *
                * @param fieldType The type of field.
                * @param options The options used to locate the field.
                * @returns An instance of the field.
                */
            field<T extends FormElement>(fieldType: {
                    new (): T;
            }, options: {
                    label: string;
                    contains?: boolean;
            }): T;
            /**
                * Waits until the blade has been revealed (blade may be "loading" additional data in the background).
                *
                * @param {number} timeout?  The time, in milliseconds, to wait for the blade to load.
                * @returns A promise that resolves with this blade instance when it has been revealed.
                */
            waitUntilRevealed(timeout?: number): Promise<Blade>;
            /**
                * Waits until the blade has finished loading.
                *
                * @param timeout  The time, in milliseconds, to wait for the blade to load.
                * @returns A promise that resolves with this blade instance when it has finished loading.
                */
            waitUntilLoaded(timeout?: number): Promise<Blade>;
            /**
                * Waits until all blade tiles are loaded. If the tiles have not finished loading after the specified timeout is reached, an error is thrown.
                *
                * @param {number} timeout The time, in milliseconds, to wait for the tiles to load.
                * @returns A promise that resolves with this blade instance when all tiles are loaded.
                */
            waitForAllTilesLoaded(timeout?: number): Promise<Blade>;
            /**
                * Waits until both the blade and all its tiles have finished loading.
                *
                * @param {number} timeout? The time, in milliseconds, to wait for the blade and tiles to load.
                * @returns  A promise that resolves with this blade instance when the blade and all tiles are loaded.
                */
            waitUntilBladeAndAllTilesLoaded(options?: number | {
                    timeout?: number;
                    postWaitDelay?: number;
            }): Promise<Blade>;
            /**
                * Gets the Tile by provided title Title.
                *
                * @returns A Tile.
                */
            getTileByText(text: string): Promise<Tile>;
            protected _hasButtons(buttons: string[], actionBar: ActionBar): Promise<boolean>;
            protected _getButton(button: string): PortalElement;
            protected _foundActionBar(actionBar: ActionBar): Promise<boolean>;
            protected _foundButtons(buttons: string[]): Promise<boolean>;
            /**
                * Gets a value indicating whether the blade is maximized or not.
                */
            isMaximized(): Promise<boolean>;
            /**
                * Gets a value indicating whether the blade is in normal state.
                */
            isMinimized(): Promise<boolean>;
            /**
                * Maximizes the blade.
                */
            maximize(): Promise<void>;
            /**
                * Restores the blade to its specified size using the context menu.
                */
            restoreUsingContextMenu(): Promise<void>;
            /**
                * Restores the blade to its specified size.
                *
                * @returns a promise that resolves after the blade is restored.
                */
            restore(): Promise<void>;
            /**
                * Gets DefaultBladeContent.
                *
                * @returns a promise that resolves with DefaultBladeContent.
                */
            getDefaultBladeContent(): Promise<DefaultBladeContent>;
            /**
                * Opens the command bar.
                */
            findCommandBar(): CommandBar;
            /**
                * Finds a MessageBox within the Command Bar of the blade.
                *
                * @param title The title of the message box to find.
                * @returns the found MessageBox.
                */
            findMessageBox(title?: string): Promise<MessageBox>;
            /**
                * Gets the blade width.
                *
                * @returns enum object of blade width.
                */
            width(): Promise<Constants.BladeWidth>;
            /**
                * Finds the blade notice header element.
                *
                * @returns the found element.
                */
            findNoticeHeader(): PortalElement;
            /**
                * Collapses the resource summary.
                *
                * @returns a promise that resolves when ResourceSUmmary is collapsed.
                */
            collapseResourceSummary(): Promise<void>;
            /**
                * Resets the layout of the blade
                *
                * @param confirmReset value to be selected by message box.
                */
            resetLayout(confirmReset?: boolean): Promise<void>;
            /**
                * Waits until the blade has no progress indicator.
                *
                * @param timeout The time to wait for the blade to load.
                * @returns The blade.
                */
            waitUntilBladeHasNoProgressIndicator(timeout?: number): Promise<Blade>;
    }
}

declare module '@microsoft/azureportal-test/Blades/BrowseResourceBlade' {
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import BrowseResourceBladeGrid from "@microsoft/azureportal-test/Blades/BrowseResourceBladeGrid";
    import BrowseResourceColumnPickerBlade from "@microsoft/azureportal-test/Blades/BrowseResourceColumnPickerBlade";
    /**
        * Represents a Blade used to browse resources.
        */
    export default class BrowseResourceBlade extends Blade {
            /**
                * The grid that shows the browse results.
                */
            grid: BrowseResourceBladeGrid;
            /**
                * Returns the text filter on the blade.
                *
                * @returns An instance of TextField class wrapped in a promise.
                */
            getTextFilter(): Promise<TextField>;
            /**
                * Filters the browse results using the specified filter.
                *
                * @param {string} filter The filter.
                * @returns A promise that resolves with this blade instance when filtered browse results are available.
                */
            filterItems(filter: string): Promise<BrowseResourceBlade>;
            /**
                * Opens the Browse Column picker blade
                *
                * @param timeout Optional timeout to wait for the columns blade to load
                * @returns A promise that resolves with the instance of the BrowseResourceColumnPickerBlade
                */
            openColumnsPickerBlade(timeout?: number): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Opens the Browse Column picker blade
                *
                * @param timeout Optional timeout to wait for the columns blade to load
                * @returns A promise that resolves with the instance of the Blade
                */
            openNewColumnsPickerBlade(timeout?: number): Promise<Blade>;
            /**
                * Returns the Text field filter on Resource blade.
                *
                * @returns The test field on the resource blade.
                */
            getFilterTextField(): TextField;
    }
}

declare module '@microsoft/azureportal-test/Blades/BrowseResourceBladeGrid' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as GridBase from "@microsoft/azureportal-test/Controls/GridBase";
    /**
        * Represents the related resources grid inside the BrowseResourceBlade.
        */
    class BrowseResourceBladeGrid extends GridBase.BaseGrid<BrowseResourceBladeGrid.Row, BrowseResourceBladeGrid.Cell, BrowseResourceBladeGrid.ColumnHeader> {
            constructor(elementArrayFinder?: ElementArrayFinder<BrowseResourceBladeGrid>);
    }
    namespace BrowseResourceBladeGrid {
            /**
                * Represents a column header in the BrowseResourceBladeGrid.
                */
            class ColumnHeader extends GridBase.BaseColumnHeader {
            }
            /**
                * Represents a cell in the BrowseResourceBladeGrid.
                */
            class Cell extends GridBase.BaseCell {
            }
            /**
                * Represents a row in the BrowseResourceBladeGrid.
                */
            class Row extends GridBase.BaseRow<BrowseResourceBladeGrid.Cell> {
                    constructor(elementArrayFinder?: ElementArrayFinder<BrowseResourceBladeGrid.Row>);
                    /**
                        * Invokes the click function on the grid row and waits for it to be activated.
                        *
                        * @returns A promise that resolves when the grid row has been activated.
                        */
                    click(): Promise<void>;
            }
    }
    export default BrowseResourceBladeGrid;
}

declare module '@microsoft/azureportal-test/Blades/CreateBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import CreateActionBar from "@microsoft/azureportal-test/ActionBars/CreateActionBar";
    /**
        * Represents and extension's Create Blade.
        */
    export default class CreateBlade extends Blade {
            /**
                * The action bar contained in the blade.
                */
            actionBar: CreateActionBar;
    }
}

declare module '@microsoft/azureportal-test/Blades/DeploymentDetailsOverviewBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    /**
        * Represents the deployment overview blade, opened after a template deployment is accepted by ARM.
        * Only use this class if your create flow support customized post-provisioning (Knockout-based create flows).
        * For all other create flows, use the DeploymentOverview class under /Views/.
        */
    export default class DeploymentDetailsOverviewBlade extends Blade {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Waits for the deployment blade to report it has completed
                *
                * @param timeout The maximum amount of time in milliseconds to wait when trying to locate elements.
                * @returns a promise that resolves when the deployment has reported Completion
                */
            waitForDeploymentCompletion(timeout?: number): Promise<void>;
            /**
                * Waits for the deployment blade to report it has failed
                *
                * @param timeout The maximum amount of time in milliseconds to wait when trying to locate elements.
                * @returns a promise that resolves when the deployment has reported failure
                */
            waitForDeploymentFailure(timeout?: number): Promise<void>;
            /**
                * Waits for the deployment blade to log details
                *
                * @param timeout The maximum amount of time in milliseconds to wait when trying to locate elements.
                * @returns a promise that resolves with deployment details logged
                */
            logDeploymentDetails(timeout?: number): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Blades/GalleryInfoCreateBlade' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents the intermediate Gallery Create Blade.
        */
    export default class GalleryInfoCreateBlade extends Blade {
            /**
                * The create button on the blade.
                */
            createButton: PortalElement;
            /**
                * Builds a Blade locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    title?: string;
            }): Locator;
    }
}

declare module '@microsoft/azureportal-test/Blades/ResourceGroupCreateBlade' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import GroupDropDownField from "@microsoft/azureportal-test/Controls/GroupDropDownField";
    import { StringMap } from "@microsoft/azureportal-test/Utils/UriBuilder";
    import { TagsByResource, ResourceGroupDropDownField } from "@microsoft/azureportal-test/Controls";
    /**
        * Represents a blade that allows creating a resource group.
        */
    export default class ResourceGroupCreateBlade extends Blade {
            /**
                * Gets the name text field.
                */
            get nameTextField(): ResourceGroupDropDownField;
            /**
                * Gets the subscription text field.
                */
            get subscriptionField(): GroupDropDownField;
            /**
                * Gets the location text field.
                */
            get locationField(): GroupDropDownField;
            /**
                * Gets the tags grid field.
                */
            get tagsGrid(): TagsByResource;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            get tags(): Promise<TagsByResource>;
            /**
                * Gets the Review + create or Create button on the blade.
                *
                * @returns A promise that resolves with the Create or Review + Create button.
                */
            createButton(): Promise<PortalElement>;
            /**
                * Gets the Next : Review + create > button on the blade.
                *
                * @returns A promise that resolves with the Next : Review + create button.
                */
            nextReviewCreateButton(): Promise<PortalElement>;
            /**
                * Gets the Next : Tags > button on the blade.
                *
                * @returns A promise that resolves with the Next : Tags button.
                */
            nextTagsButton(): Promise<PortalElement>;
            /**
                * Gets the template automation hyperlink on the blade.
                *
                * @returns The template automation hyperlink.
                */
            templateAutomationHyperlink(): Promise<PortalElement>;
            /**
                * Fills out the fields on the create resource group form.
                *
                * @param resourceGroupName The name of the resource group.
                * @param subscription The subscription that the resource group should be created in.
                * @param location The location of the resource group.
                */
            fillRequiredFields(resourceGroupName: string, subscription: string, location: string): Promise<ResourceGroupCreateBlade>;
            /**
                * Fills out the tags field.
                *
                * @param tags The stringmap of tag names and tag values
                * @returns A promise that resolves with filled out tags field.
                */
            fillTagsField(tags: StringMap<string>): Promise<this>;
            /**
                * Gets the summary item on the review tab.
                *
                * @param className The name of the HTML element class.
                * @param text The text within the HTML element.
                * @returns A promise that resolves with the Tags text.
                */
            getSummaryItem(className: string, text: string): Promise<PortalElement>;
    }
}

declare module '@microsoft/azureportal-test/Blades/MoveResourcesBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import GenericActionBar from "@microsoft/azureportal-test/ActionBars/GenericActionBar";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a blade used to move resources to a new resource group.
        */
    export default class MoveResourcesBlade extends Blade {
            /**
                * The action bar contained in the blade.
                */
            actionBar: GenericActionBar;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Starts a move operation using the specified options.
                *
                * @param options The options used to populate the blade.
                * @returns A promise that resolves when the move operation has started.
                */
            startMove(options: {
                    currentResourceGroup: string;
                    targetResourceGroup: string;
                    createNewGroup?: boolean;
                    subscriptionName?: string;
                    relatedResources?: string[];
                    timeout?: number;
            }): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/MenuBlade' {
    import MenuBladeItem, { OverviewMenuItem } from "@microsoft/azureportal-test/Controls/MenuBlade/MenuBladeItem";
    import Menu from "@microsoft/azureportal-test/Controls/Menu";
    import CompositionBlade from "@microsoft/azureportal-test/Blades/CompositionBlade";
    /**
        * Represents a Resource Menu Blade.
        */
    export default class MenuBlade extends CompositionBlade {
            protected bladeClass: string;
            /**
                * Gets the specified menu item.
                *
                * @param title The title of the menu item.
                * @param comparer The method used to compare menu items to text, the default behavior is to check whether the menu item text string contains the title string.
                * @returns The menu item.
                */
            getMenuItem(title: string, comparer?: (menuBladeItem: MenuBladeItem, value: string) => Promise<boolean>): Promise<MenuBladeItem>;
            /**
                * Gets the menu of the menu blade.
                */
            getMenu(): Promise<Menu>;
            /**
                * Checks if the specified menu item is present in menu.
                *
                * @param title {string}: tiltle of Menu Item
                * @returns A promise that resolves when menu item found.
                */
            hasMenuItem(title: string): Promise<boolean>;
            /**
                * Opens a menu item in the right contents.
                *
                * @param parentBlade The parent blade associated to the menu blade.
                * @param menuItemTitle The title for the menu item to open.
                * @param waitForTilesToLoad Optional boolean true (default) to wait for the parts to load, else false.
                * @param comparer The method used to compare menu items to text, the default behavior is to check whether the menu item text string contains the title string.
                * @returns the menublade that opens up or null if parentBlade is not provided.
                */
            openMenuItem(menuItemTitle: string, parentBlade?: string, waitForTilesToLoad?: boolean, comparer?: (menuBladeItem: MenuBladeItem, value: string) => Promise<boolean>): Promise<MenuBlade>;
            get overviewMenuItem(): MenuBladeItem;
            /**
                * Gets the overview menu item.
                *
                *  @returns The overview menu item.
                */
            getOverviewItem(): Promise<OverviewMenuItem>;
            /**
                * Opens the overview item in the right contents
                */
            openOverviewItem(waitForPartsToLoad?: boolean): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/TabMenuBlade' {
    import TabMenuBladeItem, { TabMenuItem } from "@microsoft/azureportal-test/Controls/MenuBlade/TabMenuBladeItem";
    import TabMenu from "@microsoft/azureportal-test/Controls/TabMenu";
    import CompositionBlade from "@microsoft/azureportal-test/Blades/CompositionBlade";
    /**
        * Represents a Tab Menu Blade.
        */
    export default class TabMenuBlade extends CompositionBlade {
            protected bladeClass: string;
            /**
                * Gets the specified menu item.
                *
                * @param title The title of the menu item.
                * @param comparer The method used to compare menu items to text, the default behavior is to check whether the menu item text string contains the title string.
                * @returns The menu item.
                */
            getTabMenuItem(title: string, comparer?: (menuBladeItem: TabMenuItem, value: string) => Promise<boolean>): Promise<TabMenuBladeItem>;
            /**
                * Gets the tab menu of the tab menu blade.
                */
            getTabMenu(): Promise<TabMenu>;
            /**
                * Opens a menu item in the right contents.
                *
                * @param menuItemTitle The title for the menu item to open.
                * @param parentBlade The parent blade associated to the tab menu blade.
                * @param waitForTilesToLoad Optional boolean true (default) to wait for the parts to load, else false.
                * @param comparer The method used to compare menu items to text, the default behavior is to check whether the menu item text string contains the title string.
                * @returns the menublade that opens up or null if parentBlade is not provided.
                */
            openTabMenuItem(menuItemTitle: string, parentBlade?: string, waitForTilesToLoad?: boolean, comparer?: (menuBladeItem: TabMenuBladeItem, value: string) => Promise<boolean>): Promise<TabMenuBlade>;
    }
}

declare module '@microsoft/azureportal-test/Blades/PickerBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import Grid from "@microsoft/azureportal-test/Controls/Grid";
    import SelectorField from "@microsoft/azureportal-test/Controls/SelectorField";
    /**
        * Represents a PickerBlade.
        */
    export default class PickerBlade extends Blade {
            /**
                * Gets the create new field.
                */
            createNewField: SelectorField;
            /**
                * Gets the blade grid.
                */
            grid: Grid;
            /**
                * Picks the specified item in the grid.
                *
                * @param {string} item The item to pick.
                * @returns A promise that resolves when the specified item has been picked.
                */
            pickItem(item: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/PropertiesBlade' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import PartProperty from "@microsoft/azureportal-test/Parts/PartProperty";
    /**
        * Represents a PropertiesBlade blade.
        */
    export default class PropertiesBlade extends Blade {
            /**
                * The collection of part properties contained in this part.
                */
            properties: ElementArrayFinder<PartProperty, never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the part property that corresponds to the specified options.
                *
                * @param options The options used to find the part property.
                */
            property(options: {
                    name: string;
            }): PartProperty;
    }
}

declare module '@microsoft/azureportal-test/Blades/QuickStartBlade' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    /**
        * Represents a QuickStart blade.
        */
    export default class QuickStartBlade extends Blade {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clicks the specified link.
                *
                * @param {string} linkText The text of the link to click.
                * @returns A promise that resolves when the link has been clicked.
                */
            clickLink(linkText: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/ResourceFilterTextField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    /**
        * Represents the text field in the BrowseResourceBlade.
        */
    export default class ResourceFilterTextField extends TextField {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Enters the specified text in the TextField.
                *
                * @param var_args The text to enter.
                * @returns A promise that resolves when the text has been entered and the ResourceTextFields ratelimit completed
                */
            sendKeys(...var_args: string[]): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/SpecPicker' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a SpecPicker.
        */
    export default class SpecPicker extends PortalElement {
            /**
                * Gets the SpecPicker code.
                */
            code: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Builds a SpecPicker locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    code?: string;
            }): Locator;
    }
}

declare module '@microsoft/azureportal-test/Blades/SpecPickerBlade' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import SpecPicker from "@microsoft/azureportal-test/Blades/SpecPicker";
    import PickerActionBar from "@microsoft/azureportal-test/ActionBars/PickerActionBar";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a SpecPickerBlade.
        */
    export default class SpecPickerBlade extends Blade {
            /**
                * The collection of specs in this blade.
                */
            specs: ElementArrayFinder<SpecPicker>;
            /**
                * The action bar contained in this blade.
                */
            actionBar: PickerActionBar;
            /**
                * Gets all the SpecPicker view Options.
                */
            allViewOptions: ElementArrayFinder<PortalElement>;
            /**
                * Picks the spec that corresponds to the specified code.
                *
                * @param {string} specCode The code associated to the spec to pick.
                * @returns A promise that resolves when the spec has been picked.
                */
            pickSpec(specCode: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/UsersBlade' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    /**
        * Represents a UsersBlade.
        */
    export default class UsersBlade extends Blade {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Blades/BladeDialog' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a Blade Dialog.
        */
    export default class BladeDialog extends PortalElement {
            /**
                * The dialog title.
                */
            title: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clicks the specified button in the dialog.
                *
                * @param {string} buttonText The text of the button to click.
                * @returns A promise that resolves when the button has been clicked.
                */
            clickButton(buttonText: string): Promise<void>;
            /**
                * Gets a field contained in this blade dialog that matches the given options.
                *
                * @param fieldType The type of field.
                * @param options The options used to locate the field.
                * @returns An instance of the field.
                */
            field<T extends FormElement>(fieldType: {
                    new (): T;
            }, options: {
                    label: string;
            }): T;
            /**
                * Builds a BladeDialog locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    title?: string;
            }): Locator;
    }
}

declare module '@microsoft/azureportal-test/Blades/BladeStatusBar' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { ContentState } from "@microsoft/azureportal-test/Blades/ContentState";
    /**
        * Represents the Status Bar in a blade.
        */
    export default class BladeStatusBar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the state of the statusBar.
                */
            getContentState(): Promise<ContentState>;
    }
}

declare module '@microsoft/azureportal-test/Blades/ContentState' {
    /**
        * Represents the state of the content in a Part or a Blade.
        */
    export enum ContentState {
            /**
                * No content state.
                */
            None = 0,
            /**
                * Success content state.
                */
            Success = 1,
            /**
                * Warning content state.
                */
            Warning = 2,
            /**
                * Error content state
                */
            Error = 3,
            /**
                * Dirty content state
                */
            Dirty = 4,
            /**
                * Info content state
                */
            Info = 5,
            /**
                * Upsell content state
                */
            Upsell = 6,
            /**
                * Complete content state
                */
            Complete = 7
    }
}

declare module '@microsoft/azureportal-test/Blades/DeleteResourceGroupBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import SimpleButton from "@microsoft/azureportal-test/Controls/SimpleButton";
    /**
        * Represents a Blade used to delete a resource group
        */
    export default class DeleteResourceGroupBlade extends Blade {
            /**
                * Gets the locator for the blade.
                */
            get locator(): Locator;
            /**
                * Confirms the delete given the resource group name.
                *
                * @param resourceGroupName The resource group name for the text editor.
                */
            confirmDelete(resourceGroupName: string): Promise<DeleteResourceGroupBlade>;
            /**
                * Clicks the delete button on the blade.
                *
                * @returns A promise that resolves with this blade instance when filtered browse results are available.
                */
            delete(): Promise<DeleteResourceGroupBlade>;
            /**
                * Clicks the cancel button on the blade.
                *
                * @returns A promise that resolves with this blade instance when filtered browse results are available.
                */
            cancel(): Promise<DeleteResourceGroupBlade>;
            /**
                * Gets the delete button on the blade.
                *
                * @returns A promise that resolves with the delete button.
                */
            getDeleteButton(): Promise<SimpleButton>;
            /**
                * Gets the cancel button on the blade.
                *
                * @returns A promise that resolves with the cancel button.
                */
            getCancelButton(): Promise<SimpleButton>;
    }
}

declare module '@microsoft/azureportal-test/Blades/AllResourcesBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { Grid, DataGrid, ResourceFilter } from "@microsoft/azureportal-test/Controls";
    export default class AllResourcesBlade extends Blade {
            get locator(): Locator;
            /**
                * Returns The Subscription Summary Element.
                */
            getSubscriptionSummaryLink(): Promise<PortalElement>;
            /**
                * Returns the grid on AllResourcesBlade
                *
                * @returns an instance of Grid class wrapped in a promise
                */
            getAllResourcesBladeGrid(): Promise<Grid>;
            /**
                * Returns the data grid on AllResourcesBlade
                *
                * @returns an instance of Grid class wrapped in a promise
                */
            getAllResourcesBladeDataGrid(): Promise<DataGrid>;
            /**
                * Gets Resource filter on "All resources" Blade.
                *
                * @returns an instance of ResourceFilter class wrapped in a promise
                */
            getResourceFilter(): Promise<ResourceFilter>;
    }
}

declare module '@microsoft/azureportal-test/Blades/DefaultBladeContent' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { PartContainer } from "@microsoft/azureportal-test/Parts/PartContainer";
    import ResourceSummary from "@microsoft/azureportal-test/Blades/ResourceSummary";
    import { BladeWidth } from "@microsoft/azureportal-test/Constants";
    /**
        * Represents the default content of the blade.
        */
    export default class DefaultBladeContent extends PartContainer {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * finds the resource summary element.
                */
            findResourceSummary(): Promise<ResourceSummary>;
            /**
                * Gets the blade width.
                *
                * @returns enum object of blade width.
                */
            getWidth(): Promise<BladeWidth>;
    }
}

declare module '@microsoft/azureportal-test/Blades/DetailBladeContent' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ResourceSummary from "@microsoft/azureportal-test/Blades/ResourceSummary";
    import { PartContainer } from "@microsoft/azureportal-test/Parts/PartContainer";
    /**
        * Represents the detail content (Right Content) of the blade.
        */
    export default class DetailBladeContent extends PartContainer {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * finds the resource summary element.
                */
            findResourceSummary(): Promise<ResourceSummary>;
    }
}

declare module '@microsoft/azureportal-test/Blades/BrowseResourceGroupsBlade' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import BrowseResourceBlade from "@microsoft/azureportal-test/Blades/BrowseResourceBlade";
    export default class BrowseResourceGroupsBlade extends BrowseResourceBlade {
        /**
          * Gets the locator associated to this element.
          *
          * @returns A Locator instance.
          */
        get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Blades/AllResourcesArgBrowseBlade' {
    import ArgBrowseBlade from "@microsoft/azureportal-test/Blades/ArgBrowseBlade";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { StringMap } from "@microsoft/azureportal-test/Utils/UriBuilder";
    /**
        * Represents the ARG browse all resources blade in the portal.
        */
    export default class AllResourcesArgBrowseBlade extends ArgBrowseBlade {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Sets the resource types filter to the given resource types. The resource types should be fully qualified
                * resource type with the namespace (provider) ie 'microsoft.sql/server/database'.
                *
                * @param resourceTypes The fully qualified resource types for the resource type filter.
                * @param resourceTypeDisplayNameMap The map from resource type to resource type display names.
                * @returns Promise which resolves when complete.
                */
            setResourceTypesFilter(resourceTypes: string[], resourceTypeDisplayNameMap?: StringMap<string>): Promise<void>;
            /**
                * Sets the resource groups filter to the given resource groups. The resource groups should be the name of the
                * resource group.
                *
                * @param resourceGroups The resource group names for the resource group filter.
                * @returns Promise which resolves when complete.
                */
            setResourceGroupsFilter(resourceGroups: string[]): Promise<void>;
            /**
                * Sets the locations filter to the given locations. The locations should be the ARM ID of the
                * location ie, 'eastus'.
                *
                * @param locations The location IDs for the location filter.
                * @param locationDisplayNameMap The map from location IDs to location display names.
                * @returns Promise which resolves when complete.
                */
            setLocationsFilter(locations: string[], locationDisplayNameMap?: StringMap<string>): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/ResourceGroupsArgBrowseBlade' {
    import ArgBrowseBlade from "@microsoft/azureportal-test/Blades/ArgBrowseBlade";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { StringMap } from "@microsoft/azureportal-test/Utils/UriBuilder";
    /**
        * Represents the ARG browse resource groups blade in the portal.
        */
    export default class ResourceGroupsArgBrowseBlade extends ArgBrowseBlade {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Sets the locations filter to the given locations. The locations should be the ARM ID of the
                * location ie, 'eastus'.
                *
                * @param locations The location IDs for the location filter.
                * @param locationDisplayNameMap The map from location IDs to location display names.
                * @returns Promise which resolves when complete.
                */
            setLocationsFilter(locations: string[], locationDisplayNameMap?: StringMap<string>): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/ResourceArgBrowseBlade' {
    import ArgBrowseBlade from "@microsoft/azureportal-test/Blades/ArgBrowseBlade";
    import { StringMap } from "@microsoft/azureportal-test/Utils/UriBuilder";
    /**
        * Represents the ARG browse resource blade in the portal for a specific resource type.
        */
    export default class ResourceArgBrowseBlade extends ArgBrowseBlade {
            /**
                * Sets the resource groups filter to the given resource groups. The resource groups should be the name of the
                * resource group.
                *
                * @param resourceGroups The resource group names for the resource group filter.
                * @returns Promise which resolves when complete.
                */
            setResourceGroupsFilter(resourceGroups: string[]): Promise<void>;
            /**
                * Sets the locations filter to the given locations. The locations should be the ARM ID of the
                * location ie, 'eastus'.
                *
                * @param locations The location IDs for the location filter.
                * @param locationDisplayNameMap The map from location IDs to location display names.
                * @returns Promise which resolves when complete.
                */
            setLocationsFilter(locations: string[], locationDisplayNameMap?: StringMap<string>): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/MergedResourceArgBrowseBlade' {
    import ArgBrowseBlade from "@microsoft/azureportal-test/Blades/ArgBrowseBlade";
    import { StringMap } from "@microsoft/azureportal-test/Utils/UriBuilder";
    /**
        * Represents the ARG browse resource blade in the portal for a specific resource type with merged resource types.
        */
    export default class MergedResourceArgBrowseBlade extends ArgBrowseBlade {
            /**
                * Sets the resource groups filter to the given resource groups. The resource groups should be the name of the
                * resource group.
                *
                * @param resourceGroups The resource group names for the resource group filter.
                * @returns Promise which resolves when complete.
                */
            setResourceGroupsFilter(resourceGroups: string[]): Promise<void>;
            /**
                * Sets the locations filter to the given locations. The locations should be the ARM ID of the
                * location ie, 'eastus'.
                *
                * @param locations The location IDs for the location filter.
                * @returns Promise which resolves when complete.
                */
            setLocationsFilter(locations: string[], locationDisplayNameMap?: StringMap<string>): Promise<void>;
            /**
                * Sets the merged resource types filter to the given set of resource type and optional kind values.
                *
                * @param resourceTypes The resource types (type and optional kind) the set as the filter on the blade.
                * @returns Promise which resolves when the filter is set.
                */
            setMergedResourceTypesFilter(resourceTypes: {
                    type: string;
                    kind?: string;
            }[], resourceTypeDisplayNameMap?: StringMap<string>): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/ResourcePickerBlade' {
    import ArgBrowseBlade from "@microsoft/azureportal-test/Blades/ArgBrowseBlade";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents the ARG resource picker blade in the portal.
        */
    export default class ResourcePickerBlade extends ArgBrowseBlade {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Blades/ArgBrowseBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { DataGrid, Pill, TextField } from "@microsoft/azureportal-test/Controls";
    /**
        * Represents the base ARG browse filter pill in the portal.
        */
    export class BrowseFilterPill extends Pill {
            /**
                * Gets the filter (column) text for the pill.
                *
                * @returns Promise which resolves to the text for the filter.
                */
            getFilterText(): Promise<string>;
            /**
                * Gets the operator text for the pill.
                *
                * @returns Promise which resolves to the text for the operator.
                */
            getOperatorText(): Promise<string>;
            /**
                * Gets the value text for the pill.
                *
                * @returns Promise which resolves to the text for the value.
                */
            getValueText(): Promise<string>;
    }
    /**
        * Represents the base ARG browse blade in the portal.
        */
    export default abstract class ArgBrowseBlade extends Blade {
            /**
                * Returns the Subscription Summary Link element.
                *
                * @returns An instance of the PortalElement class wrapped in a promise.
                */
            getSubscriptionSummaryLink(): Promise<PortalElement>;
            /**
                * Waits for and returns the data grid on the blade.
                *
                * @returns An instance of DataGrid class wrapped in a promise.
                */
            waitForDataGrid(): Promise<DataGrid>;
            /**
                * Returns the data grid on the blade.
                *
                * @returns An instance of DataGrid class wrapped in a promise.
                */
            getDataGrid(): Promise<DataGrid>;
            /**
                * Returns the text filter on the blade.
                *
                * @returns An instance of TextField class wrapped in a promise.
                */
            getTextFilter(): Promise<TextField>;
            /**
                * Sets the text filter on the blade to the given filter.
                *
                * @param filter The given filter string.
                * @returns Promise which resolves when complete.
                */
            setTextFilter(filter: string): Promise<void>;
            /**
                * Sets the subscriptions filter to the given subscriptions. The subscriptions will be the subscriptionId from the
                * subscription resource (GUID).
                *
                * @param subscriptions The subscription IDs for the subscription filter.
                * @returns Promise which resolves when complete.
                */
            setSubscriptionsFilter(subscriptions: string[]): Promise<void>;
            /**
                * Gets the browse filter pill by the filter name.
                *
                * @param filterName The filter name for the filter pill.
                * @param index Optional index for multiple cases of the filter.
                * @returns Promise which resolves to the browse filter pill.
                */
            getFilterPill(filterName: string, index?: number): Promise<BrowseFilterPill>;
            /**
                * Sets the custom filter to the given values.
                *
                * @param filterName The filter name. The must be the display name of the column which represents this filter.
                * @param values The location IDs for the location filter.
                * @returns Promise which resolves when complete.
                */
            setFilter(filterName: string, values: string[]): Promise<void>;
            /**
                * Adds a filter pill and sets the custom filter to the given values.
                *
                * @param filterName The filter prefix. The must be the display name of the column which represents this filter.
                * @param values The location IDs for the location filter.
                * @returns Promise which resolves when complete.
                */
            addAndSetFilter(filterName: string, values: string[]): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Browse/BrowseBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import Portal from "@microsoft/azureportal-test/Portal";
    /**
        * Gets the browse blade from a given portal blade. This will determine the underlying framework and provide a
        * framework-agnostic facade.
        *
        * @param portal The portal instance.
        * @param blade The portal blade representing KO or react ARG browse.
        * @param bladeNameOverride Optional blade name override when looking for the blade.
        * @param logging Optional flag to enable logging debug information.
        * @returns Promise which resolves with the browse blade or throws an error if the blade does not represent a browse blade.
        */
    export function getBrowseFromBlade(portal: Portal, blade: Blade, bladeNameOverride?: string, logging?: boolean): Promise<BrowseBlade>;
    /**
        * Text compare operators for finding elements by text.
        */
    export const enum TextComparison {
            /**
                * Element text is equal to the expected text.
                */
            Equals = 0,
            /**
                * Element text starts with the expected text.
                */
            StartsWith = 1,
            /**
                * Element text ends with the expected text.
                */
            EndsWith = 2,
            /**
                * Element text includes with the expected text.
                */
            Includes = 3
    }
    /**
        * The browse blade is a facade to encapsulate the browse blade and provide access to blade elements in a framework
        * agnostic manner.
        */
    export interface BrowseBlade {
            /**
                * Gets the commands for the browse blade.
                */
            readonly commands: Promise<BrowseCommands>;
            /**
                * Gets the grouping for the browse.
                */
            readonly grouping: Promise<string>;
            /**
                * Sets the grouping for the browse.
                *
                * @param grouping The grouping for the browse.
                * @returns Promise which resolves when the grouping is set.
                */
            setGrouping(grouping: string): Promise<boolean>;
            /**
                * Gets the search for the browse blade.
                */
            readonly search: Promise<BrowseSearch>;
            /**
                * Gets the filters for the browse blade.
                */
            readonly filters: Promise<BrowseFilters>;
            /**
                * Gets the feature cards for the browse blade.
                */
            readonly featureCards: Promise<BrowseFeatureCards>;
            /**
                * Gets the browse grid for the browse blade.
                */
            readonly grid: Promise<BrowseGrid>;
            /**
                * Gets the pager for the browse blade.
                */
            readonly pager: Promise<BrowsePager>;
            /**
                * Launches the feedback context pane for browse.
                *
                * @returns Promise which resolves with true when the feedback link in clicked.
                */
            launchFeedback: () => Promise<boolean>;
            /**
                * Expect grouping to be in the command bar.
                */
            readonly expectGroupingInCommandBar: boolean;
    }
    /**
        * Text search options for operations of searching for UX values.
        */
    export type TextSearchOptions = {
            /**
                * Ignore the case differences between the search text and the UX text.
                */
            ignoreCase?: boolean;
            /**
                * If multiple items match the text, the index is the index into the matches.
                */
            index?: number;
            /**
                * The text comparison operator (default is equals).
                */
            textComparison?: TextComparison;
    };
    /**
        * Framework-agnostic browse commands facade with access to commands.
        */
    export interface BrowseCommands {
            /**
                * Gets the command count for the grid.
                */
            readonly commandCount: Promise<number>;
            /**
                * Gets the command items in the commands.
                */
            readonly commands: Promise<ReadonlyArray<BrowseCommand>>;
            /**
                * Gets a command by index.
                *
                * @param index The index of the command in the grid.
                * @returns Promise which resolves to the command, throws an error if the command index in not valid.
                */
            getCommand(index: number): Promise<BrowseCommand>;
            /**
                * Gets a command by text.
                *
                * @param commandText The text to find in the command.
                * @param options The optional options for finding the command by text.
                * @returns Promise which resolves to the command, throws an error if the command in not found.
                */
            getCommandByText(commandText: string, options?: TextSearchOptions): Promise<BrowseCommand>;
    }
    /**
        * Framework-agnostic browse command facade with access to text and image.
        */
    export interface BrowseCommand {
            /**
                * Gets the text for the command.
                */
            readonly text: Promise<string>;
            /**
                * Gets the image for the command.
                */
            readonly image: Promise<string>;
            /**
                * Gets whether or not the command is a separator.
                */
            readonly isSeparator: Promise<boolean>;
            /**
                * Gets whether or not the command is a menu.
                */
            readonly isMenu: Promise<boolean>;
            /**
                * Opens a menu command's menu to expose the menu items.
                *
                * @returns Promise which resolves to true if the menu is open.
                */
            openMenu(): Promise<boolean>;
            /**
                * Closes a menu command's menu.
                *
                * @returns Promise which resolves to true if the menu is closed.
                */
            closeMenu(): Promise<boolean>;
            /**
                * Gets the menu's command items (if command is a menu).
                */
            readonly menuCommands: Promise<ReadonlyArray<BrowseCommand>>;
            /**
                * Gets a menu command by index.
                *
                * @param index The index of the command in the grid.
                * @returns Promise which resolves to the command, throws an error if the command index in not valid.
                */
            getMenuCommand(index: number): Promise<BrowseCommand>;
            /**
                * Gets a menu command by text.
                *
                * @param commandText The text to find in the command.
                * @param options The optional options for finding the command by text.
                * @returns Promise which resolves to the command, throws an error if the command in not found.
                */
            getMenuCommandByText(commandText: string, options?: TextSearchOptions): Promise<BrowseCommand>;
            /**
                * Activates the command.
                */
            activate(): Promise<void>;
    }
    /**
        * Framework-agnostic browse search facade.
        */
    export interface BrowseSearch {
            /**
                * Gets the search term for browse.
                */
            readonly searchTerm: Promise<string>;
            /**
                * Sets the search term for browse.
                */
            setSearchTerm(searchTerm: string): Promise<boolean>;
    }
    /**
        * Framework-agnostic browse filters facade with access to filters.
        */
    export interface BrowseFilters {
            /**
                * Gets the count of browse filter items for the browse filters.
                */
            readonly filterCount: Promise<number>;
            /**
                * Gets the browse filter items for the browse filters.
                */
            readonly filters: Promise<ReadonlyArray<BrowseFilter>>;
            /**
                * Gets the browse filter by index.
                *
                * @param index The index of the browse filter.
                * @returns Promise which resolves to the browse filter, throws an error if the index in invalid.
                */
            getFilter(index: number): Promise<BrowseFilter>;
            /**
                * Gets the browse filter by column name.
                *
                * @param column The column name for the browse filter.
                * @param options The optional options for finding the filter by column name.
                * @returns Promise which resolves to the browse filter, throws an error if the column name is not found.
                */
            getFilterByColumn(column: string, options?: TextSearchOptions): Promise<BrowseFilter>;
    }
    /**
        * Framework-agnostic browse filter facade with access to column, operator and value(s).
        */
    export interface BrowseFilter {
            /**
                * The column for the browse filter.
                */
            readonly column: Promise<string>;
            /**
                * The operator for the browse filter.
                */
            readonly operator: Promise<BrowseFilterOperator>;
            /**
                * The value text for the browse filter.
                */
            readonly valueText: Promise<string>;
    }
    /**
        * Browse filter operator.
        */
    export type BrowseFilterOperator = "equals" | "does not equal" | "==" | "!=" | "contains" | "!contains" | "startswith" | "!startswith" | "endswith" | "!endswith" | /*"==" | "!=" |*/ "<" | "<=" | ">=" | ">" | "between" | "!between" | /*"==" | "!=" |*/ "before" | "after";
    /**
        * Framework-agnostic browse feature cards facade with access to cards.
        */
    export interface BrowseFeatureCards {
            /**
                * Gets the card count for the cards.
                */
            readonly cardCount: Promise<number>;
            /**
                * Gets the card items in the cards.
                */
            readonly cards: Promise<ReadonlyArray<BrowseFeatureCard>>;
            /**
                * Gets a card by index.
                *
                * @param index The index of the card in the cards.
                * @returns Promise which resolves to the card, throws an error if the card index in not valid.
                */
            getCard(index: number): Promise<BrowseFeatureCard>;
            /**
                * Gets a card by text.
                *
                * @param cardText The text to find in the card.
                * @param options The optional options for finding the card by text.
                * @returns Promise which resolves to the card, throws an error if the card in not found.
                */
            getCardByText(cardText: string, options?: TextSearchOptions): Promise<BrowseFeatureCard>;
    }
    /**
        * Framework-agnostic browse feature card facade.
        */
    export interface BrowseFeatureCard {
            /**
                * The text for the feature card (label).
                */
            readonly text: Promise<string>;
            /**
                * The image for the feature card.
                */
            readonly image: Promise<string>;
            /**
                * The count for the feature card.
                */
            readonly count: Promise<string>;
            /**
                * Activates the feature card.
                *
                * @returns Promise which resolves when the card is activated.
                */
            activate(): Promise<void>;
    }
    /**
        * Framework-agnostic browse grid facade with access to columns, rows and cells.
        */
    export interface BrowseGrid {
            /**
                * Gets the row count for the grid.
                */
            readonly rowCount: Promise<number>;
            /**
                * Gets the rows in the grid.
                */
            readonly rows: Promise<ReadonlyArray<BrowseGridRow>>;
            /**
                * Gets a row by index.
                *
                * @param index The index of the row in the grid.
                * @returns Promise which resolves to the row, throws an error if the row index in not valid.
                */
            getRow(index: number): Promise<BrowseGridRow>;
            /**
                * Gets a row by cell text.
                *
                * @param cellText The text to find in the cell.
                * @param cellIndex The cell index.
                * @param options The optional options for finding the row by cell text.
                * @returns Promise which resolves to the row, throws an error if the row in not found.
                */
            getRowByCellText(cellText: string, cellIndex: number, options?: TextSearchOptions): Promise<BrowseGridRow>;
            /**
                * Gets the column count for the grid.
                */
            readonly columnCount: Promise<number>;
            /**
                * Gets the columns for the grid.
                */
            readonly columns: Promise<ReadonlyArray<BrowseGridColumn>>;
            /**
                * Gets the column by index.
                *
                * @param index The column index.
                * @returns Promise which resolves to the column, throws error if index is invalid.
                */
            getColumn(index: number): Promise<BrowseGridColumn>;
            /**
                * Gets the column by label.
                *
                * @param label The column label.
                * @param options The optional opens for finding the column by label.
                * @returns Promise which resolves to the column, throws error if the column label is not found.
                */
            getColumnByLabel(label: string, options?: TextSearchOptions): Promise<BrowseGridColumn>;
            /**
                * Gets the current column sorting for the browse.
                */
            readonly sorting: Promise<ReadonlyArray<BrowseColumnSort>>;
            /**
                * Sets the column sorting for the browse.
                *
                * @param sorting The column sorting for the browse.
                * @returns Promise which resolves when the sorting is set.
                */
            setSorting(sorting: ReadonlyArray<BrowseColumnSort>): Promise<void>;
    }
    /**
        * Browse column sort.
        */
    export interface BrowseColumnSort {
            /**
                * The column for the sort.
                */
            readonly column: string;
            /**
                * The direction for the sort.
                */
            readonly direction: BrowseSortDirection;
    }
    /**
        * Sort direction for browse grid.
        */
    export const enum BrowseSortDirection {
            /**
                * Sort column in ascending direction.
                */
            Ascending = 0,
            /**
                * Sort column in descending direction.
                */
            Descending = 1
    }
    /**
        * Framework-agnostic browse grid column facade with access to label.
        */
    export interface BrowseGridColumn {
            /**
                * Gets the label for the column.
                */
            readonly label: Promise<string>;
    }
    /**
        * Framework-agnostic browse grid row facade with access to cells.
        */
    export interface BrowseGridRow {
            /**
                * Gets the cell count for the browse row.
                */
            readonly cellCount: Promise<number>;
            /**
                * Gets the cells in the grid row.
                */
            readonly cells: Promise<ReadonlyArray<BrowseGridCell>>;
            /**
                * Gets a cell by index.
                *
                * @param index The index of the cell in the grid row.
                * @returns Promise which resolves to the cell, throws an error if the cell index in not valid.
                */
            getCell(index: number): Promise<BrowseGridCell>;
            /**
                * Gets a cell by text.
                *
                * @param cellText The text to find in the cell.
                * @param options The optional options for finding the cell by cell text.
                * @returns Promise which resolves to the cell, throws an error if the cell in not found.
                */
            getCellByText(cellText: string, options?: TextSearchOptions): Promise<BrowseGridCell>;
            /**
                * Selects the row.
                *
                * @returns Promise which resolves when row is selected.
                */
            select(): Promise<void>;
            /**
                * Unselects the row.
                *
                * @returns Promise which resolves when row is unselected.
                */
            unselect(): Promise<void>;
    }
    /**
        * Framework-agnostic browse grid cell facade with access to cell image and text.
        */
    export interface BrowseGridCell {
            /**
                * Gets the text for the grid cell.
                */
            readonly text: Promise<string>;
            /**
                * Gets the image for the grid cell.
                */
            readonly image: Promise<string>;
            /**
                * Activates the cell if there is a link.
                *
                * @returns Promise which resolves when the cell is activated, throws an error if cell is not activatable.
                */
            activate(): Promise<void>;
            /**
                * Executes an item in a context menu for the cell.
                *
                * @param itemText The item text for the menu item.
                * @returns A promise which resolves when the item is clicked.
                */
            executeContextMenu(itemText: string): Promise<void>;
    }
    /**
        * Framework-agnostic browse pager facade with access to page, total record count.
        */
    export interface BrowsePager {
            /**
                * Gets the page size for the pager.
                */
            readonly pageSize: Promise<number>;
            /**
                * Gets the page count for the pager.
                */
            readonly pageCount: Promise<number>;
            /**
                * Gets the page for the pager.
                */
            readonly page: Promise<number>;
            /**
                * Gets the record count for the pager.
                */
            readonly recordCount: Promise<number>;
    }
}

declare module '@microsoft/azureportal-test/ContextPane/ContextPane' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a context pane.
        */
    export default class ContextPane extends PortalElement {
            static readonly contextPaneRightClass = "fxs-portal-contextpane-right";
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Checks whether the element is visible or not.
                *
                * @returns a promise that resolves with a boolean value.
                */
            isVisible(): Promise<boolean>;
            /**
                * Gets a value indicating whether this instance has content.
                */
            hasContent(): Promise<boolean>;
            /**
                * Checks whether this instance is in loading state.
                *
                * @returns A promise that resolves to the boolean that determines whether context Pane is Loading
                */
            isLoading(): Promise<boolean>;
            /**
                * Gets the title of the context pane.
                */
            getTitle(): Promise<string>;
            /**
                * Closes the context pane.
                *
                * @returns A promise that will resolve after closing the context pane.
                */
            close(): Promise<void>;
            /**
                * Checks whether context pane has 'fxs-portal-contextpane-right' class.
                *
                * @returns Boolean signifying if the context pane has the class.
                */
            hasContextPaneRightClass(): Promise<boolean>;
            /**
                * Gets a value indicating whether the context pane is opened.
                */
            isOpened(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/AccessHotSpot' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import HotSpot from "@microsoft/azureportal-test/Controls/HotSpot";
    /**
        * Represents an Access HotSpot.
        */
    export default class AccessHotSpot extends HotSpot {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/AsyncFileUpload' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a file upload field.
        */
    export default class AsyncFileUpload extends FormElement {
            /**
                * The input element.
                */
            input: PortalElement<never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the current value of the AsyncFileUpload
                *
                * @returns A promise that will resolve with the current value of the AsyncFileUpload
                */
            value(): Promise<string>;
            /**
                * Sends file content to AsyncFileUpload.
                *
                * @param var_args The text to enter.
                * @returns A promise that resolves when the file conent has been sent.
                */
            sendKeys(...var_args: string[]): Promise<void>;
            /**
                * Schedules a command to clear the value of this element.
                *
                * @returns A promise that will be resolved when the element has been cleared.
                */
            clear(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Button' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    interface ButtonBuildLocatorOptions {
            text: string;
    }
    /**
        * Represents a button contained in an ActionBar.
        */
    export default class Button extends PortalElement<ButtonBuildLocatorOptions> {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            buildLocator(options: ButtonBuildLocatorOptions): Locator;
            /**
                * Returns a value that indicates whether the button is enabled.
                *
                * @returns A promise that resolves with a value that indicates whether the button is enabled.
                */
            isEnabled(): Promise<boolean>;
    }
    export {};
}

declare module '@microsoft/azureportal-test/Controls/CheckBoxField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a Checkbox field.
        */
    export default class CheckBoxField extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clicks the checkbox.
                *
                * @returns A promise that resolves when the checkbox has been clicked.
                */
            click(): Promise<void>;
            /**
                * determines if the checkbox is currently checked
                *
                * @returns A promise that resolves with a true/false result if the checkbox is currently checked
                */
            isChecked(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/CopyableLabel' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a CopyableLabel.
        */
    export default class CopyableLabel extends FormElement {
            /**
                * The input element.
                */
            input: PortalElement<never>;
            /**
                * The copy button element.
                */
            copyButton: PortalElement<never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the current value of the CopyableLabel
                *
                * @returns A promise that will resolve with the current value of the CopyableLabel
                */
            value(): Promise<string>;
            /**
                * Enters the specified text in the CopyableLabel.
                *
                * @param var_args The text to enter.
                * @returns A promise that resolves when the text has been entered.
                */
            sendKeys(...var_args: string[]): Promise<void>;
            /**
                * Schedules a command to clear the value of this element.
                *
                * @returns A promise that will be resolved when the element has been cleared.
                */
            clear(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/CreatorAndSelectorField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a CreatorAndSelector field.
        */
    export default class CreatorAndSelectorField extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Opens the associated picker by clicking on this field.
                *
                * @returns A promise that resolves when the the field has been clicked.
                */
            openPicker(): Promise<void>;
            /**
                * Clicks the Create New link on this field.
                *
                * @returns A promise that resolves when the Create New link has been clicked.
                */
            clickCreateNew(): Promise<void>;
            /**
                * Enters a new value in the creator TextField.
                *
                * @param var_args Text to send to the TextField.
                * @returns A promise that resolves with this CreatorAndSelectorField instance
                * when the text has been entered in the creator TextField.
                */
            enterNewValue(...var_args: string[]): Promise<CreatorAndSelectorField>;
    }
}

declare module '@microsoft/azureportal-test/Controls/CreateComboBoxField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents an CreatorComboBoxField field.
        */
    export default class CreateComboBoxField extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Selects the specified option.
                *
                * @param {string} optionText The text of the option to select.
                * @returns A promise that resolves when the option has been selected.
                */
            selectOption(optionText: string, timeout?: number): Promise<void>;
            /**
                * Sets the first text field in the create section
                *
                * @param {string} value the value of the text to input in the text control
                * @param {number} [timeout] optional timeout to wait for the CreateComboBoxField to be displayed
                * @returns {Promise<void>} A promise that resolves when the value has been set
                */
            setCreateValue(value: string, timeout?: number): Promise<void>;
            /**
                * Gets the first text fields value in the create section
                *
                * @param {number} [timeout] optional timeout to wait for the CreateComboBoxField to be displayed
                * @returns {Promise<string>} the value of the text from the create field
                */
            getCreateValue(timeout?: number): Promise<string>;
            /**
                * Gets the dropdown fields value in the use existing section
                *
                * @param {number} [timeout] optional timeout to wait for the CreateComboBoxField to be displayed
                * @returns {Promise<string>} the value of the text from the create field
                */
            getDropdownValue(timeout?: number): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/DropDownField' {
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import DropDownFieldOption from "@microsoft/azureportal-test/Controls/DropDownFieldOption";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    /**
        * Represents a DropDown field.
        */
    export default class DropDownField extends FormElement {
            /**
                * The collection of options that belong to this dropdown field.
                */
            options: ElementArrayFinder<DropDownFieldOption>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Selects the specified option.
                *
                * @param {string} optionText The text of the option to select.
                * @returns A promise that resolves when the option has been selected.
                */
            selectOption(optionText: string): Promise<void>;
            /**
                * Gets the value of the control via reading out of.
                */
            getValue(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/DropDownFieldOption' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a DropDown field option.
        */
    export default class DropDownFieldOption extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/EditableGrid' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as Grid2Base from "@microsoft/azureportal-test/Controls/Grid2Base";
    /**
        * Represents an EditableGrid control.
        */
    class EditableGrid extends Grid2Base.BaseGrid<EditableGrid.Row, EditableGrid.Cell, EditableGrid.ColumnHeader> {
            constructor(elementArrayFinder?: ElementArrayFinder<EditableGrid>);
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    namespace EditableGrid {
            /**
                * Represents an EditableGrid column header.
                */
            class ColumnHeader extends Grid2Base.BaseColumnHeader {
            }
            /**
                * Represents an EditableGrid cell.
                */
            class Cell extends Grid2Base.BaseCell {
                    /**
                        * Gets the value of the first input in the cell.
                        */
                    getInputValue(): Promise<string>;
                    /**
                        * Sets the value of the first input in the cell.
                        */
                    setInputValue(value: string): Promise<any>;
                    /**
                        * Waits until the cell has been focused on.
                        */
                    waitUntilActive(timeout?: number): Promise<void>;
            }
            /**
                * Represents an EditableGrid row.
                */
            class Row extends Grid2Base.BaseRow<EditableGrid.Cell> {
                    constructor(elementArrayFinder?: ElementArrayFinder<EditableGrid.Row>);
                    /**
                        * Gets the text of the EditableGrid row validation footer.
                        */
                    validationErrors(): Promise<string>;
            }
    }
    export default EditableGrid;
}

declare module '@microsoft/azureportal-test/Controls/DataGrid' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as Grid2Base from "@microsoft/azureportal-test/Controls/Grid2Base";
    /**
        * Represents a DataGrid control.
        */
    class DataGrid extends Grid2Base.BaseGrid<DataGrid.Row, DataGrid.Cell, DataGrid.ColumnHeader> {
            constructor(elementArrayFinder?: ElementArrayFinder<DataGrid>);
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    namespace DataGrid {
            /**
                * Represents a DataGrid column sort direction.
                */
            export import SortDirection = Grid2Base.SortDirection;
            /**
                * Represents an DataGrid column header.
                */
            class ColumnHeader extends Grid2Base.BaseColumnHeader {
            }
            /**
                * Represents an DataGrid cell.
                */
            class Cell extends Grid2Base.BaseCell {
            }
            /**
                * Represents an DataGrid row.
                */
            class Row extends Grid2Base.BaseRow<DataGrid.Cell> {
                    constructor(elementArrayFinder?: ElementArrayFinder<DataGrid.Row>);
            }
    }
    export default DataGrid;
}

declare module '@microsoft/azureportal-test/Controls/Editor' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Editor.
        */
    export default class Editor extends PortalElement {
            /**
                * The view model property name on the editor contract
                */
            viewModelName: string;
            /**
                * The textarea element.
                */
            textarea: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Enters the specified text in the Editor.
                *
                * @param var_args The text to enter.
                * @returns A promise that resolves when the text has been entered.
                */
            sendKeys(...var_args: string[]): Promise<void>;
            /**
                * Gets the current content of the Editor.
                *
                * @returns A promise that will resolve with the current value of the Editor.
                */
            read(): Promise<string>;
            /**
                * Sets the content of the Editor.
                *
                * @param content: The content being written
                * @returns A promise that will resolve after setting the content.
                */
            write(content: string): Promise<void>;
            /**
                * empty the content of the Editor.
                *
                * @returns A promise that will resolve after emptying the content.
                */
            empty(): Promise<void>;
            /**
                * Returns a value that determines whether the editor is disabled.
                *
                * @returns A promise that resolves to a value that determines whether the editor is disabled.
                */
            isDisabled(): Promise<boolean>;
            /**
                * Returns a value that determines whether the intellisense window appeared.
                *
                * @returns A promise that resolves to the boolean that determines whether the intellisense window appeared.
                */
            isIntellisenseUp(): Promise<boolean>;
            /**
                * Internal method used for testing purpose.
                * Returns a number of worker IFrames created by the editor.
                *
                * @returns A promise that resolves to the number of the worker IFrames.
                */
            workerIFramesCount(): Promise<number>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Essentials' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import EssentialsItem from "@microsoft/azureportal-test/Controls/EssentialsItem";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    /**
        * Represents an Essentials.
        */
    export default class Essentials extends PortalElement {
            /**
                * The essentials items.
                */
            items: ElementArrayFinder<EssentialsItem>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Count the number of all items. (MultiLine Item is counted as one)
                *
                * @returns A promise that resolves with the number of all items in the essentials.
                */
            countItems(): Promise<number>;
            /**
                * Returns a value that determines whether the essentials is disabled.
                *
                * @returns A promise that resolves to a value that determines whether the essentials is disabled.
                */
            isDisabled(): Promise<boolean>;
            /**
                * Returns a value that determines whether the essentials has ViewAll button or not.
                *
                * @returns A promise that resolves to a value that determines whether the essentials has ViewAll button or not.
                */
            hasViewAll(): Promise<boolean>;
            /**
                * Returns a PortalElement of the essentials' viewAll button.
                *
                * @returns A PortalElement of the essentials' viewAll button.
                */
            getViewAllButton(): PortalElement;
            /**
                * Returns an EssentialsItem that is found by its label text.
                *
                * @param label A label of the item.
                * @returns A promise that resolves to found EssentialsItem.
                */
            getItemByLabelText(label: string): Promise<EssentialsItem>;
            /**
                * Returns a PortalElement of matching property value.
                *
                * @param value the string to match property element value.
                * @returns A PortalElement of matching property value.
                */
            getPropertyElementByValue(value: string): Promise<PortalElement>;
            /**
                * Returns a value that determines the essentials' expanded state.
                *
                * @returns A promise that resolves to a value that determines the essentials' expanded state.
                */
            getExpandedState(): Promise<boolean>;
            /**
                * Returns the Expander element.
                *
                * @returns A PortalElement of the expander.
                */
            getExpander(): PortalElement;
    }
}

declare module '@microsoft/azureportal-test/Controls/EssentialsItem' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import EssentialsItemProperty from "@microsoft/azureportal-test/Controls/EssentialsItemProperty";
    /**
        * Represents an Essentials Item.
        */
    export default class EssentialsItem extends PortalElement {
            /**
                * The essentials item properties.
                */
            properties: ElementArrayFinder<EssentialsItemProperty>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the item label text.
                *
                * @returns A promise that resolves with the label text of the item.
                */
            getLabelText(): Promise<string>;
            /**
                * Gets whether the item has move resource blade or not.
                *
                * @returns A promise that resolves with whether the item has move resource blade or not.
                */
            hasMoveResource(): Promise<boolean>;
            /**
                * Gets the item's side.
                *
                * @returns A promise that resolves with the side of the item.
                */
            getSide(): Promise<string>;
            /**
                * Returns an element of matching property value.
                *
                * @param value The string to match property element value.
                * @returns An element of matching property value.
                */
            getPropertyElementByValue(value: string): Promise<EssentialsItemProperty>;
    }
}

declare module '@microsoft/azureportal-test/Controls/EssentialsItemProperty' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { ItemPropertyType as EssentialsItemPropertyType } from "@microsoft/azureportal-test/Controls/EssentialsItemPropertyType";
    /**
        * Represents an Essentials Item property.
        */
    export default class EssentialsItemProperty extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Type of the Essentials item property.
                *
                * @returns A promise that resolves the type of the essentials item property.
                */
            getType(): Promise<EssentialsItemPropertyType>;
            /**
                * Value of the Essentials item property.
                *
                * @returns A promise that resolve the value of the property.
                */
            getValue(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/EssentialsItemPropertyType' {
    /**
        * Possible types of the Essentials item property.
        */
    export const enum ItemPropertyType {
            /**
                * Text.
                */
            Text = 1,
            /**
                * Callback function.
                */
            Function = 2,
            /**
                * Hyperlink.
                */
            Link = 3
    }
}

declare module '@microsoft/azureportal-test/Controls/FilterComboField' {
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a FilterCombo field.
        */
    export default class FilterComboField extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Waits for the form element to be enabled.
                *
                * @param timeout The amount of time to wait before failing
                * @returns A promise that resolves when the form element is enabled
                */
            waitUntilEnabled(timeout?: number): Promise<void>;
            /**
                * Sets the specified option by typing in the text.
                *
                * @param {string} optionText The text of the option to set.
                * @returns A promise that resolves when the option has been set.
                */
            setOption(optionText: string): Promise<void>;
            /**
                * Selects the specified option.
                *
                * @param {string} optionText The text of the option to select.
                * @returns A promise that resolves when the option has been selected.
                */
            selectOption(optionText: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/FormElement' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import * as Constants from "@microsoft/azureportal-test/Constants";
    import ControlValidationState = Constants.ControlValidationState;
    /**
        * Represents a FormElement.
        */
    export default class FormElement extends PortalElement {
            protected readonly editedClassName = "azc-is-edited";
            /**
                * The FormElement label.
                */
            label: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the validation state of the element or its children
                *
                * @returns {ControlValidationState} the validation state if found, else none
                */
            getValidationState(): Promise<ControlValidationState>;
            /**
                * Waits until the element reaches a given validation state.
                *
                * @param validationState the validation state to wait on
                * @param timeout The amount of time to wait before failing
                * @returns {Promise<void>} promise that resolves when validationState is present
                */
            waitOnValidationState(validationState: ControlValidationState | ControlValidationState[], timeout?: number): Promise<void>;
            /**
                * Builds a FormElement locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    label?: string;
                    contains?: boolean;
            }): Locator;
            /**
                * Waits for the form element to be enabled.
                *
                * @param timeout The amount of time to wait before failing
                * @returns A promise that resolves when the form element is enabled
                */
            waitUntilEnabled(timeout?: number): Promise<void>;
            /**
                * Gets the enabled/disabled state of the form field.
                * The disabled state is actually applied to a child element of this div, and therefore we need to check for a css class instead of using the out of box selenium attribute.
                */
            isEnabled(): Promise<boolean>;
            /**
                * Gets a value indicating whether the control's value has been edited.
                */
            isEdited(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/FormSection' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a Form Section.
        */
    export default class FormSection extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a value that indicates whether the form section has been changed.
                *
                * @returns A promise that resolves with a value that indicates whether the form section has been changed.
                */
            isChanged(): Promise<boolean>;
            /**
                * Returns a value that indicates whether the form section is valid.
                *
                * @returns A promise that resolves with a value that indicates whether the form section is valid.
                */
            isValid(): Promise<boolean>;
            /**
                * Finds the specified form field.
                *
                * @param fieldType The type of form field to find.
                * @param fieldLabel The label text of the field to find.
                * @returns The found form field.
                */
            findFieldByLabel<T extends FormElement>(fieldType: {
                    new (): T;
            }, fieldLabel: string): Promise<T>;
            /**
                * Gets all the field elements within a form section
                */
            getAllFields(): Promise<PortalElement<any>[]>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Grid' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as GridBase from "@microsoft/azureportal-test/Controls/GridBase";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Generic Grid test harness that that works against Grid1 and Grid2 grids.
        */
    class Grid extends GridBase.BaseGrid<Grid.Row, Grid.Cell, Grid.ColumnHeader> {
            constructor(elementArrayFinder?: ElementArrayFinder<Grid>);
            /**
                * Selects all rows checkbox.
                *
                * @returns the selectAllRows checkbox.
                */
            get selectAllRowsCheckbox(): PortalElement;
            /**
                * Gets selected rows.
                *
                * @returns the selected rows.
                */
            selectedRows(): Promise<Grid.Row[]>;
    }
    namespace Grid {
            /**
                * Represents a Grid column header.
                */
            class ColumnHeader extends GridBase.BaseColumnHeader {
            }
            /**
                * Represents a Grid cell.
                */
            class Cell extends GridBase.BaseCell {
            }
            /**
                * Represents a Grid row.
                */
            class Row extends GridBase.BaseRow<Grid.Cell> {
                    constructor(elementArrayFinder?: ElementArrayFinder<Grid.Row>);
                    /**
                        * Selects the row.
                        */
                    select(): Promise<void>;
                    /**
                        * Unselects the row.
                        */
                    unSelect(): Promise<void>;
                    /**
                        * Row checkbox
                        */
                    get selectionCheckBox(): PortalElement;
                    /**
                        * Button displayed as triple dots -> ... at the end of the row
                        */
                    get contextMenuButton(): PortalElement;
            }
    }
    export default Grid;
}

declare module '@microsoft/azureportal-test/Controls/HotSpot' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a HotSpot.
        */
    export default class HotSpot extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a value that determines whether the hotspot is selected.
                *
                * @returns A promise that resolves to a value that determines whether the hotspot is selected.
                */
            isSelected(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/MonitorChart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a Monitor Chart v2 part.
        */
    export default class MonitorChart extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets whether the chart has data
                */
            hasData(): Promise<boolean>;
            /**
                * Gets the name of the monitor chart's first metric.
                */
            getMetric(): Promise<string>;
            /**
                * Gets the value of the monitor chart's first metric.
                */
            getValue(): Promise<string>;
            /**
                * Gets the unit of the monitor chart's first metric.
                */
            getUnit(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/OptionsGroupField' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import OptionsGroupFieldOption from "@microsoft/azureportal-test/Controls/OptionsGroupFieldOption";
    /**
        * Represents an OptionsGroup (picker) field.
        */
    export default class OptionsGroupField extends FormElement {
            /**
                * The collection of options that belong to this option picker field.
                */
            options: ElementArrayFinder<OptionsGroupFieldOption, never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the first selected option's text
                *
                * @returns a promise that resolves with the selected option's text
                */
            getTextForSelectedOption(): Promise<string>;
            /**
                * Clicks the specified option.
                *
                * @param {string} optionText The text of the option to select.
                * @returns A promise that resolves when the option has been selected.
                */
            clickOption(optionText: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/OptionsGroupFieldOption' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents an Option Group (picker) Field option.
        */
    export default class OptionsGroupFieldOption extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets whether the current option is selected or not.
                *
                * @returns A promise that resolves with whether the option is selected or not.
                */
            isSelected(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/PagedDataGrid' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as Grid2Base from "@microsoft/azureportal-test/Controls/Grid2Base";
    /**
        * Represents a PagedDataGrid control.
        */
    class PagedDataGrid extends Grid2Base.BaseGrid<PagedDataGrid.Row, PagedDataGrid.Cell, PagedDataGrid.ColumnHeader> {
            constructor(elementArrayFinder?: ElementArrayFinder<PagedDataGrid>);
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    namespace PagedDataGrid {
            /**
                * Represents a PagedDataGrid column sort direction.
                */
            export import SortDirection = Grid2Base.SortDirection;
            /**
                * Represents an PagedDataGrid column header.
                */
            class ColumnHeader extends Grid2Base.BaseColumnHeader {
            }
            /**
                * Represents an PagedDataGrid cell.
                */
            class Cell extends Grid2Base.BaseCell {
            }
            /**
                * Represents an PagedDataGrid row.
                */
            class Row extends Grid2Base.BaseRow<PagedDataGrid.Cell> {
                    constructor(elementArrayFinder?: ElementArrayFinder<PagedDataGrid.Row>);
            }
    }
    export default PagedDataGrid;
}

declare module '@microsoft/azureportal-test/Controls/PasswordField' {
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    export default class PasswordField extends TextField {
        /**
          * Root class name for the PasswordField
          */
        protected readonly rootClassName = "azc-passwordField";
    }
}

declare module '@microsoft/azureportal-test/Controls/Pill' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Pill List Item.
        */
    export default class Pill extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                *  Enters the pill's edit mode.
                */
            enterEditMode(): Promise<void>;
            /**
                * Returns true if the pill is in edit mode.
                */
            isInEditMode(): Promise<boolean>;
            /**
                * Returns the pill's delete button.
                */
            deleteButton(): PortalElement;
    }
}

declare module '@microsoft/azureportal-test/Controls/PillList' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PillListActionButton from "@microsoft/azureportal-test/Controls/PillListActionButton";
    import PillListItem from "@microsoft/azureportal-test/Controls/PillListItem";
    import PillListOverflowItem from "@microsoft/azureportal-test/Controls/PillListOverflowItem";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    /**
        * Represents a Pill List.
        */
    export default class PillList extends PortalElement {
            /**
                * The pill list items.
                */
            items: ElementArrayFinder<PillListItem>;
            /**
                * The pill list overflow item.
                */
            overflowItem: PillListOverflowItem;
            /**
                * The pill list items.
                */
            actionButtons: ElementArrayFinder<PillListActionButton>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Count the number of all items.
                *
                * @returns A promise that resolves with the number of all items in the pill list.
                */
            countItems(): Promise<number>;
            /**
                * Count the number of all action buttons.
                *
                * @returns A promise that resolves with the number of all items in the pill list.
                */
            countActionButtons(): Promise<number>;
            /**
                * Returns an PillListItem that is found by its text.
                *
                * @param value A value of the item.
                * @returns A promise that resolves to found PillListItem.
                */
            getItemByText(value: string): Promise<PillListItem>;
            /**
                * Returns an PillListActionButton that is found by its text.
                *
                * @param title A title of the item.
                * @returns A promise that resolves to found PillListActionButton.
                */
            getActionButtonByText(title: string): Promise<PillListActionButton>;
    }
}

declare module '@microsoft/azureportal-test/Controls/PillListActionButton' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Pill List Action Button.
        */
    export default class PillListActionButton extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the item title text.
                *
                * @returns A promise that resolves with the title text of the item.
                */
            getTitleText(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/PillListItem' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Pill List Item.
        */
    export default class PillListItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the item value text.
                *
                * @returns A promise that resolves with the value text of the item.
                */
            getValueText(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/PillListOverflowItem' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Pill List Overflow Item.
        */
    export default class PillListOverflowItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the item value text.
                *
                * @returns A promise that resolves with the value text of the item.
                */
            getValueText(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/QuickStartHotSpot' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import HotSpot from "@microsoft/azureportal-test/Controls/HotSpot";
    /**
        * Represents a QuickStart hotspot.
        */
    export default class QuickStartHotSpot extends HotSpot {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/RangeSlider' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a slider.
        */
    export default class RangeSlider extends FormElement {
            readonly RootClassName = "azc-rangeSliderField";
            readonly sliderEndHandleClassName = "azc-rangeSlider-end-handle";
            readonly sliderHandleClassName = "azc-slider-handle";
            readonly sliderBarClassName = "azc-slider-slider";
            readonly sliderMarkerClassName = "azc-slider-marker";
            sliderBar: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Drags the start handle to a marker on the slider
                *
                *  @param position the position to drag the start handle to.
                */
            dragEndHandleToPosition(position: number): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/SelectorField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a Selector field.
        */
    export default class SelectorField extends FormElement {
            readonly displayTextClassName = "fxc-selector-displayText";
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Opens the associated picker by clicking on this field.
                *
                * @returns A promise that resolves when the the field has been clicked.
                */
            openPicker(): Promise<void>;
            /**
                * Gets the display text.
                */
            displayText(): Promise<string>;
            /**
                * Clicks on the chevron of the selector.
                */
            click(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/SequentialDataGrid' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as Grid2Base from "@microsoft/azureportal-test/Controls/Grid2Base";
    /**
        * Represents a SequentialDataGrid control.
        */
    class SequentialDataGrid extends Grid2Base.BaseGrid<SequentialDataGrid.Row, SequentialDataGrid.Cell, SequentialDataGrid.ColumnHeader> {
            constructor(elementArrayFinder?: ElementArrayFinder<SequentialDataGrid>);
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    namespace SequentialDataGrid {
            /**
                * Represents a SequentialDataGrid column sort direction.
                */
            export import SortDirection = Grid2Base.SortDirection;
            /**
                * Represents an SequentialDataGrid column header.
                */
            class ColumnHeader extends Grid2Base.BaseColumnHeader {
            }
            /**
                * Represents an SequentialDataGrid cell.
                */
            class Cell extends Grid2Base.BaseCell {
            }
            /**
                * Represents an SequentialDataGrid row.
                */
            class Row extends Grid2Base.BaseRow<SequentialDataGrid.Cell> {
                    constructor(elementArrayFinder?: ElementArrayFinder<SequentialDataGrid.Row>);
            }
    }
    export default SequentialDataGrid;
}

declare module '@microsoft/azureportal-test/Controls/SideBar' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Menu from "@microsoft/azureportal-test/Controls/Menu";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import SideBarBrowseFlyout from "@microsoft/azureportal-test/Controls/SideBarBrowseFlyout";
    /**
        * Represents the SideBar.
        */
    export default class SideBar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Indicator if the sidebar is collapsed.
                */
            isCollapsed(): Promise<boolean>;
            /**
                * Gets the browse flyout for the sidebar.
                */
            get browseFlyout(): SideBarBrowseFlyout;
            /**
                * Checks if blade menu is hosted on sidebar.
                */
            isBladeMenuHostedOnSideBar(): Promise<boolean>;
            /**
                * Checks if the blade menu on sidebar is displayed.
                */
            isBladeMenuDisplayed(): Promise<boolean>;
            /**
                * Gets the blade menu toggle button.
                */
            get getBladeMenuToggleButton(): PortalElement;
            /**
                * Opens the browse flyout.
                */
            openBrowseFlyout(): Promise<void>;
            /**
                * Opens the sidebar. For use in sidebar flyout mode.
                */
            open(): Promise<void>;
            /**
                * Toggles the collapse state of sidebar.
                */
            toggleCollapse(): Promise<void>;
            /**
                * Gets the blade menu.
                */
            getBladeMenu(): Promise<Menu>;
            /**
                * Indicates if the sidebar is docked.
                * There are two display modes for SideBar:
                * flyout: SideBar will be hidden into a hamburger button on topbar and flyout when clicking on it.
                * docked: SideBar will be docked to the window left.
                */
            inDockedMode(): Promise<boolean>;
            /**
                * Gets a favorite item by the asset type name.
                *
                * @param assetTypeName Favorite item's asset type name.
                * @returns A promise wrapping the favorite item.
                * @throws Will throw an error if the specified fragment is not found.
                */
            getFavorite(assetTypeName: string): Promise<any>;
    }
}

declare module '@microsoft/azureportal-test/Controls/SideBarBrowseFlyout' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import SideBarBrowseFlyoutFilterInput from "@microsoft/azureportal-test/Controls/SideBarBrowseFlyoutFilterInput";
    /**
        * Represents the sidebar browse flyout.
        */
    export default class SideBarBrowseFlyout extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Toggles the detail view of the browse flyout.
                */
            toggleDetailView(): Promise<void>;
            /**
                * Switches to the specified category.
                *
                * @param categoryName The category name to switch to.
                */
            switchCategory(categoryName: string): Promise<PortalElement<any>>;
            /**
                * Gets the filter input for the browse flyout.
                */
            getFilterInput(): Promise<SideBarBrowseFlyoutFilterInput>;
            /**
                * Gets the browse flyout item having the specified text
                *
                * @param text Specified text to find
                * @returns A promise wrapping the browse flyout item
                */
            getBrowseFlyoutItem(flyoutItemText: string): Promise<PortalElement<any>>;
            /**
                * Gets the browse flyout card having the specified text
                *
                * @param text Specified text to find
                * @returns A promise wrapping the browse flyout item
                */
            getBrowseFlyoutCard(cardLabel: string): Promise<PortalElement<any>>;
            clickAllCategoryAndGetBrowseFlyoutItem(flyoutItemText: string): Promise<PortalElement<any>>;
            /**
                * Gets the count of categories on browse flyout. This count doesn't include reserved categories such as 'All', 'Favorites', 'Recents'.
                *
                * @returns A promise wrapping the count of categories on browse flyout
                */
            getCategoryCount(): Promise<number>;
            /**
                * Gets the count of categories on browse flyout including reserved categories such as 'All', 'Favorites', 'Recents'.
                *
                * @returns A promise wrapping the count of categories on browse flyout
                */
            getCategoryWithReservedCategoryCount(): Promise<number>;
            /**
                * Gets the string array of categories on browse flyout including reserved categories such as 'All', 'Favorites', 'Recents'.
                */
            getAllCategoriesWithReservedCategories(): Promise<string[]>;
            /**
                * Gets the string array of categories on browse flyout. This doesn't include reserved categories such as 'All', 'Favorites', 'Recents'.
                *
                * @returns A promise wrapping the string array of categories on browse flyout
                */
            getAllCategories(): Promise<string[]>;
            /**
                * Gets all the item names in the flyout.
                *
                * @returns A array of strings for the item names.
                */
            getAllItems(): Promise<string[]>;
            /**
                * Gets all the detail view card names in the flyout.
                *
                * @returns A array of strings for the card names.
                */
            getAllCards(): Promise<string[]>;
            /**
                * Checks if the no result view is visible in all services flyout.
                *
                * @returns Promise that resolves to a boolean. True means no result view is visible, false means it is not visible.
                */
            hasNoResult(): Promise<boolean>;
            /**
                * Gets the count of items on browse flyout
                *
                * @returns A promise wrapping the count of items on browse flyout
                */
            getItemCount(): Promise<number>;
            /**
                * Gets the count of detail view cards on browse flyout
                *
                * @returns A promise wrapping the count of cards on browse flyout
                */
            getCardCount(): Promise<number>;
            /**
                * Gets the category portal element having the specified text
                *
                * @param categoryText Specified text to find
                * @returns A promise wrapping the category portal element having the specified text
                */
            getCategory(categoryText: string): Promise<PortalElement>;
            /**
                * Gets the item matches text for the given item text.
                * Returns an empty string on error
                *
                * @param categoryText The item text to find
                * @returns The matches text for the given item.
                */
            getItemMatchesString(itemText: string): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/TextField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a TextField.
        */
    export default class TextField extends FormElement {
            /**
                * Root class name for the TextField.
                */
            protected readonly rootClassName: string;
            /**
                * The input element.
                */
            input: PortalElement<never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the current input value of the TextField
                *
                * @returns A promise that will resolve with the current value of the TextField
                */
            value(): Promise<string>;
            /**
                * Gets the placeholder value of the textbox
                */
            placeholderValue(): Promise<string>;
            /**
                * Enters the specified text in the TextField.
                *
                * @param var_args The text to enter.
                * @returns A promise that resolves when the text has been entered.
                */
            sendKeys(...var_args: string[]): Promise<void>;
            /**
                * Enters the specified text in the TextField, and validates that it has been set.
                *
                * @param text The text to enter.
                * @returns A promise that resolves when the text has been entered.
                */
            setText(text: string): Promise<void>;
            /**
                * Schedules a command to clear the value of this element.
                *
                * @returns A promise that will be resolved when the element has been cleared.
                */
            clear(): Promise<void>;
            /**
                * Sends a blur event to the textbox.
                */
            blur(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/MultiLineTextField' {
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a MultiLineTextField.
        */
    export default class MultiLineTextField extends TextField {
            /**
                * Root class name for the MultiLineTextField.
                */
            protected readonly rootClassName = "azc-multiLineTextField";
            /**
                * The input element.
                */
            input: PortalElement<never>;
    }
}

declare module '@microsoft/azureportal-test/Controls/TextBox' {
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Driver class for the TextBox portal control
        */
    export default class TextBox extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the current value of the TextField
                *
                * @returns A promise that will resolve with the current value of the TextField
                */
            value(): Promise<string>;
            /**
                * Gets the placeholder value of the textbox
                *
                * @returns A promise that will resolve with the placeholder value of the TextField
                */
            placeholderValue(): Promise<string>;
            /**
                * Enters the specified text in the TextField.
                *
                * @param var_args The text to enter.
                * @returns A promise that resolves when the text has been entered.
                */
            sendKeys(...var_args: string[]): Promise<void>;
            /**
                * Schedules a command to clear the value of this element.
                *
                * @returns A promise that will be resolved when the element has been cleared.
                */
            clear(): Promise<void>;
            /**
                * Sends a blur event to the textbox.
                */
            blur(): Promise<void>;
            /**
                * Gets the placeholder value of the TextBox
                *
                * @returns A promise that will resolve with the placeholder value of the TextBox
                */
            placeholder(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/NumericTextbox' {
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Driver class for the Numeric Text Box portal control
        */
    export default class NumericTextbox extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the current value of the NumericTextbox
                *
                * @returns A promise that will resolve with the current value of the NumericTextbox
                */
            value(): Promise<number>;
            /**
                * Gets the current value of the NumericTextbox
                *
                * @returns A promise that will resolve with the current value of the NumericTextbox
                */
            setText(text: number): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/GroupDropDownField' {
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import GroupDropDownFieldOption from "@microsoft/azureportal-test/Controls/GroupDropDownFieldOption";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    /**
        * DropDown Item options.
        */
    export interface DropDownItemOption {
            /**
                * The item text when specified as a string.
                */
            text: string;
            /**
                * The item text or htmlTemplate.
                */
            htmlText: string;
            /**
                * The item html template when specified.
                */
            htmlTemplate: string;
            /**
                * The item value.
                */
            value: string;
            /**
                * The item aria label.
                */
            ariaLabel: string;
            /**
                * The item disabled state.
                */
            disabled?: boolean;
            /**
                * The selected item override.
                */
            selectedItemOverride?: string;
    }
    /**
        * Represents a Group DropDown field.
        */
    export default class GroupDropDownField extends FormElement {
            /**
                * Root class name for the dropdown
                */
            static readonly rootClassName = "fxc-group-dropdown";
            /**
                * The collection of options that belong to this dropdown field.
                *
                * @returns The options.
                */
            get options(): ElementArrayFinder<GroupDropDownFieldOption, never>;
            /**
                * Gets the value of the control via reading out of / writing to the input.
                *
                * @returns Promise which resolves to the value.
                */
            getValue(): Promise<string>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            getOptions(): Promise<DropDownItemOption[]>;
            /**
                * Selects the first option that matches the given optionText.
                *
                * @param optionText The text of the option to select.
                * @param partial Should the option be selected with a partial match
                * @param timeout The time, in milliseconds, to wait for the dropdown to be enabled, have items and select the item (note each action is given this timeout independently so cumulative time may be longer).
                * @returns A promise that resolves when the option has been selected.
                */
            selectOptionByText(optionText: string, partial?: boolean, timeout?: number): Promise<void>;
            /**
                * Gets the selected items
                *
                * @returns An array contains the values (not text) of the selected items.
                */
            getSelectedValues(): Promise<any[]>;
            /**
                * Gets the selected item names.
                *
                * @returns a collection of strings representing the texts of the selected items. If in single select mode, returns a collection with a single text.
                */
            getSelectedNames(): Promise<string[]>;
            /**
                * Selects the specified options for this dropdown field.
                *
                * @param optionsToBeSelected List of texts of the options to be selected
                * @param leaveOpen whether to leave drop down open after selecting
                * @param partial Should the option be selected with a partial match
                * @param timeout The time, in milliseconds, to wait for the dropdown to be enabled, and select the item (note each action is given this timeout independently so cumulative time may be longer).
                * @param clearFilter Should the filter be cleared after selection
                * @returns A promise that resolves when the options have been selected.
                */
            selectOptionsByText(optionsToBeSelected: string[], leaveOpen?: boolean, partial?: boolean, timeout?: number, clearFilter?: boolean): Promise<void>;
            /**
                * Toggle "Select All" checkbox in the DropDown.
                */
            toggleSelectAll(): Promise<void>;
            /**
                * Selects the specified options for this dropdown field.
                *
                * @param {string[]} optionsToBeSelected List of texts of the options to be selected
                * @returns A promise that resolves when the options have been selected.
                */
            toggleOptionsSelectionByText(optionsToBeSelected: string[]): Promise<void>;
            /**
                * Selects option by provided index.
                *
                * @param {number} index option index to select
                * @returns A promise that resolves when the option has been selected.
                */
            selectByIndex(index: number): Promise<void>;
            /**
                * Unselects the all options in groupDropDownfield.
                */
            unselectAllOptions(): Promise<void>;
            /**
                * Checks whether drop down is open or not.
                *
                * @returns Promise which resolves to the open state.
                */
            isDropDownOpen(): Promise<boolean>;
            /**
                * Opens the drop down.
                *
                * @param timeout The time, in milliseconds, to wait for the dropdown to be enabled and open (note each action is given this timeout independently so cumulative time may be longer).
                */
            openDropDown(timeout?: number): Promise<void>;
            /**
                * Closes the drop down.
                */
            closeDropDown(): Promise<void>;
            /**
                * Gets the search text field in dropdown.
                *
                * @returns Promise which resolves to the search text field.
                */
            getDropDownSearchTextField(): Promise<PortalElement>;
    }
}

declare module '@microsoft/azureportal-test/Controls/GroupDropDownFieldOption' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a Group DropDown field option.
        */
    export default class GroupDropDownFieldOption extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/ResourceGroupDropDownField' {
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a CreatorAndSelector field.
        */
    export default class ResourceGroupDropDown extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Get the selected resource group.
                * In the old style of the control with Radio buttons, this will switch the mode to UseExisting and return the value of the dropdown.
                * In the new style of the control, this will return the value of the textbox if allowedMode is createNew, otherwise the value of the dropdown.
                *
                * @returns A promise that resolves when the resource group has been retrieved.
                */
            getSelectedResourceGroup(): Promise<string>;
            /**
                * Set the selected resource group in the dropdown.
                * This will switch the mode of the control if using the old style control with radio buttons.
                *
                * @param {string} value the value of the text to input in the dropdown control.
                * @returns A promise that resolves when the resource group has been selected.
                */
            setSelectedResourceGroup(value: string): Promise<void>;
            /**
                * Get the created resource group from the textbox or dropdown.
                * This will switch the mode of the control if using the old style control with radio buttons.
                */
            getNewResourceGroup(): Promise<string>;
            /**
                * Creates a new resource group using the resource group control.
                * This will switch the mode of the control if using the old style control with radio buttons.
                * In the old dropdown, this will switch the mode to Create New and enter the value in the textbox.
                * In the new dropdown, this will either enter the value in the textbox (mode = createNew)
                * or use the dialog to create a new dropdown option.
                *
                * @param resourceGroupName The name of the resource group to create.
                * @returns A promise that resolves when the new resource group has been selected.
                */
            setNewResourceGroup(resourceGroupName: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/List/ListView' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ListViewItem from "@microsoft/azureportal-test/Controls/List/ListViewItem";
    import ListViewGroup from "@microsoft/azureportal-test/Controls/List/ListViewGroup";
    /**
        * Driver class for the ListView portal control
        */
    export default class ListView extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets all of the rows of the group.
                */
            get groups(): ElementArrayFinder<ListViewGroup>;
            /**
                * Gets all of the rows of the group.
                */
            get items(): ElementArrayFinder<ListViewItem>;
            /**
                * Gets the specified item.
                *
                * @param identifier Specified identifier
                */
            getListViewItem(identifier: string): Promise<any>;
            /**
                * Checks if the specified menu item is present in menu.
                *
                * @param identifier Specified identifier
                */
            hasListViewItem(identifier: string): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/List/ListViewItem' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a list view item.
        */
    export default class ListViewItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Checks whether or not this element is selected.
                */
            isSelected(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/List/ListViewGroup' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ListViewItem from "@microsoft/azureportal-test/Controls/List/ListViewItem";
    /**
        * Represents a group in ListView.
        */
    export default class ListViewGroup extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets all of the rows of the group.
                */
            get listViewItems(): ElementArrayFinder<ListViewItem>;
            /**
                * Gets the header of the group.
                */
            get Header(): PortalElement;
            /**
                * Gets the specified item.
                *
                * @param identifier Specified identifier
                */
            getListViewItem(identifier: string): ListViewItem;
    }
}

declare module '@microsoft/azureportal-test/Controls/List/ListView2' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ListViewItem2 from "@microsoft/azureportal-test/Controls/List/ListViewItem2";
    /**
        * Driver class for the ListView portal control
        */
    export default class ListView2 extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets all listview items.
                */
            get items(): ElementArrayFinder<ListViewItem2>;
            /**
                * Gets all selected listview items.
                */
            getSelectedItems(): Promise<ListViewItem2[]>;
    }
}

declare module '@microsoft/azureportal-test/Controls/List/ListViewItem2' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a list view item.
        */
    export default class ListViewItem2 extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a value indicating whether or not this element is selected.
                */
            isSelected(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Toolbars/Toolbar' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ToolbarItem from "@microsoft/azureportal-test/Controls/Toolbars/ToolbarItem";
    /**
        * Driver class for the Toolbar portal control
        */
    export default class Toolbar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets all of toolbar items.
                */
            get items(): () => Promise<ToolbarItem[]>;
            /**
                * Find the toolbar item with specified text
                *
                * @param text the item to find.
                */
            findToolbarItem(text: string): Promise<ToolbarItem>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Toolbars/ToolbarItem' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    interface ToolbarItemBuildLocatorOptions {
            text: string;
    }
    /**
        * Driver class for the ToolbarItem portal control
        */
    export default class ToolbarItem extends PortalElement<ToolbarItemBuildLocatorOptions> {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            buildLocator(options: ToolbarItemBuildLocatorOptions): Locator;
            /**
                * Gets a value indicating whether the toolbar item is enabled.
                */
            isEnabled(): Promise<boolean>;
            /**
                * Gets the label text of the toolbar item.
                */
            get text(): () => Promise<string>;
    }
    export {};
}

declare module '@microsoft/azureportal-test/Controls/Recommendations' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a Recommendations.
        */
    export default class Recommendations extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets blade link
                */
            getBladeLink(): PortalElement;
            /**
                * Gets a value indicating whether it is empty experience.
                */
            isEmptyExperience(): Promise<boolean>;
            /**
                * Gets a value indicating whether it is error experience.
                */
            isErrorExperience(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/ResourceFilter' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import GroupDropDownField from "@microsoft/azureportal-test/Controls/GroupDropDownField";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    export default class ResourceFilter extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                *  Returns the SubscriptionFilter.
                *
                * @returns A promise that resolves when finds the SubscriptionFilter.
                */
            getSubscriptionFilter(): Promise<GroupDropDownField>;
            /**
                *  Returns the ResourceGroupsFilter.
                *
                * @returns A promise that resolves when finds the ResourceGroupsFilter.
                */
            getResourceGroupsFilter(): Promise<GroupDropDownField>;
            /**
                *  Returns the ResourceTypesFilter.
                *
                * @returns A promise that resolves when finds the ResourceTypesFilter.
                */
            getResourceTypesFilter(): Promise<GroupDropDownField>;
            /**
                *  Returns the LocationsFilter.
                *
                * @returns A promise that resolves when finds the LocationsFilter.
                */
            getLocationsFilter(): Promise<GroupDropDownField>;
            /**
                *  Returns the Tags Filter.
                *
                * @returns A promise that resolves when it finds the Tags Filter.
                */
            getTagsFilter(): Promise<GroupDropDownField>;
            /**
                *  Returns the TextFilter.
                *
                * @returns A promise that resolves when finds the TextFilter.
                */
            getTextFilter(): Promise<TextField>;
    }
}

declare module '@microsoft/azureportal-test/Controls/SimpleButton' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    interface ButtonBuildLocatorOptions {
            text: string;
    }
    /**
        * Represents a simple button.
        */
    export default class SimpleButton extends PortalElement<ButtonBuildLocatorOptions> {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            buildLocator(options: ButtonBuildLocatorOptions): Locator;
            /**
                * Checks if this button is enabled
                *
                * @returns True, if enabled. False, otherwise
                */
            isEnabled(): Promise<boolean>;
    }
    export {};
}

declare module '@microsoft/azureportal-test/Controls/CommandBar' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import CommandBarItem from "@microsoft/azureportal-test/Commands/CommandBarItem";
    import CommandBarMenuButton from "@microsoft/azureportal-test/Controls/CommandBarMenuButton";
    /**
        * Represents a command bar.
        */
    export default class CommandBar extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the collection of command bar items, excluding the overflow button.
                * If there are overflow commands, the overflow button will be clicked and overflow commands will also be returned.
                *
                * @returns Promise returning an array of CommandBarItem.
                */
            getItems(): Promise<CommandBarItem[]>;
            /**
                * Gets the command bar item for the given command name.
                * If there are overflow commands, the overflow button will be clicked and overflow command matching the command name will be returned.
                *
                * @param commandText Name of the command.
                * @returns Promise returning the CommandBarItem matching the given command name.
                */
            getItem(commandText: string): Promise<CommandBarItem | null | undefined>;
            /**
                * Finds the commandBar menu button with the specified command label.
                *
                * @param {string} commandLabel Text of the command to click.
                */
            findCommandBarMenuButton(commandLabel: string): Promise<CommandBarMenuButton>;
            /**
                * Finds the command with the specified command text.
                *
                * @param {string} commandText Text of the command to find.
                */
            findCommandBarItem(commandText: string): Promise<CommandBarItem>;
            /**
                * Clicks the command with the specified command text and optionally handles a message box after the command is clicked.
                *
                * @param commandText Text of the command to find.
                * @param messageBoxTitle The title of the message box to handle.  If empty, then any message box will be found.  Optional
                * @param messageBoxButtonToClick The text of the button to click in the message box that is expected to appear.  If empty, then will not handle a message box.  Optional
                */
            clickCommandBarItem(commandText: string, messageBoxTitle?: string, messageBoxButtonToClick?: string): Promise<CommandBarItem>;
    }
}

declare module '@microsoft/azureportal-test/Controls/InfoBox' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents an infobox.
        */
    export default class InfoBox extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the text of the infoBox.
                */
            infoBoxTextContent(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/ColumnChooser/ColumnChooser' {
    import EditableGrid from "@microsoft/azureportal-test/Controls/EditableGrid";
    import TextField from "@microsoft/azureportal-test/Controls/TextField";
    import GroupDropDown from "@microsoft/azureportal-test/Controls/GroupDropDownField";
    import SimpleButton from "@microsoft/azureportal-test/Controls/SimpleButton";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import { ColumnChooserType } from "@microsoft/azureportal-test/Controls/ColumnChooser/ColumnChooserType";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    export default class ColumnChooser {
            sourceGrid: EditableGrid;
            columnGrid: EditableGrid;
            filterBox: TextField;
            typeDropDown: GroupDropDown;
            addButton: SimpleButton;
            removeButton: SimpleButton;
            applyButton: SimpleButton;
            resetButton: SimpleButton;
            noSourceRowsElement: PortalElement;
            noColumnRowsElement: PortalElement;
            constructor(columnChooserBlade: Blade);
            /**
                * Waits until Grid is loaded.
                *
                * @param skipColumnCheck Optional flag to skip column checks for the new blade.
                * @returns A promise that resolves when expected column grids found.
                */
            waitUntilReady(skipColumnCheck?: boolean): Promise<void>;
            /**
                * Clicks Apply button.
                *
                * @returns A promise that resolves when ApplyButton is clicked.
                */
            clickApply(): Promise<void>;
            /**
                * Clicks Reset button.
                *
                * @returns A promise that resolves when ResetButton is clicked.
                */
            clickReset(): Promise<void>;
            /**
                * Clicks the reset to defaults command button in the new blade.
                * NOTE: NoOp for old blade - there is no reset to defaults button.
                *
                * @returns A promise that resolves when reset to defaults command button is clicked.
                */
            resetToDefaults(): Promise<void>;
            /**
                * Switch between type of Available Columns.
                * NOTE: NoOp on new blade - there is no type switching.
                *
                * @param {ColumnChooserType} type Option to be selected.
                * @returns A promise that resolves when switch between available columns..
                */
            switchToType(type: ColumnChooserType): Promise<void>;
            /**
                * Validates expected and Source Grid rows.
                * NOTE: NoOp on the new blade - there is no source grid.
                *
                * @param {number} expectedRows number of expected rows.
                * @returns A promise that resolves when Source Grid and exptected rows are same..
                */
            validateExpectedSourceRows(expectedRows: number): Promise<void>;
            /**
                * Validates expected and Source Grid rows.
                * NOTE: NoOp on the new blade - there is no source grid.
                *
                * @param {string[]} expectedRows number of expected rows.
                * @returns A promise that resolves when Source Grid and exptected rows are same..
                */
            validateExpectedSourceRowsGivenTheColumnNamesArrays(expectedRows: string[]): Promise<void>;
            /**
                * Validates expected and source Column Grid rows.
                *
                * @param {number} expectedRows : number of expected Column rows.
                * @returns A promise that resolves when source and exptected rows are same..
                */
            validateExpectedColumnRows(expectedRows: number): Promise<void>;
            /**
                * Validates expected and source Column Grid rows.
                *
                * @param {number} expectedRows : number of expected Column rows.
                * @returns A promise that resolves when source and exptected rows are same..
                */
            validateExpectedColumnRowsGivenTheColumnNamesArrays(expectedRows: string[]): Promise<void>;
            /**
                * Adds column from source grid to columns grid and moves to specified index.
                *
                * @param {string} column column name.
                * @param {number} index Move to specified index.
                * @returns A promise that resolves when column added and move to specified index.
                */
            addColumnAndMoveToIndex(column: string, index: number): Promise<void>;
            /**
                * Adds column from source grid to columns grid.
                *
                * @param column column name.
                * @returns A promise that resolves when column added.
                */
            addColumn(column: string): Promise<void>;
            /**
                * Validates expected columns on source grid and columns grid
                *
                * @param {number} propertyColumns number of property columns
                * @param {number} tagColumns number of tag columns
                * @param {number} selectedColumns number of columns that got selected
                */
            validateExpectedColumns(propertyColumns: number, tagColumns: number, selectedColumns: number): Promise<void>;
            /**
                * Validates expected columns on source grid and columns grid
                *
                * @param {string[]} propertyColumns number of property columns
                * @param {string[]} tagColumns number of tag columns
                * @param {string[]} selectedColumns number of columns that got selected
                */
            validateExpectedColumnsGivenTheColumnNamesArrays(propertyColumns: string[], tagColumns: string[], selectedColumns: string[]): Promise<void>;
            /**
                * Adds Tag column from source grid to columns grid.
                *
                * @param {string} column column name.
                * @returns A promise that resolves when column added.
                */
            addTagColumn(column: string): Promise<void>;
            /**
                * Adds new column and moves to specified index.
                *
                * @param {string} column Column to add.
                * @param {number} index on which column to be moved.
                */
            addTagColumnAndMoveToIndex(column: string, index: number): Promise<void>;
            /**
                * Removes all columns from source grid to columns grid.
                */
            removeAllColumns(): Promise<void>;
            /**
                * Removes column from source grid to columns grid.
                *
                * @param {string} column column name.
                * @returns A promise that resolves when column is removed.
                */
            removeColumn(column: string): Promise<void>;
            /**
                * Removes Tag column from source grid to columns grid.
                *
                * @param {string} column column name.
                * @returns A promise that resolves when column is removed.
                */
            removeTagColumn(column: string): Promise<void>;
            /**
                * Sets filter via filter textbox with the supplied filter text.
                * NOTE: NoOp on the new blade - there is no filter.
                *
                * @param filterText filter to apply.
                */
            setFilter(filterText: string): Promise<void>;
            /**
                * Clears the filter text box.
                * NOTE: NoOp on the new blade - there is no filter.
                */
            clearFilter(): Promise<void>;
            /**
                * Determines if there is an info box on the column chooser with the given text.
                *
                * @param expectedText The expected text for the info box.
                * @returns Promise which resolves to true if the info box is found with the text, otherwise false.
                */
            hasInfoBoxText(expectedText: string): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/ColumnChooser/ColumnChooserType' {
    export enum ColumnChooserType {
        All = 0,
        Properties = 1,
        Tags = 2
    }
}

declare module '@microsoft/azureportal-test/Controls/Menu' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    import MenuBladeItem from "@microsoft/azureportal-test/Controls/MenuBlade/MenuBladeItem";
    import { MenuGridItem } from "@microsoft/azureportal-test/Controls/MenuBlade/MenuBladeItem";
    export default class Menu extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the collection of menu items.
                *
                * @returns an array of menu items.
                */
            getMenuItems(): Promise<MenuGridItem[]>;
            /**
                * Gets the specified menu item.
                *
                * @param title The title of the menu item.
                * @param comparer The method used to compare menu items to text, the default behavior is to check whether the menu item text string contains the title string.
                * @returns The menu item.
                */
            getMenuItem(title: string, comparer?: (menuBladeItem: MenuBladeItem, value: string) => Promise<boolean>): Promise<MenuBladeItem>;
            expandAllMenuHeaders(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/SvgElement' {
    import { Locator } from "@microsoft/azureportal-test/Locators";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Web element which represents an SVG element.
        */
    export class SvgElement extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * @deprecated hasTitle getter has been deprecated. Please use instance method hasTitleAsync instead.
                */
            get hasTitle(): boolean;
            /**
                * Gets a value indicating whether the SVG has a title or not.
                */
            hasTitleAsync(): Promise<boolean>;
            /**
                * Gets the title if present.
                *
                * @returns The title marker if present else null.
                */
            getTitle(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Parts/PartProperty' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a property of a ResourceSummaryPart.
        */
    export default class PartProperty extends PortalElement {
            /**
                * The name of the property.
                */
            name: PortalElement<any>;
            /**
                * The value of the property.
                */
            value: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Builds a PartProperty locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    name?: string;
            }): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/Balloon/MessageBoxBalloon' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Balloon from "@microsoft/azureportal-test/Controls/Balloon/Balloon";
    import MessageBox from "@microsoft/azureportal-test/Controls/Dialogs/MessageBox";
    /**
        *  Represents the a message box in a balloon.
        */
    export default class MessageBoxBalloon extends Balloon {
            /**
                *  Gets the By locator used to identify elements of this class.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the MessageBox.
                */
            getMessageBox(): Promise<MessageBox>;
            /**
                * Clicks the message box button with the specified command text.
                *
                * @param {string} buttonText The text of the message box button to click.
                */
            clickButton(buttonText: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Balloon/Balloon' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        *  Represents a balloon.
        */
    export default class Balloon extends PortalElement {
            /**
                *  Gets the By locator used to identify elements of this class.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/Dialogs/MessageBox' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Button from "@microsoft/azureportal-test/Controls/Button";
    import DialogBase from "@microsoft/azureportal-test/Controls/Dialogs/DialogBase";
    /**
        *  Represents a balloon.
        */
    export default class MessageBox extends DialogBase {
            /**
                *  By locator used to identify elements of this class.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the message box title.
                */
            getTitle(): Promise<string>;
            /**
                * Clicks the message box button with the specified command text.
                *
                * @param {string} buttonText The text of the message box button to click.
                */
            clickButton(buttonText: string): Promise<void>;
            /**
                * Verifies button count.
                *
                * @param {number} count Expected button count.
                * @param filterFn filter function.
                */
            verifyButtonCount(count: number, filterFn: (element: Button) => Promise<boolean>): Promise<void>;
            /**
                * Gets a checkbox of message box confirmation secion.
                */
            clickConfirmation(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Dialogs/DialogBase' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
      *  Represents a balloon.
      */
    export default abstract class DialogBase extends PortalElement {
        abstract getTitle(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/TabList' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Gets the By locator used to identify elements of this class.
        */
    export default class TabList extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Finds the tab item with the specified command label.
                *
                * @param tabLabel Text of the tab.
                */
            switchToTab(tabLabel: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/TagsByResource' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    export interface TagItem {
            key: string;
            value: string;
            resources: string[];
    }
    /**
        * Represents the TagsByResource control.
        */
    export default class TagsByResource extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns By locator used to identify elements of this class.
                */
            get locator(): Locator;
            /**
                * Get get tags for control
                *
                * @returns tags shown in the TagsByResource control.
                */
            tags(): Promise<TagItem[]>;
            /**
                * Get errors for control
                *
                * @returns errors shown in the errors InfoBox control shown in the TagsByResource control.
                */
            errorMessages(): Promise<string>;
            /**
                * Get info message for control
                *
                * @returns content of the informational InfoBox control shown in the TagsByResource control.
                */
            infoMessages(): Promise<string>;
            /**
                * Adds a tag to the TagsByResource grid.
                *
                * @param key The tag name.
                * @param value The tag value.
                * @param resources The resources to apply the tag to.
                */
            addTag(key: string, value?: string, resources?: string[]): Promise<void>;
            /**
                * Attempt to remove a tag from the TagsByResource grid. This method will throw an <see cref="InvalidOperationException"/> if more than a single row matches the inputs provided.
                *
                * @param name The name of the tag to be removed.
                * @param value The value of the tag to be removed. Optional if there is only a single tag with the name provided.
                * @param resources The resources of the tag to be removed. Optional if the resource column is not shown or a single tag matches the name and value provided.
                */
            removeTag(name: string, value?: string, resources?: string[]): Promise<void>;
            /**
                * Returns the validation state of the control.
                *
                * @returns if control is valid
                */
            isValid(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/TagEditor' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import EditableGrid from "@microsoft/azureportal-test/Controls/EditableGrid";
    import MenuBlade from "@microsoft/azureportal-test/Blades/MenuBlade";
    export default class TagEditor {
            static readonly maximumNumberOfTagsPerResource = 50;
            constructor(tagEditorBlade: MenuBlade | Blade);
            /**
                * Waits until TagEditor is loaded. Should be called after TagEditor class is initialized.
                */
            waitUntilReady(): Promise<void>;
            /**
                * Validate expected tag count.
                *
                * @param expectedTags expected count of tags.
                */
            validateExpectedTagCount(expectedTags: number): Promise<void>;
            /**
                * Adds random tag in the blade.
                *
                * @param {boolean} cleanUpTags to delete all the existing tags.
                * @returns {string} A promise that resolves with the added tag and its value.
                */
            addRandomTag(cleanUpTags?: boolean): Promise<string>;
            /**
                * Sets the new tag value.
                *
                * @param {string} tagName Tag Name.
                * @param {string} tagValue Tag Value.
                */
            setNewTagValues(tagName: string, tagValue: string): Promise<void>;
            /**
                * Validates new tag row exists or not.
                */
            validateNewTagRowExists(): Promise<void>;
            /**
                * Applies tags in blade.
                */
            applyTagsInBlade(): Promise<void>;
            /**
                * Sets the focus to new tag row.
                */
            setFocusToNewTagRow(): Promise<void>;
            /**
                * Validates the row tag.
                *
                * @param {number} rowIndex Row index to be validate.
                * @param {string} expectedTagName expected Tag Name.
                * @param {string} expectedTagValue expected Tag Value.
                */
            validateRowTag(rowIndex: number, expectedTagName: string, expectedTagValue: string): Promise<void>;
            /**
                * Gets the string of tag for row.
                *
                * @param tagIndex Tag index.
                */
            getTagStringForRow(tagIndex: number): Promise<string>;
            /**
                * Modifies the existing tag value.
                *
                * @param {string} nameOfTagToEdit Tag name to edit.
                * @param {string} newTagValue new value of tag.
                */
            modifyExistingTagValue(nameOfTagToEdit: string, newTagValue: string): Promise<void>;
            /**
                * Finds the row with tag name.
                *
                * @param {string} nameOfTag Name of tag.
                */
            findTagRow(nameOfTag: string): Promise<EditableGrid.Row>;
            /**
                * Deletes the existing tag.
                *
                * @param {string} nameOfTagToDelete Tag name to delete.
                */
            deleteExistingTag(nameOfTagToDelete: string): Promise<void>;
            /**
                * Deletes the existing tag index.
                *
                * @param {number} tagIndex Tag index to delete.
                */
            deleteExistingTagwithTagIndex(tagIndex: number): Promise<void>;
            /**
                * Finds the specified row and clicks specified command
                *
                * @param {EditableGrid.Row} row on which to execute the command.
                * @param {string} commandText command text to be clicked.
                */
            findRowAndClickCommandButton(row: EditableGrid.Row, commandText: string): Promise<void>;
            /**
                * Opens the context menu for row and clicks specified command
                *
                * @param {EditableGrid.Row} row on which open the conext menu.
                * @param {string} commandText command text to be clicked.
                */
            openContextMenuForRowAndClickCommand(row: EditableGrid.Row, commandText: string): Promise<void>;
            /**
                * Validates that grid has no duplicate tags.
                *
                * @param {number}cellIndex Cell index to validate.
                */
            validateNoDuplicateTags(cellIndex?: number): Promise<void>;
            /**
                * Validated no duplicate tags in editor.
                */
            validateNoDuplicateTagsInEditors(): Promise<void>;
            /**
                * Deletes all tags in the blade.
                *
                * @param useRowCommands to use the row commands.
                * @returns a promise that resolves after all tags are deleted.
                */
            deleteAllTags(useRowCommands?: boolean): Promise<void>;
            /**
                * Finds the row and clicks specified command.
                *
                * @param rowIndex the row idndex.
                * @param commandText command to be clicked.
                * @returns a promise that resolves after the specified command is clicked.
                */
            findRowAndClickCommandButtonGivenRowIndex(rowIndex: number, commandText: string): Promise<void>;
            /**
                * Opens the context and clicks specified command.
                *
                * @param rowIndex the row idndex.
                * @param commandText command to be clicked.
                * @returns a promise that resolves after the specified command is clicked.
                */
            openContextMenuForRowAndClickCommandGivenRowIndex(rowIndex: number, commandText: string): Promise<void>;
            validateNewTagRowDoesNotExist(): Promise<void>;
            validateMaxTagsMessageExists(): Promise<void>;
            validateMaxTagsMessageDoesNotExist(): Promise<void>;
            launchRelatedResourcesForTag(tagIndex: number): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/OAuthButtonField' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a OAuth button field.
        */
    export default class OAuthButtonField extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * The FormElement label.
                *
                * @returns The label PortalElement.
                */
            get label(): PortalElement;
            /**
                * Gets the OAuthButton.
                *
                * @returns The OAuthButton PortalElement.
                */
            getOAuthButton(): PortalElement;
            /**
                * Gets the value of the OAuth button.
                *
                * @returns A promise for the value of the OAuth button.
                */
            getValue(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/OptionPicker' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import FormElement from "@microsoft/azureportal-test/Controls/FormElement";
    /**
        * Represents a TextField.
        */
    export default class OptionPicker extends FormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets which item is selected in the option picker.
                */
            getSelectedItem(): Promise<string>;
            /**
                * Selects the item in the option picker.
                *
                * @param itemValue Value to be set.
                */
            setSelectedItem(itemValue: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Password' {
    import TextBox from "@microsoft/azureportal-test/Controls/TextBox";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    export default class Password extends TextBox {
        /**
          * Gets the locator associated to this element.
          *
          * @returns A Locator instance.
          */
        get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/TimePicker' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Driver class for the time picker control
        */
    export default class TimePicker extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clears the input.
                *
                * @param input target input element to be cleared without blurring.
                */
            clearInputWithoutBlur(input: PortalElement): Promise<void>;
            /**
                * Sets the value of the control via typing into/reading out of the input.
                *
                * @param value desired control value to be set.
                */
            setValue(value: Date): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/DatePicker' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Driver class for the date picker control
        */
    export default class DatePicker extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clears the input.
                *
                * @param input target input element to be cleared without blurring.
                */
            clearInputWithoutBlur(input: PortalElement): Promise<void>;
            /**
                * Sets the value of the control via typing into/reading out of the input.
                *
                * @param value desired control value to be set.
                */
            setValue(value: Date): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Controls/DateTimePicker' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Driver class for the date-time picker control
        */
    export default class DateTimePicker extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clears the input.
                *
                * @param input target input element to be cleared without blurring.
                */
            clearInputWithoutBlur(input: PortalElement): Promise<void>;
            /**
                * Sets the value of the control via typing into/reading out of the inputs.
                *
                * @param value desired control value to be set.
                */
            setValue(value: Date): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Parts/CollectionPart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import Grid from "@microsoft/azureportal-test/Controls/Grid";
    /**
        * Represents a Collection part
        */
    export default class CollectionPart extends Part {
            /**
                * @returns {Grid} The grid that shows the collection elements.
                */
            get grid(): Grid;
            /**
                * @returns {Promise} A promise that resolves with the rollup count of this CollectionPart
                */
            getRollupCount(): Promise<number>;
            /**
                * @returns {Promise} A promise that resolves with the rollup label of this CollectionPart
                */
            getRollupLabel(): Promise<string>;
            /**
                * @returns {Promise} A promise that resolves with the title of this CollectionPart
                */
            getTitle(): Promise<string>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Parts/CollectionSummaryPart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    /**
        * Represents a CollectionSummary part
        */
    export default class CollectionSummaryPart extends Part {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the count of the part.
                */
            getCount(): Promise<number>;
            /**
                * Gets the title of the part.
                */
            getTitle(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Parts/Part' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { TileSize } from "@microsoft/azureportal-test/Parts/TileSize";
    import { ConfirmationAlertAction } from "@microsoft/azureportal-test/ConfirmationAlertAction";
    /**
        * Represents a Part.
        */
    export default class Part extends PortalElement {
            protected partCss: string;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the asset name element.
                */
            get assetNameElement(): PortalElement<any>;
            /**
                * Gets the asset name.
                */
            getAssetName(): Promise<string>;
            /**
                * Builds a Part locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    innerText?: string;
            }): Locator;
            /**
                * Get a value that indicates whether the part is selected.
                *
                * @returns A promise that resolves with a value that indicates whether the part is selected.
                */
            isSelected(): Promise<boolean>;
            /**
                * Get a value that indicates whether the part is loaded.
                *
                * @returns A promise that resolves with a value that indicates whether the part is loaded.
                */
            isLoaded(): Promise<boolean>;
            /**
                * Get a value that indicates whether the part can be clicked.
                *
                * @returns A promise that resolves with a value that indicates whether the part can be clicked.
                */
            isClickable(): Promise<boolean>;
            /**
                * Get a value that indicates whether the part is in an error state.
                *
                * @returns A promise that resolves with a value that indicates whether the part is in an error state.
                */
            hasError(): Promise<boolean>;
            /**
                * Clicks the part.
                *
                * @returns A promise that resolves when the part has been clicked.
                */
            click(): Promise<void>;
            /**
                * Waits until the part has been loaded. Throws an error if the part is not loaded when it reaches the timeout.
                *
                * @param {number} timeout Time, in milliseconds, to wait for the part to load.
                * @returns A promise that resolves to this Part instance when the part has been loaded.
                */
            waitUntilLoaded(timeout?: number): Promise<Part>;
            /**
                * Gets the title of part.
                *
                * @returns  returns part Title or Returns null if the part has not defined a title..
                */
            getPartTitle(): Promise<string>;
            /**
                * @deprecated partTitle instance method is deprecated. Instead, use getPartTitle instance method.
                */
            partTitle(): Promise<string>;
            /**
                * Pin the part, if the Pin command is available.
                *
                * @returns A promise that resolves when Pin command has been clicked.
                */
            pin(): Promise<void>;
            /**
                * Pins the part from the StartBoard.
                */
            pinToStartboard(): Promise<void>;
            /**
                * Unpins the part from the StartBoard.
                */
            unpinFromStartboard(action?: ConfirmationAlertAction): Promise<void>;
            /**
                * Opens the child blade for the part in a new tab.
                */
            openInNewTab(): Promise<void>;
            /**
                * Resizes the part.
                *
                * @returns void
                */
            resize(size: TileSize): Promise<void>;
            /**
                * Resizes the tile using resize handle, only if the part supports user resize mode.
                *
                * @param xOffset x offset to resize.
                * @param yOffset y offset to resize.
                */
            resizeCustom(xOffset: number, yOffset: number): Promise<void>;
            /**
                * Get the size of the part (example: normal, hero-wide, etc)
                *
                * @returns  A promise that resolves with size class of tile.
                */
            getSizeClass(): Promise<string>;
            /**
                * Executes the context menu command.
                *
                * @param commandText The command text.
                */
            executeContextMenuCommand(commandText: string, action?: ConfirmationAlertAction): Promise<void>;
            /**
                *  Returns the class name corresponding to the specified part.
                *
                * @returns The command name.
                */
            mapPartSizeToClassName(size: TileSize): string;
            /**
                *  Returns the part size corresponding to the specified part.
                *
                * @returns The part size.
                */
            getPartSize(): Promise<TileSize>;
            /**
                * Clicks this element with the CONTROL key pressed down.
                */
            clickWithCtrlKey(): Promise<void>;
            /**
                * Gets a value indicating whether the part is in an error state or not.
                *
                * @returns  true if part is in an error state otherwise false.
                */
            isUnauthorized(): Promise<boolean>;
            /**
                * Gets the part's size.
                *
                * @returns enum object fo TileSize.
                */
            partSize(): Promise<TileSize>;
            /**
                * Gets a value indicating whether <see cref="Part"/> is still loading or not.
                *
                * @returns true if <see cref="Part"/> is still loading otherwise, false.
                */
            isLoading(): Promise<boolean>;
            /**
                * Gets a value indicating whether the part is in an error state or not.
                *
                * @returns a promise that resolves with true if Part is in an error state otherwise false.
                */
            isErrorState(): Promise<boolean>;
            /**
                * Gets a value indicating whether the asset is not found.
                */
            isAssetNotFound(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Parts/PropertiesPart' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import PartProperty from "@microsoft/azureportal-test/Parts/PartProperty";
    /**
        * Represents a Properties part.
        */
    export default class PropertiesPart extends Part {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets properties contained in this part.
                *
                * @returns An ElementArrayFinder of PartProperty instances.
                */
            get properties(): ElementArrayFinder<PartProperty>;
            /**
                * Gets the part property that corresponds to the specified options.
                *
                * @param options The options used to find the part property.
                */
            property(options: {
                    name: string;
            }): PartProperty;
    }
}

declare module '@microsoft/azureportal-test/Parts/PricingTierPart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    interface SpecDisplay {
            firstText: string;
            secondText: string;
            specCode: string;
    }
    /**
        * Represents a PricingTier part.
        */
    export default class PricingTierPart extends Part {
            readonly specCodeClassName = "msportalfx-pricingTier-specCode";
            readonly firstTextClassName = "msportalfx-pricingTier-firstText";
            readonly multiSpecClassName = "msportalfx-layoutChildren-child";
            readonly iconClassName = "msportalfx-pricingTier-icon";
            readonly secondTextClassName = "msportalfx-pricingTier-secondText";
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a value indicating whether or not this element is activated.
                */
            specCode(): Promise<string>;
            /**
                * Gets a value of first text.
                */
            firstText(): Promise<string>;
            /**
                * Gets a value of spec display.
                */
            specs(): Promise<SpecDisplay[]>;
    }
    export {};
}

declare module '@microsoft/azureportal-test/Parts/ResourceSummaryPart' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import PartProperty from "@microsoft/azureportal-test/Parts/PartProperty";
    import HotSpot from "@microsoft/azureportal-test/Controls/HotSpot";
    import QuickStartHotSpot from "@microsoft/azureportal-test/Controls/QuickStartHotSpot";
    import AccessHotSpot from "@microsoft/azureportal-test/Controls/AccessHotSpot";
    /**
        * Represents a ResourceSummary part.
        */
    export default class ResourceSummaryPart extends Part {
            /**
                * The resource group property.
                */
            resourceGroupProperty: PartProperty;
            /**
                * The Quick Start hotspot.
                */
            quickStartHotSpot: QuickStartHotSpot;
            /**
                * The Access hotspot.
                */
            accessHotSpot: AccessHotSpot;
            /**
                * The Settings hotspot.
                */
            settingsHotSpot: HotSpot;
            /**
                * The collection of part properties contained in this part.
                */
            properties: ElementArrayFinder<PartProperty, never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the part property that corresponds to the specified options.
                *
                * @param options The options used to find the part property.
                */
            property(options: {
                    name: string;
            }): PartProperty;
    }
}

declare module '@microsoft/azureportal-test/Parts/Tile' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import { TileSize } from "@microsoft/azureportal-test/Parts/TileSize";
    /**
        * Represents a Tile.
        */
    export default class Tile extends PortalElement {
            /**
                * The part that lives inside this tile.
                */
            part: Part;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Get a value that indicates whether the tile is loaded.
                *
                * @returns A promise that resolves with a value that indicates whether the tile is loaded.
                */
            isLoaded(): Promise<boolean>;
            /**
                * Tries to pin the tile, if the Pin command is available.
                *
                * @returns A promise that resolves when Pin command has been clicked or when the Pin command has not been found.
                */
            tryPin(): Promise<void>;
            /**
                * Waits until the tile has been loaded. Throws an error if the tile is not loaded when it reaches the timeout.
                *
                * @param {number} timeout Time, in milliseconds, to wait for the tile to load.
                * @returns A promise that resolves to this Tile instance when the tile has been loaded.
                */
            waitUntilLoaded(timeout?: number): Promise<Tile>;
            /**
                * @deprecated this resize is deprecated. Use resize method from Part.ts instead.
                * Resizes the part.
                * @returns void
                */
            resize(size: TileSize): Promise<void>;
            /**
                * @deprecated this getSizeClass is deprecated. Use getSizeClass method from Part.ts instead.
                * Finds size class
                * @returns  A promise that resolves with size class of tile.
                */
            getSizeClass(): Promise<string>;
            /**
                *  @deprecated this mapPartSizeToClassName is deprecated. Use mapPartSizeToClassName method from Part.ts instead.
                *  Returns the class name corresponding to the specified part.
                * @returns The command name.
                */
            mapPartSizeToClassName(size: TileSize): string;
    }
}

declare module '@microsoft/azureportal-test/Parts/TileSize' {
    /**
        * Represents the possible sizes that Tile can have.
        */
    export enum TileSize {
            /**
                * The mini size
                */
            Mini = 0,
            /**
                * The small size
                */
            Small = 1,
            /**
                * The normal size
                */
            Normal = 2,
            /**
                * The wide size
                */
            Wide = 3,
            /**
                * The tall size
                */
            Tall = 4,
            /**
                * The hero wide size
                */
            HeroWide = 5,
            /**
                * The hero tall size
                */
            HeroTall = 6,
            /**
                * The hero wide fit height size
                */
            HeroWideFitHeight = 7,
            /**
                *  The full width fit height size
                */
            FullWidthFitHeight = 8,
            /**
                * The fit to container size
                */
            FitToContainer = 9,
            /**
                * The large size
                */
            Large = 10,
            /**
                * The hero size
                */
            Hero = 11,
            /**
                * The custom size
                */
            Custom = 99
    }
}

declare module '@microsoft/azureportal-test/Parts/ButtonPart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    /**
        * Represents a ButtonPart.
        */
    export default class ButtonPart extends Part {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * @deprecated partTitle instance method is deprecated. Instead use getPartTitle instance method
                */
            partTitle(): Promise<string>;
            /**
                * Gets the part title.
                */
            getPartTitle(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Parts/InfoList/InfoListPart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { Part, InfoListItem } from "@microsoft/azureportal-test/Parts";
    /**
        * Represents a InfoListPart.
        */
    export default class InfoListPart extends Part {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets an array of info list items within the info list part.
                */
            getItems(): Promise<InfoListItem[]>;
    }
}

declare module '@microsoft/azureportal-test/Parts/InfoList/InfoListItem' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a InfoListItem.
        */
    export default class InfoListItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the part title.
                */
            partTitle(): Promise<string>;
            /**
                * Gets the links element of the info list item.
                */
            getLinks(): PortalElement;
    }
}

declare module '@microsoft/azureportal-test/Parts/PartContainer' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { TileSize } from "@microsoft/azureportal-test/Parts/TileSize";
    import Tile from "@microsoft/azureportal-test/Parts/Tile";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import Lens from "@microsoft/azureportal-test/Lens";
    export abstract class PartContainer extends PortalElement {
            /**
                * Gets the tiles by providing tile size.
                *
                * @param size the tile size.
                * @returns a collection of matched tiles.
                */
            findTilesBySize(size: TileSize): Promise<Tile[]>;
            /**
                * Gets the Part by provided title and type.
                *
                * @param {string} elementType The type of the part that is expected to open.
                * @param {string} title the title of part.
                * @returns A part if a single part is found or undefined if no part is found
                * @throws Error if more then one part is found
                */
            findSinglePartByTitle<T extends Part>(elementType: {
                    new (): T;
            }, title: string): Promise<T>;
            /**
                * Finds the only lens that has the specified title.
                *
                * @param title The title of the lens to be found. Not case sensitive.
                * @returns A Lens with the specified title.
                */
            findSingleLensByTitle(title: string): Promise<Lens>;
            findSingleTileByTitle(title: string): Promise<Tile>;
            /**
                * Waits until all blade tiles are loaded. If the tiles have not finished loading after the specified timeout is reached, an error is thrown.
                *
                * @param {number} timeout The time, in milliseconds, to wait for the tiles to load.
                * @returns A promise that resolves when all tiles are loaded.
                */
            waitForAllTilesLoad(timeout?: number): Promise<void>;
            /**
                * Gets all the parts contained in this blade.
                */
            getAllParts(): Promise<Part[]>;
    }
}

declare module '@microsoft/azureportal-test/Parts/AssetPart' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    /**
        * Represents a AssetPart.
        */
    export default class AssetPart extends Part {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the asset name.
                */
            getAssetName(): Promise<string>;
            /**
                * Gets the asset status.
                */
            getStatus(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Parts/SpecCard' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    /**
        * Represents a spec card.
        */
    export default class SpecCard extends PortalElement {
            readonly specCardClassName = "msportalfx-specpicker";
            readonly specCodeClassName = "msportalfx-specpicker-header-specCode";
            readonly footerContainerClassName = "msportalfx-specpicker-footer";
            readonly costAmountClassName = "msportalfx-specpicker-footer-value";
            readonly channelMessageClassName = "msportalfx-specpicker-footer-channelMessage";
            readonly uiBlockingShieldClassName = "msportalfx-specpicker-disable-blockui-shield";
            readonly recommendedIconClassName = "msportalfx-specpicker-star";
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a value of spec code.
                */
            specCode(): Promise<string>;
            /**
                * Checks whether cost is loaded or not.
                */
            IsCostLoaded(): Promise<boolean>;
            /**
                * Gets Cost amount.
                */
            costAmount(): Promise<string>;
            /**
                * Gets Cost channel message.
                */
            channelMessage(): Promise<string>;
            /**
                * Gets a value indicating if this spec card is disabled.
                */
            isDisabled(): boolean;
            /**
                * Returns a value that indicates whether the Recommended Icon is present or not.
                */
            hasRecommendedIcon(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/PartManagement/PartGallery2' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ContextPane from "@microsoft/azureportal-test/ContextPane/ContextPane";
    import GroupDropDownField from "@microsoft/azureportal-test/Controls/GroupDropDownField";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PartGalleryItem2 from "@microsoft/azureportal-test/PartManagement/PartGalleryItem2";
    /**
        * Represents a Part Gallery.
        */
    export default class PartGallery2 extends ContextPane {
            /**
                * Gets the "Add" button.
                */
            addButton: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a value indicating whether this instance is loading.
                *
                * @returns A promise that resolves to the boolean that determines whether part gallery is Loading
                */
            isLoading(): Promise<boolean>;
            /**
                * Gets the items.
                *
                * @returns A promise that resolves to return all the gallery items.
                */
            getItems(): Promise<PartGalleryItem2[]>;
            /**
                * Finds the single item by title.
                *
                * @param {string} title The title.
                * @returns A promise that resolves to return the gallery item matching the title.
                */
            findSingleItemByTitle(title: string): Promise<PartGalleryItem2>;
            /**
                * Awaits items in part gallery getting populated and the amount is not less than the param count.
                *
                * @param count expected amount of the part gallery items.
                */
            awaitItemsGreaterThenCount(count: number): Promise<void>;
            /**
                * Performs a search by the searchString in the PartGallery.
                *
                * @param searchString The string to search.
                */
            searchItems(searchString: string): Promise<void>;
            /**
                * Gets the categories drop down.
                */
            getCategoriesDropDown(): Promise<GroupDropDownField>;
            /**
                * Gets the resources drop down.
                */
            getResourcesDropDown(): Promise<GroupDropDownField>;
    }
}

declare module '@microsoft/azureportal-test/PartManagement/PartGalleryItem2' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents an item in the part gallery.
        */
    export default class PartGalleryItem2 extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the part title.
                *
                * @returns A promise that resolves to return the gallery item matching the title.
                */
            getTitle(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Parts/ResourcePart/ResourcePart' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Part from "@microsoft/azureportal-test/Parts/Part";
    import ResourcePartProperty from "@microsoft/azureportal-test/Parts/ResourcePart/ResourcePartProperty";
    /**
        * Represents a ResourcePart.
        */
    export default class ResourcePart extends Part {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets properties contained in this part.
                *
                * @returns An ElementArrayFinder of ResourcePartProperty instances.
                */
            get properties(): ElementArrayFinder<ResourcePartProperty>;
            /**
                * Gets columns.
                */
            columns: ElementArrayFinder<PortalElement<any>>;
            /**
                * Gets the part title.
                */
            getPartTitle(): Promise<string>;
            /**
                * Gets the part property that corresponds to the specified options.
                *
                * @param options The options used to find the part property.
                */
            property(options: {
                    name: string;
            }): ResourcePartProperty;
    }
}

declare module '@microsoft/azureportal-test/Parts/ResourcePart/ResourcePartProperty' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a property of a ResourcePart.
        */
    export default class ResourcePartProperty extends PortalElement {
            /**
                * The name of the property.
                */
            name: PortalElement<any>;
            /**
                * The value of the property.
                */
            value: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Builds a PartProperty locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    name?: string;
            }): Locator;
    }
}

declare module '@microsoft/azureportal-test/Commands/CommandBarItem' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a command in a blade's command bar.
        */
    export default class CommandBarItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a value that indicates whether the CommandBarItem is in enabled state.
                *
                * @returns A promise that resolves with a value that indicates whether the CommandBarItem is in enabled state.
                */
            isEnabled(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Commands/ContextMenu' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ContextMenuItem from "@microsoft/azureportal-test/Commands/ContextMenuItem";
    import { ConfirmationAlertAction } from "@microsoft/azureportal-test/ConfirmationAlertAction";
    /**
        * Represents a context menu.
        */
    export default class ContextMenu extends PortalElement {
            /**
                * The collection of items that belong to this context menu.
                */
            items: ElementArrayFinder<ContextMenuItem>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a value that indicates whether the ContextMenu is in active state.
                *
                * @returns A promise that resolves with a value that indicates whether the Context Menu is in active state.
                */
            isActive(): Promise<boolean>;
            /**
                * Returns the ContextMenuItem that corresponds to the specified text.
                *
                * @param {text?} options The options used to find the ContextMenuItem.
                * @returns The ContextMenuItem.
                */
            item(options: {
                    text?: string;
            }): ContextMenuItem;
            /**
                * Returns a value that specifies whether the specified item exists in this context menu.
                *
                * @param {string} text The item text.
                * @returns A promise that resolves with a value that specifies whether the specified item exists in this context menu.
                */
            hasItem(text: string): Promise<boolean>;
            /**
                * Clicks the specified item.
                *
                * @param {string} text The text of the item to click.
                * @returns A promise that resolves when the item has been clicked.
                */
            clickItem(text: string): Promise<void>;
            /**
                * Opens the ContextMenu and click Command.
                *
                * @param {PortalElement} portalElement on which context menu to be open.
                * @param {string} contextMenuItemText command text.
                * @param opt_offset optional, location to right click on a specific location
                * @param action action to perform when a confirmation alter is shown.
                */
            static openContextMenuAndClickCommand(portalElement: PortalElement, contextMenuItemText: string, opt_offset?: {
                    x: number;
                    y: number;
            }, action?: ConfirmationAlertAction): Promise<void>;
            /**
                * Opens the ContextMenu.
                *
                * @param {PortalElement} portalElement on which context menu to be open.
                * @param opt_offset optional, location to right click on a specific location
                * @returns Returns the contextMenu.
                */
            static openContextMenu(portalElement: PortalElement, opt_offset?: {
                    x: number;
                    y: number;
            }): Promise<ContextMenu>;
            /**
                * Finds the context menu item by the full text. It is case insensitive.
                *
                * @param {string} itemText Item name to be searched in context menu.
                * @returns The ContextMenuItem.
                */
            findContextMenuItemByText(itemText: string): Promise<ContextMenuItem>;
    }
}

declare module '@microsoft/azureportal-test/Commands/ContextMenuItem' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents an item in a ContextMenu.
        */
    export default class ContextMenuItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a value that indicates whether the ContextMenuItem is displayed and in enabled state.
                *
                * @returns A promise that resolves with a value that indicates whether the ContextMenuItem is displayed and in enabled state.
                */
            isEnabled(): Promise<boolean>;
            /**
                * Builds a ContextMenu locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    text?: string;
            }): Locator;
            /**
                * Whether context menu item has the expected text (case insensitive) and is enabled.
                *
                * @param itemText text to check if present in context menu item.
                */
            hasExpectedTextAndIsEnabled(itemText: string): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Commands/ListCommandPopup' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a list popup command in a blade's command bar.
        */
    export default class ListCommandPopup extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Selects an item by it's text from list popup.
                *
                * @param {string} text The item text.
                * @returns  A promise that resolves when the item has been selected.
                */
            selectItemByText(text: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Utils/DefaultTimeouts' {
    import Timeout from "@microsoft/azureportal-test/Timeout";
    class DefaultTimeoutsImpl implements Timeout {
            /**
                * The timeout for assert functions. Checks for user value otherwise defaults to 8 seconds.
                */
            assertTimeout: number;
            /**
                * The delay post blade wait methods. This is needed sometime when DOM is updated but rendering is slow.
                * Checks for user value otherwise defaults to 0.5 second.
                */
            bladePostWaitDelay: number;
            /**
                * The default timeout used for delay calls.
                * Checks for user value otherwise defaults to 1 second.
                */
            delayTimeout: number;
            /**
                * The default extra long timeout used for actions that are expected to take more time than `longTimeout`
                * in CI (e.g. slower CloudTest agents).
                * Checks for user value otherwise defaults to 120 seconds.
                */
            extraLongTimeout: number;
            /**
                * Internal timeout used in ElementArrayFinder.waitForElementLocatedTimeout().
                * This timeout should never be longer than timeouts provided to portal.Wait (defaults to `timeout`) or portal.Wait may never retry.
                * Checks for user value otherwise defaults to 3 seconds.
                */
            internalWaitForElementLocatedTimeout: number;
            /**
                * The defaut long timeout used for actions that are expected to take longer than normal (e.g. loading the portal).
                * Checks for user value otherwise defaults to 60 seconds.
                */
            longTimeout: number;
            /**
                * The timeout used to check for a "page" event when getting a list of pages from browser (Playwright only).
                * Checks for user value otherwise defaults to 3 seconds.
                */
            pageEventTimeout: number;
            /**
                * The default timeout used across msportalfx-test.
                * Checks for user value otherwise defaults to 10 seconds.
                */
            timeout: number;
            /**
                * The timeout used to check whether url has settled. Checks for user value otherwise defaults to 30 seconds.
                */
            urlSettledTimeout: number;
    }
    const DefaultTimeouts: DefaultTimeoutsImpl;
    export default DefaultTimeouts;
}

declare module '@microsoft/azureportal-test/Utils/NConfWindowsCredentialManager' {
    import * as nconf from "nconf";
    /**
        * provides nconf.get functionality with a WindowsCredentialManager backing store.
        */
    export default class NConfWindowsCredentialManager extends nconf.Provider {
            /**
                * Gets the password for the given key from Windows Credential Manager.
                *
                * @param key the key in windows credential manager to return the password of
                */
            get(key: any): string;
            /**
                * The provider name to use when registering this when calling nconf.use(...);
                */
            static ProviderName: string;
    }
}

declare module '@microsoft/azureportal-test/Utils/WindowsCredentialManager' {
    /**
        * Provides the ability to retrieve credentials from the Windows Credential Manager.
        */
    export default class WindowsCredentialManager {
            /**
                * Gets the credential matching the given targetName from the Windows Credential Manager synchronously.
                *
                * @param targetName the target name of the credential to retrieve.
                * @returns an object containing the credential information.
                */
            static getWindowsCredentialSync(targetName: string): {
                    UserName: string;
                    CredentialBlob: string;
                    TargetName: string;
                    Win32Error: number;
            };
            /**
                * Gets the credential matching the given targetName from the Windows Credential Manager asynchronously.
                *
                * @param targetName the target name of the credential to retrieve.
                */
            static getWindowsCredential(targetName: string): Promise<{
                    UserName: string;
                    CredentialBlob: string;
                    TargetName: string;
                    Win32Error: number;
            }>;
    }
}

declare module '@microsoft/azureportal-test/Utils/Arm' {
    import { ResourceManagementClient, ResourceGroup } from "@azure/arm-resources";
    /**
        * ArmClient is simple abstraction around @azure/arm-resources and @azure/identity to provide simple crud operations against a resource group
        */
    export class ArmClient {
            resourceManagerClient: ResourceManagementClient;
            /**
                * creates a new ArmClient that will use the supplied resourceManagerClient
                *
                * @param resourceManagerClient a resource management client created via @azure/arm-resources module
                */
            constructor(resourceManagerClient: ResourceManagementClient);
            /**
                * creates an ArmClient configured with the given options
                *
                * @param {IArmClientOptions} [options]
                * @returns {Promise<ArmClient>} promise that resolves with a {ArmClient}
                */
            static createClient(options?: IArmClientOptions): Promise<ArmClient>;
            /**
                * Creates a resource group with the given name and location
                *
                * @param {string} name is the name of the resource group to create
                * @param {string} location is the location where the resource group should be created e.g centralus
                * @param {number} [maxRetries] the number of times the client will attempt to create the resource group after failure. The default is 3.
                * @returns {Promise<{ resourceGroup: ResourceGroup }>} returns a promise that resolves when the resource group is created
                */
            createResourceGroup(name: string, location: string, maxRetries?: number): Promise<{
                    resourceGroup: ResourceGroup;
            }>;
            /**
                * Deletes a resource group with the specified name
                *
                * @param {string} name is the name of the resource group to delete
                * @param {number} [maxRetries] the number of times the client will attempt to delete the resource group after failure. The default is 3.
                * @returns {Promise<any>} returns a promise that resolves when the resource group is delete
                */
            deleteResourceGroup(name: string, maxRetries?: number): Promise<any>;
            /**
                * gets the resource group for the current subscription with given name
                *
                * @param {string} [name] the name of the resource group to be found.
                * @param {number} [maxRetries] the number of times the client will attempt to list the resource groups after failure. The default is 3.
                * @returns {Promise<ResourceGroup>} returns a promise that resolves with the list of resource groups returned
                */
            getResourceGroup(name: string, maxRetries?: number): Promise<ResourceGroup>;
            /**
                * gets an array of resource groups for the current subscription
                *
                * @param {number} [maxRetries] the number of times the client will attempt to list the resource groups after failure. The default is 3.
                * @returns {Promise<ResourceGroup[]>} returns a promise that resolves with the list of resource groups returned
                */
            getResourceGroups(maxRetries?: number): Promise<ResourceGroup[]>;
            /**
                * creates a resource with the specified options
                *
                * @param {IResourceOptions} options specifiying the resource you wish to create
                * @param {number} [maxRetries] the number of times the client will attempt to create the resource after failure. The default is 3.
                * @returns {Promise<string>} returns a promise that resolves when the resource is created, and the returned string is the created resource's id.
                */
            createResource(options: IResourceOptions, maxRetries?: number): Promise<string>;
    }
    /**
        * options required to create an {ArmClient}.
        */
    export interface IArmClientOptions {
            /**
                * the AAD authority url for your tenant id e.g "https://login.windows.net/TENANT_ID_HERE",
                */
            aadAuthorityUrl: string;
            /**
                * the AAD client id
                */
            aadClientId: string;
            /**
                * the AAD client secret corresponding to the client id
                */
            aadClientSecret: string;
            /**
                * arm endpoint you wish to use e.g https://management.azure.com
                */
            armEndpoint: string;
            /**
                * service management endpoint used by adal client to get an authorization token e.g https://management.core.windows.net/
                */
            managementEndpoint: string;
            /**
                * the subscription id with which you want the client to act upon
                */
            subscriptionId: string;
    }
    /**
        * options required to create a resource group
        */
    export interface IResourceOptions {
            /**
                * the name of the resource
                */
            name: string;
            /**
                * the name of the resource group
                */
            resourceGroup: string;
            /**
                * the resource provider for creating the resource
                */
            resourceProvider: string;
            /**
                * provide parent resource identity
                */
            parentResourcePath?: string;
            /**
                * the resource type
                */
            resourceType: string;
            /**
                * the resource provider API version
                */
            resourceProviderApiVersion: string;
            /**
                * properties
                */
            properties: any;
            /**
                * location
                */
            location: string;
    }
}

declare module '@microsoft/azureportal-test/Utils/Array' {
    /**
      * Filters an array using asynchronous predicate.
      *
      * @param {any[]} arr Array to filter.
      * @param {function} predicate Predicate to filter with.
      * @returns A filtered array.
      */
    export function filterAsync<T>(arr: any[], predicate: (arg: any) => any): Promise<T[]>;
}

declare module '@microsoft/azureportal-test/Utils/Assert' {
    import * as assert from "assert";
    import AssertPredicate = assert.AssertPredicate;
    /**
        * Executes `assert.deepEqual` within a timeout. See {@link assert.deepEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {unknown} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function deepEqual(actual: unknown, expected: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.deepStrictEqual` within a timeout. See {@link assert.deepStrictEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {object} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function deepStrictEqual<T>(actual: unknown, expected: T, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.doesNotMatch` within a timeout. See {@link assert.doesNotMatch} for more details.
        *
        * @param {function(): string | function(): Promise<string> | string} value A string or a callback that returns a string to be tested.
        * @param {RegExp} regExp A regular expression the value string is tested against.
        * @param {string | Error} [message = "The input matched the regular expression"] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function doesNotMatch(value: (() => string | Promise<string>) | string, regExp: RegExp, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.doesNotReject` within a timeout. See {@link assert.doesNotReject} for more details.
        *
        * @param {Promise<unknown> | function(): Promise<unknown>} block A promise or an async callback of which to wait for resolution.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function doesNotReject(block: Promise<unknown> | (() => Promise<unknown>), message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.doesNotReject` within a timeout. See {@link assert.doesNotReject} for more details.
        *
        * @param {Promise<unknown> | function(): Promise<unknown>} block A promise or an async callback of which to wait for resolution.
        * @param {AssertPredicate} error An error to compare the rejection error to.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function doesNotReject(block: Promise<unknown> | (() => Promise<unknown>), error: AssertPredicate, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.doesNotThrow` within a timeout. See {@link assert.doesNotThrow} for more details.
        *
        * @param {function(): unknown} block A callback of which to wait for execution.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function doesNotThrow(block: () => unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.doesNotThrow` within a timeout. See {@link assert.doesNotThrow} for more details.
        *
        * @param {function(): unknown} block A callback of which to wait for execution.
        * @param {AssertPredicate} error An error to compare the thrown error to.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function doesNotThrow(block: () => unknown, error: AssertPredicate, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.equal` within a timeout. See {@link assert.equal} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {unknown} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function equal(actual: unknown, expected: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes non-deprecated `assert.fail`. See {@link assert.fail} for more details.
        *
        * @param {string | Error} [message] An optional message to throw in case of an error.
        */
    export function fail(message?: string | Error): void;
    /**
        * Executes `assert.ifError` within a timeout. See {@link assert.ifError} for more details.
        *
        * @param {unknown} value A value or a callback that returns a value to be tested.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function ifError(value: unknown, timeout?: number): Promise<void>;
    /**
        * Executes `assert.match` within a timeout. See {@link assert.match} for more details.
        *
        * @param {function():  string | function(): Promise<string> | string} value A string or a callback that returns a string to be tested.
        * @param {RegExp} regExp A regular expression the value string is tested against.
        * @param {string | Error} [message = "The input matched the regular expression"] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function match(value: (() => string | Promise<string>) | string, regExp: RegExp, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.notDeepEqual` within a timeout. See {@link assert.notDeepEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {unknown} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function notDeepEqual(actual: unknown, expected: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.notDeepStrictEqual` within a timeout. See {@link assert.notDeepStrictEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {unknown} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function notDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.notEqual` within a timeout. See {@link assert.notEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {unknown} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function notEqual(actual: unknown, expected: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.notStrictEqual` within a timeout. See {@link assert.notStrictEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {unknown} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function notStrictEqual(actual: unknown, expected: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.ok` within a timeout. See {@link assert.ok} for more details.
        *
        * @param {unknown} value A value or a callback that returns a value to be tested.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function ok(value: unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.rejects` within a timeout. See {@link assert.rejects} for more details.
        *
        * @param {Promise<unknown> | function(): Promise<unknown>} block A promise or an async callback of which to wait for rejection.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function rejects(block: Promise<unknown> | (() => Promise<unknown>), message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.rejects` within a timeout. See {@link assert.rejects} for more details.
        *
        * @param {Promise<unknown> | function(): Promise<unknown>} block A promise or an async callback of which to wait for rejection.
        * @param {AssertPredicate} error An error to compare the rejection error to.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function rejects(block: Promise<unknown> | (() => Promise<unknown>), error: AssertPredicate, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.strictEqual` within a timeout. See {@link assert.strictEqual} for more details.
        *
        * @param {unknown} actual A value or a callback that returns a value to be tested.
        * @param {object} expected An expected value the actual is tested against.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function strictEqual<T>(actual: unknown, expected: T, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.throws` within a timeout. See {@link assert.throws} for more details.
        *
        * @param {function(): unknown} block A callback of which to wait for thrown error.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function throws(block: () => unknown, message?: string | Error, timeout?: number): Promise<void>;
    /**
        * Executes `assert.throws` within a timeout. See {@link assert.throws} for more details.
        *
        * @param {function(): unknown} block A callback of which to wait for thrown error.
        * @param {AssertPredicate} error An error to compare the thrown error to.
        * @param {string | Error} [message] An optional message to throw in case of an error.
        * @param {number} [timeout = assertTimeout] An optional timeout to wait for the assert. Default is {@link assertTimeout}.
        */
    export function throws(block: () => unknown, error: AssertPredicate, message?: string | Error, timeout?: number): Promise<void>;
}

declare module '@microsoft/azureportal-test/Utils/AssetTypes' {
    /**
      * Maps asset type name.
      *
      * @param assetTypePluralName asset type name to be mapped.
      * @param {testFx.Portal} portal : portal instance.
      * @returns A promise that will resolve to mapped asset type name string.
      */
    export function mapAssetTypePluralName(assetTypePluralName: string): Promise<string>;
}

declare module '@microsoft/azureportal-test/Utils/ErrorHandling' {
    /**
      * Returns a string respresentation of the specified error.
      *
      * @param {any} error The error to read.
      * @returns A string respresentation of the specified error.
      */
    export function readError(error: any): any;
}

declare module '@microsoft/azureportal-test/Utils/Findup' {
    import * as fs from "fs";
    /**
        * Filter configuration that is used to match against files.
        *
        * @param {string | RegExp | (string | RegExp)[] | ((file: fs.Dirent, fileDir?: string) => boolean)} filter A filter to test the file names against.
        *                              It can be a string, a regular expression, an array of strings or regular expressions or a callback.
        *                              A callback accepts an {@link fs.Dirent} and the file's current directory as a string (optional) and has to return a boolean.
        * @param {boolean} [noCase] A flag to remove case sensitivity while testing against string and regular expression filters.
        * @param {boolean} [partial] A flag to partially match against string filters.
        */
    export interface FilterOptions {
            filter: string | RegExp | (string | RegExp)[] | ((file: fs.Dirent, fileDir?: string) => boolean);
            noCase?: boolean;
            partial?: boolean;
    }
    /**
        * Scanner configuration that is used to determine what files to find.
        *
        * @param {string | string[]} [dir] A string or an array of strings that represent relative or absolute paths of directories to scan.
        * @param {FilterOptions} [exclude] An object that defines which files or directories should be excluded from search results. Look at {@link FilterOptions} for description.
        * @param {boolean} [findAll] A flag to find all matching files (and directories if 'includeDir' is set to 'true').
        * @param {boolean} [includeDir] A flag to include directories in search results.
        * @param {FilterOptions} [match] An object that defines which files or directories to find. Look at {@link FilterOptions} for description.
        */
    export interface ScanOptions {
            dir?: string | string[];
            exclude?: FilterOptions;
            findAll?: boolean;
            includeDir?: boolean;
            match?: FilterOptions;
    }
    /**
        * A robust scanner for files and/or directories based on given options.
        *
        * If no {@link ScanOptions.dir} is provided, the current working directory is used.
        * Parameter {@link ScanOptions.exclude} takes precedence over {@link ScanOptions.match}.
        * Parameter {@link ScanOptions.exclude} is tested against both directories and files while {@link ScanOptions.match} only tests against files
        * unless {@link ScanOptions.includeDir} is set to 'true'.
        *
        * The exclusion of a file/directory is done when {@link FilterOptions.filter} is truthy. This means that strings/regular expressions that match
        * the given filter or the callback that returns 'true' **will** get excluded from the search. For example, if you need to exclude a directory named
        * 'Tests' that is located inside a directory 'SDK', you can pass a callback
        * `(file: fs.Dirent, fileDir: string) => fileDir.endsWith("\\SDK") && file.isDirectory() && file.name === "Tests"`.
        *
        * @param {ScanOptions} [options] Scanner configuration that is used to determine what files to find. Look at {@link ScanOptions} for description.
        * @returns {string[]} An array of files found.
        */
    export function Scan(options?: ScanOptions): string[];
}

declare module '@microsoft/azureportal-test/Utils/Guid' {
    export function newGuid(): string;
}

declare module '@microsoft/azureportal-test/Utils/ReactView' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { IBrowserElement } from "@microsoft/azureportal-test/IBrowserAutomation";
    /**
        * Execute function within the active ReactView iframe.
        *
        * @param fn Async function to be executed.
        */
    export function executeInActiveReactView<T>(fn: () => Promise<T>): Promise<T>;
    /**
        * Execute function within the ReactView iframe located by frameLocator.
        *
        * @param frameLocator Locator or IBrowserElement for ReactView iframe.
        * @param fn Async function to be executed.
        */
    export function executeInReactViewIframe<T>(frameLocator: Locator | IBrowserElement, fn: () => Promise<T>): Promise<T>;
    export function switchToDefaultContent(): Promise<void>;
}

declare module '@microsoft/azureportal-test/Utils/String' {
    /**
        * Formats a string based on its key value pair object.
        *
        * @param args The list of arguments format arguments. For example: "String with params {0} and {1}".format("val1", "val2");.
        * @returns Formatted string.
        */
    export function format(value: string, ...restArgs: any[]): string;
    /**
        * Determines if the current string starts with the given string.
        *
        * @param value The value to check if the current string starts with.
        * @returns Boolean true if the current string starts with the given string, else false.
        */
    export function startsWith(source: string, searchString: string): boolean;
    export function equalsIgnoringCase(source: string, other: string): boolean;
    export function isNullOrEmpty(value: string): boolean;
    export function isNullOrUndefined(value: string): boolean;
    export function isNullOrEmptyOrUndefined(value: string): boolean;
    /**
        * Routine to convert the string css px sizes to their integer units.
        *
        * @param cssSize Source css pixels number to convert to int.
        * @returns An integer number equal to the number of pixels in the given css px size.
        */
    export function cssStringSizeToInt(cssSize: string): number;
}

declare module '@microsoft/azureportal-test/Utils/Timeouts' {
    /**
        * @deprecated Use `DefaultTimeouts.timeout` instead.
        */
    export let defaultTimeout: number;
    /**
        * @deprecated Use `DefaultTimeouts.longTimeout` instead.
        */
    export let defaultLongTimeout: number;
    /**
        * @deprecated Use `DefaultTimeouts.extraLongTimeout` instead.
        */
    export let defaultExtraLongTimeout: number;
    /**
        * @deprecated Use `DefaultTimeouts.bladePostWaitDelay` instead.
        */
    export let bladePostWaitDelay: number;
    /**
        * @deprecated Use `DefaultTimeouts.internalWaitForElementLocatedTimeout` instead.
        */
    export let internalWaitForElementLocatedTimeout: number;
    /**
        * @deprecated Use `DefaultTimeouts.assertTimeout` instead.
        */
    export let assertTimeout: number;
    /**
        * @deprecated Use `DefaultTimeouts.urlSettledTimeout` instead.
        */
    export let urlSettledTimeout: number;
    /**
        * @deprecated Use `DefaultTimeouts.pageEventTimeout` instead.
        */
    export let pageEventTimeout: number;
}

declare module '@microsoft/azureportal-test/Utils/UriBuilder' {
    export interface StringMap<T> {
            [key: string]: T;
    }
    /**
        * Provides basic query string manipulation functions.
        */
    export class QueryStringBuilder {
            /**
                * Initializes a new instance of the query string builder.
                *
                * @param qs The initial query string.
                * @param leadingSeparator The leading character of the query string. ? by default.
                */
            constructor(qs?: string, leadingSeparator?: string);
            /**
                * Sets multiple parameters in the query string. Overwrites any existing values.
                *
                * @param keys The object that represents the key value pairs.
                * @returns The QueryStringBuilder instance.
                */
            setParameters(keys: StringMap<any>): QueryStringBuilder;
            /**
                * Sets a parameter in the query string. Overwrites any existing values.
                *
                * @param key The key of the parameter.
                * @param value The value of the parameter.
                * @returns The QueryStringBuilder instance.
                */
            setParameter(key: string, value: any): QueryStringBuilder;
            /**
                * Gets the value of a parameter in the query string.
                *
                * @param key The key of the parameter.
                * @returns The value of the parameter. Undefined if the value doesn't exist.
                */
            getParameter(key: string): any;
            /**
                * Gets all values of the query string as a stringmap.
                *
                * @returns StringMap of all query string key/value pairs.
                */
            getParameters(): StringMap<any>;
            /**
                * Removes multiple parameters from the query string.
                *
                * @param keys The keys of the parameter.
                * @returns The QueryStringBuilder instance.
                */
            removeParameters(keys: string[]): QueryStringBuilder;
            /**
                * Removes a parameter from the query string.
                *
                * @param key The key of the parameter.
                * @returns The QueryStringBuilder instance.
                */
            removeParameter(key: string): QueryStringBuilder;
            /**
                * Returns a string representation of the URI.
                *
                * @param includeLeadingSeparator Whether to emit the leading ?. Defaults to true.
                * @returns A string representation of the URI.
                */
            toString(includeLeadingSeparator?: boolean): string;
    }
    /**
        * Provides basic URI manipulation functions.
        */
    export class UriBuilder {
            /**
                * Gets or sets the path part of the URI. This includes the protocol, domain, port, and virtual path.
                */
            path: string;
            /**
                * Gets or sets the query string part of the URI. This is represented as key value pairs.
                */
            query: QueryStringBuilder;
            /**
                * Gets or sets the fragment of the URI. This includes everything after the # separator in the URI.
                */
            fragment: string;
            /**
                * Initializes a new instance of the URI.
                */
            constructor(uri?: string);
            /**
                * Returns a string representation of the URI.
                */
            toString(): string;
    }
}

declare module '@microsoft/azureportal-test/Tests/Parts' {
    /**
      * Verifies that all the parts in the target blade can be pinned to the dashboard and that the pinned parts load and are not
      * in an error state.
      *
      * @param {string} targetBladeDeepLink Deep link to the blade under test.
      * @param {string} targetBladeTitle The title of the blade under test.
      * @param {number} timeout The time, in milliseconds, to wait for the blade and parts to load.
      * @returns A promise that resolves with a value that indicates whether the test passed.
      */
    export function canPinAllBladeParts(targetBladeDeepLink: string, targetBladeTitle: string, timeout?: number): Promise<boolean>;
}

declare module '@microsoft/azureportal-test/Tests/Browse' {
    /**
        * Tests context menu in browse contains expected commands.
        * browse will be opened for the given resource type and the context menu for the first row in the grid
        * will be opened.  The commands present in the context menu will be compared with the expectedCommands
        *
        * @param {string} resourceProvider The resource provider.
        * @param {string} resourceType The resource type.
        * @param {string} browseBladeTitle - The title of the browse blade for the resource.
        * @param {number} columnIndex - The column to right click for the context menu.
        * @param {Array<string>} expectedCommands - An array of strings representing the expected context menu commands.
        * @param {number} [timeout] The time to wait, in milliseconds, for the context menu to show up
        * @returns A promise that resolves when the test is completed
        * @tutorial tutorial-browse-context-menu
        */
    export function contextMenuContainsExpectedCommands(resourceProvider: string, resourceType: string, browseBladeTitle: string, columnIndex: number, expectedCommands: string[], timeout?: number): Promise<void>;
    /**
        * Tests extension resource specific columns can be selected in browse and that after selection the union of defaultColumns and columnsToSelect are shown in the browse grid.
        * In the case that they are not an AssertionError is thrown.
        *
        * @param {string} resourceProvider The resource provider.
        * @param {string} resourceType The resource type.
        * @param {string} browseBladeTitle - The title of the browse blade for the resource.
        * @param {Array<ColumnTestOptions>} defaultColumns - An array of default custom columns that are shown in browse
        * @param {Array<ColumnTestOptions>} columnsToSelect - An array of custom columns to check based on the custom column interface. If empty, this tests default columns only.
        * @param {number} [timeout] The time to wait
        * @returns A promise that resolves when the test is completed
        * @tutorial tutorial-browse-column-tests
        */
    export function canSelectResourceColumns(resourceProvider: string, resourceType: string, browseBladeTitle: string, defaultColumns: ColumnTestOptions[], columnsToSelect?: ColumnTestOptions[], timeout?: number): Promise<void>;
    /**
        * Tests columns in browse.
        *
        * @param {string} resourceProvider The resource provider.
        * @param {string} resourceType The resource type.
        * @param {string} browseBladeTitle - The title of the browse blade for the resource.
        * @param {Array<ColumnTestOptions>} defaultColumns - An array of default custom columns that are shown in browse
        * @param {number} [timeout] The time to wait
        * @returns Boolean true if the expected default columns were in browse.
        * @tutorial tutorial-browse-column-tests
        */
    export function containsExpectedDefaultColumns(resourceProvider: string, resourceType: string, browseBladeTitle: string, defaultColumns: ColumnTestOptions[], timeout?: number): Promise<void>;
    /**
        * Options used to specify expectations on columns in browse tests
        */
    export interface ColumnTestOptions {
            columnLabel: string;
    }
}

declare module '@microsoft/azureportal-test/Notifications/Notification' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a Portal notification.
        */
    export default class Notification extends PortalElement {
            /**
                * The notification title.
                */
            title: PortalElement<any>;
            /**
                * The notification title.
                */
            progressTitle: PortalElement<any>;
            /**
                * The notification description.
                */
            description: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Notifications/NotificationsMenu' {
    import IPortalElementRetryOptions from "@microsoft/azureportal-test/IPortalElementRetryOptions";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Notification from "@microsoft/azureportal-test/Notifications/Notification";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    /**
        * Represents the Portal Notifications menu.
        */
    export default class NotificationsMenu extends PortalElement {
            /**
                * The list of displayed notifications.
                */
            notifications: ElementArrayFinder<Notification, never>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Invokes the click function on notifications button.
                *
                * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
                * @returns A promise that resolves when the invoked function resolves.
                */
            click(retryOptions?: IPortalElementRetryOptions): Promise<void>;
            /**
                * Checks if any notifications are open and if so, clicks the notification button to try to close them.
                */
            closeNotificationIfOpen(): Promise<void>;
            /**
                * Waits for a new notification to show up given the specified parameters. An error is thrown if the notification
                * does not show up after the timeout is reached.
                *
                * @param {string} title The notification title.
                * @param {string} description The notification description.
                * @param {number} timeout The time to wait, in milliseconds, for the notification to show up.
                * @returns The found Notification.
                */
            waitForNewNotification(title?: string, description?: string, timeout?: number): Promise<Notification>;
    }
}

declare module '@microsoft/azureportal-test/Notifications/NotificationsPane' {
    import ContextPane from "@microsoft/azureportal-test/ContextPane/ContextPane";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import Notification from "@microsoft/azureportal-test/Notifications/Notification";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    /**
        * Represents the Portal Notifications pane.
        */
    class NotificationsPaneBase extends ContextPane {
            /**
                * The list of displayed notifications.
                */
            notifications: ElementArrayFinder<Notification, never>;
            /**
                * Gets the total notification count.
                */
            getNotificationCount(): Promise<number>;
            /**
                * Waits for a new notification to show up given the specified parameters. An error is thrown if the notification
                * does not show up after the timeout is reached.
                *
                * @param {string} title The notification title.
                * @param {string} description The notification description.
                * @param {number} timeout The time to wait, in milliseconds, for the notification to show up.
                * @returns The found Notification.
                */
            waitForNewNotification(title?: string, description?: string, timeout?: number): Promise<Notification>;
    }
    export default class NotificationsPane extends NotificationsPaneBase {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    export class CustomNotificationsPane extends NotificationsPaneBase {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    export {};
}

declare module '@microsoft/azureportal-test/Notifications/ToastNotification' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { AlertPromise } from "selenium-webdriver";
    import { Dialog } from "playwright";
    /**
        * Represents the Toast Notification.
        */
    export default class ToastNotification extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the title associated to this element.
                *
                * @returns A instance.
                */
            get getToastTitle(): PortalElement;
            /**
                * Get buttons in the toast.
                */
            getToastButtons(): Promise<PortalElement[]>;
            /**
                * Click close button on toast.
                */
            clickClose(dialogCb?: (dialog: Dialog | AlertPromise) => Promise<void>): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Settings/SettingsFlyout' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * The views in the settings flyout.
        */
    export enum SettingsViews {
            AppearanceAndStartupViews = 0,
            Directories = 1,
            Filters = 2,
            LanguageAndRegion = 3,
            MoreAzureResources = 4,
            MyInformation = 5,
            Overview = 6,
            SigningOutAndNotifications = 7
    }
    /**
        * A test handle for the new full screen settings page.
        */
    export class SettingsFlyout extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Returns a flag indicating whether or not the settings flyout is still loading.
                */
            isLoading(): Promise<boolean>;
            /**
                * Navigates to the specified area of settings.
                *
                * @param view The tab to navigate to.
                */
            openSettingsView(view: SettingsViews): Promise<void>;
            /**
                * Navigates to the specified tab of settings.
                *
                * @param linkText The link text that the tab will navigate to.
                */
            openSettingsViewFromLink(linkText: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Views/ReactView' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { PortalElementOptionsType } from "@microsoft/azureportal-test/PortalElementOptions";
    import View from "@microsoft/azureportal-test/Views/View";
    /**
        * Represents a ReactView.
        */
    export default class ReactView extends View {
            /**
                * Gets all PortalElements that match the specified locator in ReactView frame.
                *
                * @deprecated Use .findAll()
                * @param locator The locator.
                * @returns All PortalElements that match the specified locator in ReactView frame.
                */
            findAllReactElements(locator: Locator): Promise<PortalElement<any>[]>;
            /**
                * Gets a PortalElement that matches the specified locator in ReactView frame.
                *
                * @deprecated Use .find()
                * @param locator The locator.
                * @returns A PortalElement that matches the specified locator in ReactView frame.
                */
            findReactElement(locator: Locator): Promise<PortalElement<any>>;
            find<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }, locatorOptions?: TElementOptions): Promise<TPortalElement>;
            findAll<TPortalElement extends PortalElement<any>, TElementOptions extends PortalElementOptionsType<TPortalElement> = PortalElementOptionsType<TPortalElement>>(subLocatorOrElementType: Locator | {
                    new (): TPortalElement;
            }, locatorOptions?: TElementOptions): Promise<TPortalElement[]>;
    }
}

declare module '@microsoft/azureportal-test/Views/DeploymentOverview' {
    import ReactView from "@microsoft/azureportal-test/Views/ReactView";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    /**
        * Represents a deployment overview blade based on `deploymentOverviewBuilder`.
        */
    export default class DeploymentOverview extends ReactView {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Waits for the deployment blade to report it has completed
                *
                * @param timeout The maximum amount of time in milliseconds to wait when trying to locate elements.
                * @returns a promise that resolves when the deployment has reported Completion
                */
            waitForDeploymentCompletion(timeout?: number): Promise<void>;
            /**
                * Waits for the deployment blade to report it has failed
                *
                * @param timeout The maximum amount of time in milliseconds to wait when trying to locate elements.
                * @returns a promise that resolves when the deployment has reported failure
                */
            waitForDeploymentFailure(timeout?: number): Promise<void>;
            /**
                * Waits for the deployment blade to log details
                *
                * @param timeout The maximum amount of time in milliseconds to wait when trying to locate elements.
                * @returns a promise that resolves with deployment details logged
                */
            logDeploymentDetails(timeout?: number): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/IPortalConfigurationManager' {
    import PortalContext from "@microsoft/azureportal-test/PortalContext";
    /**
      * The global PortalConfiguration object that contains configuration for the msportalfx-test framework Portal object to be used for tests.
      * The config hierarchy is args, environment variables, user set values via code, and config json file.
      */
    export default interface IPortalConfigurationManager {
        get(key: string): any;
        set(key: string, value: any): void;
        portalContext: PortalContext;
        configJsonPath: string;
    }
}

declare module '@microsoft/azureportal-test/Search/SearchMenu' {
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import SearchResult from "@microsoft/azureportal-test/Search/SearchResult";
    import SearchCategory from "@microsoft/azureportal-test/Search/SearchCategory";
    /**
        * Represents the Portal Search menu.
        */
    export default class SearchMenu extends PortalElement {
            /**
                * @deprecated SearchMenu.mruResults instance property has been deprecated, use SearchMenu.getAllMruMenuSearchResults instance method instead.
                */
            mruResults: ElementArrayFinder<SearchResult>;
            /**
                * The list of displayed search results.
                */
            searchResults: ElementArrayFinder<SearchResult>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Get categories from search results. This method is only applicable when query string parameter asyncSearch is set to true.
                */
            getCategories(): Promise<SearchCategory[]>;
            /**
                * Get all recents from search results. This method is only applicable when mruItemsMenu is present.
                */
            getAllMruMenuSearchResults(): Promise<SearchResult[]>;
            /**
                * Get "See all" link of a search category.
                *
                * @param searchCategory The category of search result containing see all link.
                */
            getSeeAllLink(searchCategory: SearchCategory): Promise<PortalElement>;
            /**
                * Get "See more" link of a search category.
                *
                * @param searchCategory The category of search result containing see more link.
                */
            getSeeMoreLink(searchCategory: SearchCategory): Promise<PortalElement>;
            /**
                * Searches for the given string.
                *
                * @param {string} text The text to search for.
                * @param {timeout} timeout in miliseconds to wait for search to complete. Default is 5000 miliseconds.
                * @returns The list of search results.
                */
            search(text?: string, timeout?: number): Promise<SearchResult[]>;
            /**
                * Opens the search flyout..
                *
                * @returns the SearchMenu.
                */
            open(): Promise<SearchMenu>;
            /**
                * Closes the search flyout.sometimes, icon becomes enabled only after searchTextBox is clicked,Hence cliking seachTextBox and then SearchIcon.
                */
            close(): Promise<void>;
            /**
                * Clears the previous search.
                *
                * @returns The search menu.
                */
            clearSearch(): Promise<SearchMenu>;
            /**
                * Filters global search result on the basis of title.
                *
                * @param {any} searchResults List of search results.
                * @param {string} title title of the search result.
                * @returns an array that satisfies the filter conditions.
                */
            filterSearchResultsByTitle(searchResults: SearchResult[], title: string): Promise<SearchResult[]>;
            /**
                * Filters global search result on the basis of result type.
                *
                * @param {any} searchResults List of search results.
                * @param {string} resultType Result type of the search result.
                * @returns an array that satisfies the filter conditions.
                */
            filterSearchResultsByResultType(searchResults: SearchResult[], resultType: string): Promise<SearchResult[]>;
            /**
                * Checks if MruItemsMenu is present or not in SearchMenu.
                */
            isMruItemsMenuPresent(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Search/SearchResult' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a search result.
        */
    export default class SearchResult extends PortalElement {
            /**
                * The search result name.
                */
            title: PortalElement<any>;
            /**
                * The search result type.
                */
            resultType: PortalElement<any>;
            /**
                * The search result subname.
                */
            subName: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/PortalMode' {
    /**
        * Represents the mode for the portal.
        */
    export const enum PortalMode {
            /**
                * Default mode
                */
            Default = 0,
            /**
                * Organize mode
                */
            Organize = 1
    }
}

declare module '@microsoft/azureportal-test/AvatarMenu/AvatarMenu' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents the Avatar Menu.
        */
    export default class AvatarMenu extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clicks SwitchDirectory button on avatar menu.
                */
            clickSwitchDirectory(): Promise<void>;
            /**
                * Gets the directory display name.
                *
                * @returns A promise that resolves with the name.
                */
            getDirectoryDisplayName(): Promise<string>;
            /**
                * Gets a value indicating whether the Avatar menu is opened.
                */
            isOpen(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/ContextPane/DebugFlyout' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ContextPane from "@microsoft/azureportal-test/ContextPane/ContextPane";
    /**
        * Represents a context pane.
        */
    export default class DebugFlyout extends ContextPane {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Adds the specified part to the start board.
                *
                * @param extensionName The name of the extension that contains the part type.
                * @param partTypeName The part type to add.
                * @param modelJson The JSON of the container model for the part.
                */
            addPart(extensionName: string, partTypeName: string, modelJson: string): Promise<void>;
            /**
                * Gets loaded Extensions.
                *
                * @returns Promise of array of extension names which are loaded.
                */
            getLoadedExtensions(): Promise<string[]>;
            /**
                * Share dashboard to session repository.
                *
                * @param {string} dashboardTitle The title of dashboard to be shared.
                * @returns Promise which resolves when dashboard is shared to session repository.
                */
            shareDashboardToSessionRepository(dashboardTitle: string): Promise<void>;
            /**
                * Clear dashboards from session repository.
                *
                * @returns Promise which resolves when dashboards are cleared from session repository.
                */
            clearDashboardsFromSessionRepository(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Views/View' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { AlertPromise } from "selenium-webdriver";
    import { Dialog } from "playwright";
    export default abstract class View extends PortalElement {
            protected bladeClass: string;
            protected subtitleClass: string;
            protected titleClass: string;
            /**
                * Gets the title element text.
                *
                * @returns View title.
                */
            getTitle(): Promise<string>;
            /**
                * Gets the subtitle element text.
                *
                * @returns View subtitle.
                */
            getSubtitle(): Promise<string>;
            /**
                * Gets the locator associated to this view.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Builds a View locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    title?: string;
            } | {
                    subTitle?: string;
            }): Locator;
            /**
                * Returns a value that indicates whether the view has been revealed.
                *
                * @returns A promise that resolves with a value that indicates whether the view has been revealed.
                */
            isRevealed(): Promise<boolean>;
            /**
                * Returns a value that indicates whether the view has finished loading.
                *
                * @returns A promise that resolves with a value that indicates whether the view has finished loading.
                */
            isLoaded(): Promise<boolean>;
            /**
                * Waits until the view has been revealed.
                *
                * @param {number} timeout? The time, in milliseconds, to wait for the view to load.
                * @returns A promise that resolves with this view instance when it has been revealed.
                */
            waitUntilRevealed(timeout?: number): Promise<this>;
            /**
                * Waits until the view has finished loading.
                *
                * @param {number} timeout?  The time, in milliseconds, to wait for the view to load.
                * @returns A promise that resolves with this view instance when it has finished loading.
                */
            waitUntilLoaded(timeout?: number): Promise<this>;
            /**
                * Clicks the close button on the view.
                *
                * @returns A promise that results once the close button is clicked.
                */
            clickClose(dialogCb?: (dialog: Dialog | AlertPromise) => Promise<void>): Promise<void>;
            /**
                * Clicks the pin button on the view.
                *
                * @returns A promise that results once the pin button is clicked.
                */
            clickPin(): Promise<void>;
            /**
                * Pins the view to dashboard.
                *
                * @returns A promise that results once the pin to dashboard button is clicked.
                */
            pinToDashboard(): Promise<void>;
            /**
                * Clicks the ShareIt button on the view.
                *
                * @returns A promise that results once the button is clicked.
                */
            clickShareIt(): Promise<void>;
            /**
                * Returns a boolean that indicates if there is an error in this view.
                *
                * @returns A promise that resolves to a boolean value that indicates if an error is present.
                */
            hasError(): Promise<boolean>;
            /**
                * Gets the text of the error message of a view where View.hasError() returns true.
                *
                * @returns A promise which returns a string, or null if there is no error.
                */
            getErrorText(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Dialogs/ModalDialog' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import DialogBase from "@microsoft/azureportal-test/Controls/Dialogs/DialogBase";
    /**
        *  Represents a Modal dialog.
        */
    export default class ModalDialog extends DialogBase {
            /**
                *  By locator used to identify elements of this class.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the message box title.
                *
                * @returns Promise which resolves to modal dialog title.
                */
            getTitle(): Promise<string>;
            /**
                * Perform the accept action on modal dialog.
                *
                * @param {string} buttonText The label of accept button.
                * @returns Promise which resolves to accept button is clicked.
                */
            accept(buttonText?: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/BrowserResolution' {
    /**
        * Represents a browser's resolution (size).
        */
    export default interface BrowserResolution {
            /**
                * Width in pixels.
                */
            width: number;
            /**
                * Height in pixels.
                */
            height: number;
    }
}

declare module '@microsoft/azureportal-test/SilentAuthConfig' {
    /**
        * Represents silent auth configuration
        */
    export default interface SilentAuthConfig {
            /**
                * Portal auth URL to sign in to the Portal with silent auth
                */
            portalAuthUrl?: string;
            /**
                * PortalId cookie used for silent auth
                */
            portalId?: string;
    }
}

declare module '@microsoft/azureportal-test/Timeout' {
    /**
        * Represents a user defined timeout.
        */
    export default interface Timeout {
            /**
                * The shorter timeout that most functions will use.
                */
            timeout?: number;
            /**
                * The longer timeout that longer running operations will use.
                */
            longTimeout?: number;
            /**
                * The longest timeout that adds extra time for CI runs.
                */
            extraLongTimeout?: number;
            /**
                * The delay post blade wait methods. This is needed sometime when DOM is updated but rendering is slow.
                */
            bladePostWaitDelay?: number;
            /**
                * Internal timeout used in ElementArrayFinder.waitForElementLocatedTimeout().
                * This timeout should never be longer than timeouts provided to portal.Wait (defaults to `timeout`) or portal.Wait may never retry.
                */
            internalWaitForElementLocatedTimeout?: number;
            /**
                * The timeout for assert functions.
                */
            assertTimeout?: number;
            /**
                * The timeout used to check whether url has settled.
                */
            urlSettledTimeout?: number;
            /**
                * The timeout used to check for a "page" event when getting a list of pages from browser (Playwright only).
                */
            pageEventTimeout?: number;
            /**
                * The default timeout used for delay calls.
                */
            delayTimeout?: number;
    }
}

declare module '@microsoft/azureportal-test/ContextMode' {
    export enum ContextMode {
        Incognito = "incognito",
        Persistent = "persistent"
    }
}

declare module '@microsoft/azureportal-test/ICodeCoverageOptions' {
    /**
        * Options for code coverage analysis (Playwright only)
        */
    export interface CodeCoverageOptions {
            /**
                * A string or an array of strings that represent relative or absolute paths to files to be excluded by code coverage analysis.
                * A path can be a direct path to a source file or it can be a directory that contains source file(s).
                * An array of paths can be a mix of directories and direct paths to files. The "node_modules" directory is always excluded.
                */
            exclude?: string | string[];
            /**
                * A flag to analyze code coverage when a ".js" file is present but its corresponding ".ts" or ".js.map" files are not.
                * If sources are provided, the default is "true". If sources are not provided, the value is always "true".
                */
            includeJsOnly?: boolean;
            /**
                * A flag to analyze code coverage only if a source file is found.
                * If sources are provided, the default is "true". If sources are not provided, the value is always "false".
                */
            onlySources?: boolean;
            /**
                * A string or an array of strings that represent relative or absolute paths to source files for code coverage analysis.
                * A path can be a direct path to a source file or it can be a directory that contains source file(s).
                * An array of paths can be a mix of directories and direct paths to files.
                * If no sources are given, code coverage results for most scripts that have been captured on a browser page will be written.
                */
            sources?: string | string[];
    }
}

declare module '@microsoft/azureportal-test/Accessibility' {
    import * as AxeCore from "axe-core";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import AxeAnalysis = AxeCore.AxeResults;
    import Result = AxeCore.Result;
    import NodeResult = AxeCore.NodeResult;
    import CheckResult = AxeCore.CheckResult;
    export type ResultFilterFunction = (result: Result) => boolean;
    export type LoggingFunction = (message: string) => void;
    export type GetAuthenticationTokenFunction = () => Promise<string>;
    export { AxeAnalysis, Result, NodeResult, CheckResult };
    export interface Options {
        stepName?: any;
        friendlyElementName?: string;
        overrideElementToInclude?: string;
        disableRuleIds?: string[];
        violationFilters?: any;
        verboseLogging?: boolean;
        overrideLoggingFunction?: any;
        reportTestResult?: any;
        getAuthenticationToken?: any;
    }
    export function ensureAccessibilityIsAxeCoreClean(element: PortalElement, options?: Options): Promise<AxeAnalysis>;
}

declare module '@microsoft/azureportal-test/IPortalElementRetryOptions' {
    /**
        * options used for retrying a portal element.
        */
    export default interface IPortalElementRetryOptions {
            /**
                * the remaining number of times to retry.
                */
            remainingAttempts: number;
            /**
                * the amount of time to wait bewteen attempts
                */
            delay: number;
            /**
                * Script event click first
                */
            scriptClick?: boolean;
    }
}

declare module '@microsoft/azureportal-test/Dashboard/DashboardHeader' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import CommandBar from "@microsoft/azureportal-test/Controls/CommandBar";
    import DashboardPicker from "@microsoft/azureportal-test/Dashboard/DashboardPicker";
    import { CommandBarItem } from "@microsoft/azureportal-test/Commands";
    export default class DashboardHeader extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Waits until DashboardHeader is ready.
                */
            waitUntilReady(): Promise<DashboardHeader>;
            /**
                * Starts new Dashboard.
                */
            startNewDashboard(): Promise<void>;
            /**
                * Deletes the Dashboard.
                */
            deleteDashboard(): Promise<void>;
            /**
                * Changes the Dashboard title.
                */
            changeDashboardTitle(title: string): Promise<void>;
            /**
                * Clicks share dashboard command.
                */
            shareDashboard(): Promise<void>;
            /**
                * Clicks the unshare dashboard command.
                */
            unshareDashboard(): Promise<void>;
            /**
                * Clicks edit dashboard command.
                */
            editDashboard(): Promise<void>;
            /**
                * Gets the DashboardPicker.
                */
            getDashboardPicker(timeout?: number): Promise<DashboardPicker>;
            /**
                * Clone the Dashboard.
                */
            cloneDashboard(): Promise<void>;
            /**
                * Wait till dashboard command bar is ready.
                *
                * @returns Promise which resolves to return command bar when ready.
                */
            waitTillDashboardCommandBarReady(): Promise<CommandBar>;
            /**
                * Download dashboard.
                *
                * @returns Promise which resolves when dashboard download done.
                */
            downloadDashboard(): Promise<void>;
            /**
                * Get upload dashboard button.
                *
                * @returns Promise which resolves to upload dashboard button.
                */
            uploadDashboardBtn(): Promise<CommandBarItem>;
    }
}

declare module '@microsoft/azureportal-test/Dashboard/DashboardFilters' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import DashboardFilterPill from "@microsoft/azureportal-test/Dashboard/DashboardFilterPill";
    import AddPillButton from "@microsoft/azureportal-test/AddPillButton";
    /**
        * Represents a Pill List Item.
        */
    export default class DashboardFilters extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the dashboard's filter pills.
                */
            pills(): Promise<DashboardFilterPill[]>;
            /**
                * True if any pill is in edit mode.
                */
            isInEditMode(): Promise<boolean>;
            /**
                * Waits until the widget is ready.
                */
            waitUntilReady(): Promise<DashboardFilters>;
            /**
                * Waits until the widget is ready and its pills are read only.
                */
            waitUntilReadyAndPillsAreReadOnly(): Promise<DashboardFilters>;
            /**
                * Gets the dashboard's filter pill that is currently being edited.
                */
            activePill(): Promise<DashboardFilterPill>;
            /**
                * Get's the dashboard's filters add button.
                */
            addButton(): Promise<AddPillButton>;
            /**
                * Adds a dashboard filter pill. The pill will immediately enter edit mode.
                */
            addFilterPill(): Promise<DashboardFilterPill>;
            /**
                * Exits the dashboard filter's edit mode.
                */
            exitEditMode(): Promise<void>;
            /**
                * Deletes the supplied pill from the pill collection.
                *
                * @param index The index of the pill to be removed.
                * @returns True if the pill was successfully deleted.
                */
            deletePillAt(index: number): Promise<boolean>;
            /**
                * Checks the expected pills are present on dashboard or not.
                *
                * @param expectedCount the expected pill count to be verified.
                * @param waitForPillsReady  waits for the pills to appear.
                */
            checkPills(expectedCount: number, waitForPillsReady?: boolean): Promise<void>;
            /**
                * Selects colors filter from the dropdown.
                *
                * @param filterBy the filter to apply.
                */
            addFilter(filterBy: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Dashboard/DashboardPicker' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    export default class DashboardPicker extends PortalElement {
            /**
                * @returns A Locator instance for the dashboard picker.
                */
            get locator(): Locator;
            /**
                * @returns A promise that resolves to true when the element is displayed, false otherwise.
                */
            waitUntilReady(): Promise<DashboardPicker>;
            /**
                * @returns the dashboards list.
                */
            get dashboards(): ElementArrayFinder<PortalElement<any>, never>;
            /**
                * Opens the DashboardPicker.
                */
            open(): Promise<void>;
            /**
                * Closes the DashboardPicker.
                */
            close(): Promise<void>;
            /**
                * @returns The current dashboard name.
                */
            displayTitle(): Promise<string>;
            /**
                * Selects the dashboard.
                *
                * @param dashboardName The dashboard name.
                */
            pickDashboard(dashboardName: string): Promise<void>;
            /**
                * Selects the Browse all dashboards.
                */
            browseAll(): Promise<void>;
            /**
                * Verifies the current dashboard by name.
                *
                * @param expectedDashboardName The expected dashboard name.
                */
            verifyCurrentDashboardName(expectedDashboardName: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Dashboard/DashboardSharePane' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import ContextPane from "@microsoft/azureportal-test/ContextPane/ContextPane";
    import { CheckBoxField, GroupDropDownField, ResourceGroupDropDownField, SimpleButton, TextField } from "@microsoft/azureportal-test/Controls";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { StringMap } from "@microsoft/azureportal-test/Utils/UriBuilder";
    export default class DashboardSharePane extends ContextPane {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Waits until DashboardSharePane is ready.
                */
            waitUntilReady(): Promise<DashboardSharePane>;
            /**
                * Returns the body container of the share/unshare pane.
                */
            bodyContainer(): Promise<PortalElement<any>>;
            /**
                * Returns subscription dropdown field.
                */
            subscriptionDropDown(): Promise<GroupDropDownField>;
            /**
                * Returns resourceGroup dropdown field.
                */
            resourceGroupDropDown(): Promise<ResourceGroupDropDownField>;
            /**
                * Returns default resourceGroup checkbox field.
                */
            resourceGroupCheckBox(): Promise<CheckBoxField>;
            /**
                * Returns the publish/unpublish action button.
                */
            actionButton(): Promise<SimpleButton>;
            /**
                * Returns dashboard name text field.
                */
            dashboardNameTextBox(): Promise<TextField>;
            /**
                * Adds tags in share dashboard pane.
                *
                * @param tags The string map of tag names and tag values.
                */
            addTags(tags: StringMap<string>): Promise<void>;
            /**
                * Removes tags from share dashboard pane.
                *
                * @param tags The string map of tag names and tag values.
                */
            removeTags(tags: StringMap<string>): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Dashboard/DashboardPinPane' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { CheckBoxField, GroupDropDownField, ResourceGroupDropDownField, SimpleButton, TextField } from "@microsoft/azureportal-test/Controls";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import TabListItem from "@microsoft/azureportal-test/Controls/TabListItem";
    export default class DashboardPinPane extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Waits until DashboardPinPane is ready.
                */
            waitUntilReady(): Promise<DashboardPinPane>;
            /**
                * Returns the body container of the pin pane.
                */
            bodyContainer(): Promise<PortalElement<any>>;
            /**
                * Opens createNew tab and clicks Shared radio button.
                */
            createNewShared(): Promise<void>;
            /**
                * Returns subscription dropdown field.
                */
            subscriptionDropDown(): Promise<GroupDropDownField>;
            /**
                * Returns resourceGroup dropdown field.
                */
            resourceGroupDropDown(): Promise<ResourceGroupDropDownField>;
            /**
                * Returns default resourceGroup checkbox field.
                */
            resourceGroupCheckBox(): Promise<CheckBoxField>;
            /**
                * Returns dashboard name text field.
                */
            dashboardNameTextBox(): TextField;
            /**
                * Returns the "Create and pin" button.
                */
            getPinCreateNewButton(): Promise<SimpleButton>;
            /**
                * Gets the "Pin" button in existing tab.
                */
            getPinButton(): Promise<SimpleButton>;
            /**
                * Pins the selected dashboard.
                */
            pin(): Promise<void>;
            /**
                * Gets the create new tab.
                */
            createNewTab(): Promise<TabListItem>;
    }
}

declare module '@microsoft/azureportal-test/Dashboard/DashboardFilterPill' {
    import Pill from "@microsoft/azureportal-test/Controls/Pill";
    import GroupDropDownField from "@microsoft/azureportal-test/Controls/GroupDropDownField";
    /**
        * Represents a dashboard filter pill.
        */
    export default class DashboardFilterPill extends Pill {
            readonly filterIdDropdownClass = "ext-startboard-filter-id";
            readonly filterValueDropdownClass = "ext-startboard-filter-value";
            readonly filterOperatorDropdownClass = "ext-startboard-filter-operation";
            /**
                * Represents the filter id dropdown when the pill is in edit mode.
                */
            filterIdDropdown(): Promise<GroupDropDownField>;
            /**
                * Represents the filter value dropdown when the pill is in edit mode.
                */
            filterValueDropdown(): Promise<GroupDropDownField>;
            /**
                * Represents the filter operation dropdown when the pill is in edit mode.
                */
            filterOperationDropdown(): Promise<GroupDropDownField>;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/CreateActionBarCheckBoxField' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import CreateActionBarFormElement from "@microsoft/azureportal-test/ActionBars/CreateActionBarFormElement";
    /**
        * Represents a Checkbox field in the create action bar.
        */
    export default class CreateActionBarCheckBoxField extends CreateActionBarFormElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
            /**
                * Clicks the checkbox.
                *
                * @returns A promise that resolves when the checkbox has been clicked.
                */
            click(): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/ActionBars/CreateActionBarFormElement' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a CreateActionBarFormElement.
        */
    export default class CreateActionBarFormElement extends PortalElement {
            protected labelSelector: string;
            /**
                * The FormElement label.
                */
            label: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
            /**
                * Builds a FormElement locator using the specified options.
                *
                * @param options The options used to build the locator.
                * @returns A Locator instance.
                */
            buildLocator(options: {
                    label?: string;
            }): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/MessageBox' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        *  Represents a Message Box.
        */
    export default class MessageBox extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns {Locator} A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the message box title.
                */
            getTitle(): Promise<string>;
            /**
                * Clicks the message box button with the specified command text.
                *
                * @param buttonText The text of the message box button to click.
                */
            clickButton(buttonText: string): Promise<void>;
    }
}

declare module '@microsoft/azureportal-test/Blades/BrowseResourceColumnPickerBlade' {
    import * as Controls from "@microsoft/azureportal-test/Controls";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a Blade used to choose columns to show in browse resources
        */
    export default class BrowseResourceColumnPickerBlade extends Blade {
            /**
                * The grid that contains all columns that can be selected
                */
            sourceGrid: Controls.EditableGrid;
            columnGrid: Controls.EditableGrid;
            /**
                * Waits until the columns grid has rows then selects each column contained within columnsToSelect then clicks
                * the update action
                *
                * @param {Array<string>} columnsToSelect is the list of columns to click on
                * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
                * @returns A promise that resolves with this blade instance after the changes.
                */
            updateSelectedColumns(columnsToSelect: string[], timeout?: number): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Waits until the columns grid has rows then adds each column contained within columnsToAdd then clicks
                * the apply button
                *
                * @param {Array<string>} columnsToAdd is the list of columns to add to the selected columns
                * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
                * @returns A promise that resolves with this blade instance after the changes.
                */
            addColumns(columnsToAdd: string[], timeout?: number): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Waits until the columns grid has rows then removes each column contained within columnsToRemove then clicks
                * the apply button
                *
                * @param {Array<string>} columnsToRemove is the list of columns to add to the selected columns
                * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
                * @returns A promise that resolves with this blade instance after the changes.
                */
            removeColumns(columnsToRemove: string[], timeout?: number): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Waits until the columns grid has rows then sets each column contained within columnsToSelect then clicks
                * the apply button
                *
                * @param {Array<string>} columnsToSelect is the list of columns to be the selected columns
                * @param {number} [timeout] is an optional timeout to wait for the grid to have rows
                * @returns A promise that resolves with this blade instance after the changes.
                */
            setColumns(columnsToSelect: string[], timeout?: number): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Clicks the apply button on the blade.
                *
                * @returns A promise that resolves with this blade instance when apply button has been clicked.
                */
            apply(): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Clicks the reset button on the blade.
                *
                * @returns A promise that resolves with this blade instance when reset button has been clicked.
                */
            reset(): Promise<BrowseResourceColumnPickerBlade>;
            /**
                * Gets the apply button on the blade (button or action bar button).
                *
                * @returns A promise that resolves with the apply button.
                */
            applyButton(): Promise<PortalElement>;
            /**
                * Gets the reset button on the blade (button or action bar button).
                *
                * @returns A promise that resolves with the reset button.
                */
            resetButton(): Promise<PortalElement>;
            /**
                * Gets the add column button on the blade.
                *
                * @returns A promise that resolves with the add column button.
                */
            addButton(): Promise<PortalElement>;
            /**
                * Gets the remove column button on the blade.
                *
                * @returns A promise that resolves with the remove column button.
                */
            removeButton(): Promise<PortalElement>;
    }
}

declare module '@microsoft/azureportal-test/Controls/GridBase' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import IPortalElementRetryOptions from "@microsoft/azureportal-test/IPortalElementRetryOptions";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import * as GridCommon from "@microsoft/azureportal-test/Controls/GridCommonBase";
    /**
        * Represents a Grid column sort direction.
        */
    export import SortDirection = GridCommon.SortDirection;
    /**
        * Represents a Grid column header.
        */
    export abstract class BaseColumnHeader extends GridCommon.BaseColumnHeader {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
    /**
        * Represents a Grid cell.
        */
    export abstract class BaseCell extends GridCommon.BaseCell {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Invokes the click function of the cell which clicks the cell content.
                *
                * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
                * @returns A promise that resolves when the invoked function resolves.
                */
            click(retryOptions?: IPortalElementRetryOptions): Promise<void>;
    }
    /**
        * Represents a Grid row.
        */
    export abstract class BaseRow<TCell extends BaseCell> extends GridCommon.BaseRow<TCell> {
            /**
                * Constructs a base grid row.
                *
                * @param createCell Cell constructor.
                * @param elementArrayFinder Element array finder.
                */
            constructor(createCell: new () => TCell, elementArrayFinder?: ElementArrayFinder<BaseRow<TCell>>);
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Invokes the click function of the row which clicks the first visible cell.
                *
                * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
                * @returns A promise that resolves when the invoked function resolves.
                */
            click(retryOptions?: IPortalElementRetryOptions): Promise<void>;
            /**
                * Invokes the click function of the row which clicks the specified cell.
                *
                * @param cellIndex The index of the cell to click.
                * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
                * @returns A promise that resolves when the invoked function resolves.
                */
            clickCell(cellIndex: number, retryOptions?: IPortalElementRetryOptions): Promise<void>;
            /**
                * Determines if the row has been activated.
                *
                * @returns A promise that resolves when the activation state is found.
                */
            isActivated(): Promise<boolean>;
            /**
                * Determines if the row has been selected.
                *
                * @returns A promise that resolves when the selected state is found.
                */
            isSelected(): Promise<boolean>;
            /**
                * Gets a value indicating if this grid row is disabled.
                *
                * @returns A promise that resolves when the selected state is found.
                */
            isDisabled(): Promise<boolean>;
    }
    /**
        * Class to represent a Grid view port.
        */
    export class View extends GridCommon.BaseView {
            /**
                * Gets the locator associated to this element.
                */
            get locator(): Locator;
    }
    /**
        * Generic Grid test harness that that works against Grid1 and Grid2 grids.
        */
    export abstract class BaseGrid<TRow extends BaseRow<TCell>, TCell extends BaseCell, TColumnHeader extends BaseColumnHeader> extends GridCommon.BaseGrid<TRow, TCell, TColumnHeader, View> {
            /**
                * Constructs a base grid.
                *
                * @param createRow Constructs a Row.
                * @param createCell Constructs a Cell.
                * @param createColumnHeader Constructs a ColumnHeader.
                * @param elementArrayFinder Element array finder.
                */
            constructor(createRow: new () => TRow, createCell: new () => TCell, createColumnHeader: new () => TColumnHeader, elementArrayFinder?: ElementArrayFinder<BaseGrid<TRow, TCell, TColumnHeader>>);
            /**
                * The text box used to filter grid results.  If you want to set the text value, you can use searchBoxInput instead.
                * Does not apply to Grid2 (DataGrid/EditableGrid).
                */
            searchBox: PortalElement<any>;
            /**
                * The input text box used to filter grid results.  Use this if you want to set the text value without having to find the input element manually.
                * Does not apply to Grid2 (DataGrid/EditableGrid).
                */
            searchBoxInput: PortalElement<any>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Filters the grid rows using the specified text.
                * Does not apply to Grid2 (DataGrid/EditableGrid).
                *
                * @param {string} text The filter.
                * @returns A promise that resolves with this grid instance when filtered rows are available.
                */
            filter(text: string): Promise<BaseGrid<TRow, TCell, TColumnHeader>>;
            /**
                * If multi-select is enabled, the row that contains the specified text will be selected.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @param {boolean} useControlClick If true, holds down the control key while clicking. If false, performs a regular click.
                * @returns A promise that resolves when the row has been selected.
                */
            selectRow(options: {
                    text: string;
                    partialMatch?: boolean;
            }, useControlClick?: boolean): Promise<void>;
            /**
                * Checks if the row with specified text exists in the Grid.
                *
                * @param {string} rowText The text that the row should contain.
                * @param {number} cellIndex The cell index that contains the specified text.
                * @returns True, if the row with specified text is present; false, otherwise.
                */
            isRowPresent(rowText: string, cellIndex: number): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/MenuBlade/MenuBladeItem' {
    import ListViewItem from "@microsoft/azureportal-test/Controls/List/ListViewItem";
    /**
        * Represents a Menu Blade menu item.
        */
    export default interface MenuBladeItem {
            getText: () => Promise<string>;
            click: () => Promise<void>;
            isSelected(): Promise<boolean>;
    }
    /**
        * Represents an item in the Menu Grid.
        */
    export class MenuGridItem extends ListViewItem implements MenuBladeItem {
    }
    /**
        * Represents overview menu item.
        */
    export class OverviewMenuItem extends MenuGridItem {
    }
}

declare module '@microsoft/azureportal-test/Blades/CompositionBlade' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import CommandBar from "@microsoft/azureportal-test/Controls/CommandBar";
    import CommandBarItem from "@microsoft/azureportal-test/Commands/CommandBarItem";
    import Tile from "@microsoft/azureportal-test/Parts/Tile";
    import Lens from "@microsoft/azureportal-test/Lens";
    import DetailBladeContent from "@microsoft/azureportal-test/Blades/DetailBladeContent";
    import HeaderBladeContent from "@microsoft/azureportal-test/Blades/HeaderBladeContent";
    import DetailBlade from "@microsoft/azureportal-test/Controls/MenuBlade/DetailBlade";
    import { Part } from "@microsoft/azureportal-test/Parts";
    /**
        * Represents a Composition Blade.
        */
    export default class CompositionBlade extends Blade {
            /**
                * Gets the blade status bar.
                */
            get statusBar(): PortalElement<any> | Promise<PortalElement<any>>;
            /**
                * Gets the blade command bar.
                */
            get commandBar(): Promise<CommandBar>;
            /**
                * @deprecated detailBlade is deprecated. Use detailBladeContent property instead.
                */
            detailBlade: DetailBlade;
            /**
                * Gets DetailBladeContent.
                */
            detailBladeContent(): Promise<DetailBladeContent>;
            /**
                * Gets HeaderBladeContent.
                */
            headerBladeContent(): Promise<HeaderBladeContent>;
            /**
                * Gets the blade's commandbar buttons.
                */
            commandBarItemsAsync(): Promise<CommandBarItem[]>;
            /**
                * Gets the parts in the opened detail blade.
                */
            getDetailTiles(): Promise<Tile[]>;
            /**
                * Gets the lenses in the opened detail blade.
                */
            getDetailLenses(): Promise<Lens[]>;
            /**
                * Gets items of specified type from the detail blade.
                */
            getDetailBladeItems<T extends PortalElement>(elementType: {
                    new (): T;
            }): Promise<T>;
            /**
                * Gets items of specified type from the detail blade.
                */
            getDetailBladeItemsAsync<T extends PortalElement>(elementType: {
                    new (): T;
            }): Promise<T>;
            /**
                * Gets all the items of specified type from the detail blade.
                */
            getAllDetailBladeItems<T extends PortalElement>(elementType: {
                    new (): T;
            }): Promise<ElementArrayFinder<T>>;
            get title(): PortalElement;
            get subtitle(): PortalElement;
            get commandBarItems(): ElementArrayFinder<CommandBarItem>;
            /**
                * Gets the parts in the opened detail blade.
                */
            getDetailParts(): Promise<Part[]>;
    }
}

declare module '@microsoft/azureportal-test/Controls/MenuBlade/TabMenuBladeItem' {
    import TabListItem from "@microsoft/azureportal-test/Controls/TabListItem";
    /**
        * Represents a Tab Menu Blade menu item.
        */
    export default interface TabMenuBladeItem {
            getText: () => Promise<string>;
            click: () => Promise<void>;
            isSelected(): Promise<boolean>;
    }
    /**
        * Represents an item in the Menu Grid.
        */
    export class TabMenuItem extends TabListItem implements TabMenuBladeItem {
    }
}

declare module '@microsoft/azureportal-test/Controls/TabMenu' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import { Locator } from "@microsoft/azureportal-test/Locators";
    import TabMenuBladeItem from "@microsoft/azureportal-test/Controls/MenuBlade/TabMenuBladeItem";
    import { TabMenuItem } from "@microsoft/azureportal-test/Controls/MenuBlade/TabMenuBladeItem";
    export default class TabMenu extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the collection of menu items.
                *
                * @returns an array of menu items.
                */
            getTabMenuItems(): Promise<TabMenuItem[]>;
            /**
                * Gets the specified menu item.
                *
                * @param title The title of the menu item.
                * @param comparer The method used to compare menu items to text, the default behavior is to check whether the menu item text string contains the title string.
                * @returns The menu item.
                */
            getTabMenuItem(title: string, comparer?: (menuBladeItem: TabMenuItem, value: string) => Promise<boolean>): Promise<TabMenuBladeItem>;
    }
}

declare module '@microsoft/azureportal-test/Blades/ResourceSummary' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a resource summary element.
        */
    export default class ResourceSummary extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a value indicating whether this resource summary is collapsed.
                *
                * @returns a promise that resolves with a value that indicates whether the element is collapsed or not.
                */
            isCollapsed(): Promise<boolean>;
            /**
                * Toggles the resource summary.
                */
            toggle(): Promise<void>;
            /**
                * Checks if the resource summary is loaded.
                *
                * @returns a promise that resolves with a value that indicates whether the element is loading or not.
                */
            isLoading(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/Grid2Base' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import IPortalElementRetryOptions from "@microsoft/azureportal-test/IPortalElementRetryOptions";
    import * as GridCommon from "@microsoft/azureportal-test/Controls/GridCommonBase";
    import Toolbar from "@microsoft/azureportal-test/Controls/Toolbars/Toolbar";
    /**
        * Represents a Grid2 column sort direction.
        */
    export import SortDirection = GridCommon.SortDirection;
    /**
        * Base class representing a Grid2 column header.
        */
    export abstract class BaseColumnHeader extends GridCommon.BaseColumnHeader {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            canSort(): Promise<boolean>;
            sortDirection(): Promise<SortDirection>;
    }
    /**
        * Base class representing a Grid2 cell.
        */
    export abstract class BaseCell extends GridCommon.BaseCell {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Invokes the click function of the cell which clicks the cell content.
                *
                * @param retryOptions Optional set of retry options (eg attempts and delays between attempts).  Defaults to 3 retries with a 500ms delay
                * @returns A promise that resolves when the invoked function resolves.
                */
            click(retryOptions?: IPortalElementRetryOptions): Promise<void>;
    }
    /**
        * Base class to represent a Grid2 row.
        */
    export abstract class BaseRow<TCell extends BaseCell> extends GridCommon.BaseRow<TCell> {
            /**
                * Constructs a base grid row.
                *
                * @param createCell Cell constructor.
                * @param elementArrayFinder Element array finder.
                */
            constructor(createCell: new () => TCell, elementArrayFinder?: ElementArrayFinder<BaseRow<TCell>>);
            /**
                * Gets the locator associated to this element.
                */
            get locator(): Locator;
            /**
                * Gets the row footer.
                */
            get footer(): PortalElement;
            /**
                * Gets the context menu in the row.
                *
                * @returns The first context menu.
                */
            get contextMenuToolbar(): Toolbar;
    }
    /**
        * Class to represent a Grid2 view port.
        */
    export class View extends GridCommon.BaseView {
            /**
                * Gets the locator associated to this element.
                */
            get locator(): Locator;
    }
    /**
        * Base class that represents a Grid2 grid.
        */
    export abstract class BaseGrid<TRow extends BaseRow<TCell>, TCell extends BaseCell, TColumnHeader extends BaseColumnHeader> extends GridCommon.BaseGrid<TRow, TCell, TColumnHeader, View> {
            /**
                * Constructs a base grid.
                *
                * @param createRow Constructs a Row.
                * @param createCell Constructs a Cell.
                * @param createColumnHeader Constructs a ColumnHeader.
                * @param elementArrayFinder Element array finder.
                */
            constructor(createRow: new () => TRow, createCell: new () => TCell, createColumnHeader: new () => TColumnHeader, elementArrayFinder?: ElementArrayFinder<BaseGrid<TRow, TCell, TColumnHeader>>);
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a collection of group rows in the grid.
                */
            getGroupRows(): Promise<TRow[]>;
            /**
                * If multi-select is enabled, the row that contains the specified text will be selected.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @returns A promise that resolves when the row has been selected.
                */
            selectRow(options: {
                    text: string;
                    partialMatch?: boolean;
            }): Promise<void>;
            /**
                * Checks if the row with specified text exists in the Grid.
                *
                * @param rowText The text that the row should contain.
                * @param cellIndex The cell index that contains the specified text.
                * @returns True, if the row with specified text is present; false, otherwise.
                */
            isRowPresent(rowText: string, cellIndex: number): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/SideBarBrowseFlyoutFilterInput' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents the sidebar browse flyout filter input.
        */
    export default class SideBarBrowseFlyoutFilterInput extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/CommandBarMenuButton' {
    import CommandBarItem from "@microsoft/azureportal-test/Commands/CommandBarItem";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import CommandBarMenuPopup from "@microsoft/azureportal-test/Controls/CommandBarMenuPopup";
    import CommandBarMenuItem from "@microsoft/azureportal-test/Commands/CommandBarMenuItem";
    /**
        * Driver class for the toolbar menu button in toolbar portal control.
        */
    export default class CommandBarMenuButton extends CommandBarItem {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets the collection of toolbar menu items.
                */
            getItems(): Promise<CommandBarMenuItem[]>;
            /**
                * Finds the toolbar menu item with the specified command label.
                *
                * @param {string} commandLabel Text of the command to click.
                */
            findCommandBarMenuItem(commandLabel: string): Promise<CommandBarMenuItem>;
            /**
                * Returns the menu popup container for the menu button.
                */
            getMenuPopup(): Promise<CommandBarMenuPopup>;
    }
}

declare module '@microsoft/azureportal-test/Search/SearchCategory' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    /**
        * Represents a search category.
        */
    export default class SearchCategory extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/AddPillButton' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents the add pill button on a pill collection.
        */
    export default class AddPillButton extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                *  Waits until the pill is ready.
                */
            waitUntilReady(): Promise<AddPillButton>;
    }
}

declare module '@microsoft/azureportal-test/Controls/TabListItem' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    /**
        * Represents a tab list item.
        */
    export default class TabListItem extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
            /**
                * Gets a value indicating whether or not this element is selected.
                */
            isSelected(): Promise<boolean>;
    }
}

declare module '@microsoft/azureportal-test/Controls/GridCommonBase' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import ElementArrayFinder from "@microsoft/azureportal-test/ElementArrayFinder";
    import Toolbar from "@microsoft/azureportal-test/Controls/Toolbars/Toolbar";
    /**
        * Represents a grid column sort direction.
        */
    export enum SortDirection {
            /**
                * Data is sorted in ascending order.
                */
            Ascending = 1,
            /**
                * Data is sorted in descending order.
                */
            Descending = -1,
            /**
                * Data is not sorted.
                */
            Unsorted = 0
    }
    /**
        * Base class representing a grid column header.
        */
    export abstract class BaseColumnHeader extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            abstract get locator(): Locator;
            /**
                * Gets the text of the header.
                */
            getText(): Promise<string>;
    }
    /**
        * Base class representing a grid cell.
        */
    export abstract class BaseCell extends PortalElement {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            abstract get locator(): Locator;
            /**
                * Gets the text of the cell.
                */
            getText(): Promise<string>;
    }
    /**
        * Base class to represent a grid row.
        */
    export abstract class BaseRow<TCell extends BaseCell> extends PortalElement {
            /**
                * Constructs a base grid row.
                *
                * @param createCell Cell constructor.
                * @param elementArrayFinder Element array finder.
                */
            constructor(createCell: new () => TCell, elementArrayFinder?: ElementArrayFinder<BaseRow<TCell>>);
            /**
                * The collection of cells.
                */
            get cells(): ElementArrayFinder<TCell>;
            /**
                * Gets the locator associated to this element.
                */
            abstract get locator(): Locator;
            /**
                * Gets a value indicating whether or not this element is selected.
                */
            isSelected(): Promise<boolean>;
            /**
                * Gets the first context menu in the row
                *
                * @returns The first context menu.
                */
            getContextMenuToolbar(): Toolbar;
            /**
                * Gets a value indicating if this grid row is disabled.
                *
                * @returns A promise that resolves when the selected state is found.
                */
            isDisabled(): Promise<boolean>;
    }
    /**
        * Base class to represent a scrollable view port.
        */
    export abstract class BaseView extends PortalElement {
            /**
                * Constructs a base grid row.
                *
                * @param elementArrayFinder Element array finder.
                */
            constructor(elementArrayFinder?: ElementArrayFinder<BaseView>);
            /**
                * Gets the locator associated to this element.
                */
            abstract get locator(): Locator;
            /**
                * Gets the vertical scroll position.
                */
            getScrollTop(): Promise<number>;
            /**
                * Sets the vertical scroll position.
                */
            setScrollTop(value: number): Promise<any>;
            /**
                * Gets the horizontal scroll position.
                */
            getScrollLeft(): Promise<number>;
            /**
                * Sets the horizontal scroll position.
                */
            setScrollLeft(value: number): Promise<any>;
            /**
                * Gets the total scroll height.
                */
            getScrollHeight(): Promise<number>;
            /**
                * Gets the viewport height.
                */
            getHeight(): Promise<number>;
            /**
                * Gets the total scroll width.
                */
            getScrollWidth(): Promise<number>;
            /**
                * Gets the viewport width.
                */
            getWidth(): Promise<number>;
            /**
                * Indicates if the view can be scrolled horizontally.
                */
            hasHorizontalScrollbar(): Promise<boolean>;
            /**
                * Indicates if the view can be scrolled vertically.
                */
            hasVerticalScrollbar(): Promise<boolean>;
            /**
                * Scrolls the view to the top.
                */
            scrollToTop(): Promise<any>;
            /**
                * Scrolls the view to the bottom.
                */
            scrollToBottom(): Promise<any>;
            /**
                * Scrolls the view to the bottom.
                */
            scrollToLeft(): Promise<any>;
            /**
                * Scrolls the view to the bottom.
                */
            scrollToRight(): Promise<any>;
    }
    /**
        * Base class that represents a grid.
        */
    export abstract class BaseGrid<TRow extends BaseRow<TCell>, TCell extends BaseCell, TColumnHeader extends BaseColumnHeader, TView extends BaseView> extends PortalElement {
            /**
                * Constructs a base grid.
                *
                * @param createRow Constructs a Row.
                * @param createCell Constructs a Cell.
                * @param createColumnHeader Constructs a ColumnHeader.
                * @param createView Constructs a View.
                * @param elementArrayFinder Element array finder.
                */
            constructor(createRow: new () => TRow, createCell: new () => TCell, createColumnHeader: new () => TColumnHeader, createView: new () => TView, elementArrayFinder?: ElementArrayFinder<BaseGrid<TRow, TCell, TColumnHeader, TView>>);
            /**
                * Gets a collection of rows in the grid.
                */
            get rows(): ElementArrayFinder<TRow>;
            /**
                * Gets a collection of column headers in the grid.
                */
            get columnHeaders(): ElementArrayFinder<TColumnHeader>;
            /**
                * Gets a collection of all the cells in the grid.
                */
            get cells(): ElementArrayFinder<TCell>;
            /**
                * Gets grid view port.
                */
            get view(): TView;
            /**
                * Gets the total row count for the grid.
                */
            getTotalRowCount(): Promise<number>;
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            abstract get locator(): Locator;
            /**
                * Clicks the row that contains the specified text.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @returns A promise that resolves when the row has been clicked.
                */
            clickRow(options: {
                    text: string;
                    cellIndex?: number;
                    partialMatch?: boolean;
            }): Promise<void>;
            /**
                * If multi-select is enabled, the row that contains the specified text will be selected.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @returns A promise that resolves when the row has been selected.
                */
            abstract selectRow(options: {
                    text: string;
                    partialMatch?: boolean;
            }): Promise<void>;
            /**
                * If multi-select is enabled, all the rows that contains the specified text will be selected.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @returns A promise that resolves when all the rows has been selected.
                */
            selectRows(options: {
                    texts: string[];
                    partialMatch?: boolean;
            }): Promise<any[]>;
            /**
                * Performs a right click on the row that contains the specified text.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @returns A promise that resolves when the row has been right clicked.
                */
            rightClickRow(options: {
                    text: string;
                    cellIndex?: number;
                    partialMatch?: boolean;
            }): Promise<void>;
            /**
                * Finds a row that contains the specified text.
                *
                * @param options The set of options used to find the row.
                * @param {string} options.text The text that the row should contain.
                * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @param {number} [timeout] optional timeout to wait for the row to be present
                * @returns A promise that resolves with the found row.
                */
            findRow(options: {
                    text: string;
                    cellIndex?: number;
                    partialMatch?: boolean;
                    caseInsensitive?: boolean;
            }, timeout?: number): Promise<TRow>;
            /**
                * Finds a cell that contains the specified text.
                *
                * @param options The set of options used to find the cell.
                * @param {string} options.text The text that the cell should contain.
                * @param {number} options.cellIndex The optional index of the cell where the text should be searched.
                * @param {boolean} options.partialMatch Optionally searches for the text using partial matching.
                * @param {number} [timeout] optional timeout to wait for the cell to be present
                * @returns A promise that resolves with the found cell.
                */
            findCell(options: {
                    text: string;
                    cellIndex?: number;
                    partialMatch?: boolean;
            }, timeout?: number): Promise<TCell>;
            /**
                * Returns a value that indicates whether the grid has rows.
                *
                * @returns A promise that resolves with a value that indicates whether the grid has rows.
                */
            hasRows(): Promise<boolean>;
            /**
                * Waits for columns of grid to load.
                *
                * @param {string[]} expectedColumns The texts of expected columns headers in order.
                */
            waitForColumns(expectedColumns: string[]): Promise<void>;
            /**
                * Waits for columnsSets..
                *
                * @param {string[][]} columnSets The string array of expected columns headers in order.
                */
            waitForColumnSet(columnSets: string[][]): Promise<number>;
            /**
                * Gets the grid caption.
                */
            getCaption(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Blades/HeaderBladeContent' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import { PartContainer } from "@microsoft/azureportal-test/Parts/PartContainer";
    /**
        * Represents the header content (Top Content) of the blade.
        */
    export default class HeaderBladeContent extends PartContainer {
            /**
                * Gets the locator associated to this element.
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

declare module '@microsoft/azureportal-test/Controls/MenuBlade/DetailBlade' {
    import Blade from "@microsoft/azureportal-test/Blades/Blade";
    /**
      * DetailBlade will be deprecated in near future, use DetailBladeContent instead.
      * Represents the content of a Menu Blade.
      */
    export default class DetailBlade extends Blade {
        protected bladeClass: string;
    }
}

declare module '@microsoft/azureportal-test/Controls/CommandBarMenuPopup' {
    import PortalElement from "@microsoft/azureportal-test/PortalElement";
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    export default class CommandBarMenuPopup extends PortalElement {
        get locator(): Locator;
        /**
          * Unique popup id associated with menu button.
          */
        getId(): Promise<string>;
    }
}

declare module '@microsoft/azureportal-test/Commands/CommandBarMenuItem' {
    import Locator from "@microsoft/azureportal-test/Locators/Locator";
    import CommandBarItem from "@microsoft/azureportal-test/Commands/CommandBarItem";
    /**
        * Driver class for the toolbar menu item in toolbar portal control.
        */
    export default class CommandBarMenuItem extends CommandBarItem {
            /**
                * Gets the By locator used to identify elements of this class
                *
                * @returns A Locator instance.
                */
            get locator(): Locator;
    }
}

