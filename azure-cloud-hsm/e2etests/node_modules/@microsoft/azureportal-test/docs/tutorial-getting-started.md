<!-- markdownlint-disable MD041 REASON: File assembled with GitDown -->

### Installation

{"gitdown": "include", "file": "./prereq.md"}

1. Open a command prompt and create a directory for your test files.

md e2etests

1. Switch to the new directory and install the @microsoft/azureportal-test module via npm:

cd e2etests
npm install @microsoft/azureportal-test --omit=optional

1. The @microsoft/azureportal-test module comes with some TypeScript definitions and its dependencies. To make them available to your tests, we recommend that you use the [typings](https://www.npmjs.com/package/typings) Typescript Definition Manager.

1. First install the [typings](https://www.npmjs.com/package/typings) Typescript Definition Manager globally:

npm install typings -g

Next copy the provided **typings.json** file and the **microsoft-azureportal-test.d.ts** file from the **node_modules/@microsoft/azureportal-test/typescript** folder to your test root directory and use _typings_ to install the provided definitions:

_copy typings.json to your test root directory_
_navigate to your test root directory_
typings install

1. @microsoft/azureportal-test needs a WebDriver server in order to be able to drive the browser. Currently only [ChromeDriver](https://sites.google.com/a/chromium.org/chromedriver) is supported, so downloaded it and place it in your machine's PATH or just install it from the [chromedriver Node module](https://www.npmjs.com/package/chromedriver). You may also need a C++ compiler (Visual Studio includes one):

npm install chromedriver

### Write a test

You'll need an existing cloud service for the test you'll write below, so if you don't have one please go to the Azure Portal and [create a new cloud service](https://ms.portal.azure.com/#create/Microsoft.CloudService). Write down the dns name of your cloud service to use it in your test.

We'll use the [Mocha](https://mochajs.org/) testing framework to layout the following test, but you could use any framework that supports Node.js modules and promises. Let's install Mocha and its typescript definitions:

npm install mocha
npm install @types/mocha

Now, create a **portaltests.ts** file in your e2etests directory and paste the following:

```ts
/// <reference path="./typings/index.d.ts" />

import * as testFx from "@microsoft/azureportal-test";
import WindowsCM = testFx.Utils.WindowsCredentialManager;
import until = testFx.until;
import assert = testFx.Utils.Assert;

describe("Cloud Service Tests", function () {
  this.timeout(0);

  it("Can Browse To A Cloud Service", async () => {
    testFx.portal.portalContext.signInEmail = "johndoe@outlook.com";
    testFx.portal.portalContext.signInPassword = WindowsCM.getWindowsCredentialSync(
      "microsoft-azureportal-test/johndoe@outlook.com/signInPassword"
    );

    // Update this variable to use the dns name of your actual cloud service
    const dnsName = "mycloudservice";

    let blade = await testFx.portal.openBrowseBlade(
      "microsoft.classicCompute",
      "domainNames",
      "Cloud services (classic)"
    );
    blade = await blade.filterItems(dnsName);
    const row = await testFx.portal.wait<testFx.Controls.GridRow>(
      async () => {
        const count = await blade.grid.rows.count();
        return count === 1 ? blade.grid.rows.first() : null;
      },
      null,
      "Expected only one row matching '" + dnsName + "'."
    );
    await row.click();
    const summaryBlade = testFx.portal.blade({ title: dnsName + " - Production" });
    await assert.ok(until.isPresent(summaryBlade));
    await testFx.portal.quit();
  });
});
```

1. write credentials to the windows credential manager

```sh
    cmdkey /generic:microsoft-azureportal-test/johndoe@outlook.com/signInPassword /user:johndoe@outlook.com /pass:somePassword
```

Remember to replace "mycloudservice" with the dns name of your actual cloud service.

In this test we start by importing the **@microsoft/azureportal-test** module. Then the credentials are specified for the user that will sign in to the Portal. These should be the credentials of a user that already has an active Azure subscription.

After that we can use the Portal object to drive a test scenario that opens the Cloud Services Browse blade, filters the list of cloud services, checks that the grid has only one row after the filter, selects the only row and waits for the correct blade to open. Finally, the call to quit() closes the browser.

### Add the configuration

Create a file named **config.json** next to portaltests.ts. Paste this in the file:

```json
{
  "capabilities": {
    "browserName": "chrome"
  },
  "portalUrl": "https://portal.azure.com"
}
```

This configuration tells @microsoft/azureportal-test that Google Chrome should be used for the test session when using Selenium automation and [https://portal.azure.com](https://portal.azure.com) should be the Portal under test.

### Playwright automation

Besides Selenium WebDriver, @microsoft/azureportal-test framework now supports [Playwright](https://playwright.dev/) test automation library. We recommend using Playwright over Selenium as it is faster and more reliable. Note that you may encounter bugs or unexpected behavior while using Playwright as we are still working on improving the stability. Also, @microsoft/azureportal-test framework fully supports accessibility testing under Playwright. So, whether you are only starting to write your tests or you want to migrate from Selenium to Playwright, here are the steps to start using Playwright:

1. Set `playwright` parameter in `config.json`:

   ```json
   "playwright": {
       "browser": "chrome",
       "resolution": {
           "width": 1280,
           "height": 960
       },
       "options": {
           "headless": false
       }
   }
   ```

   To see all the available options that can be passed to Playwright, see [Playwright browser launch documentation](https://playwright.dev/docs/api/class-browsertype#browser-type-launch).

1. There are two ways to make tests run using Playwright:

   - By default, test framework uses Selenium automation. To enable Playwright, set `browserAutomation` parameter to `playwright` in `config.json`:

   ```json
   "browserAutomation": "playwright"
   ```

   It's also possible to explicitly set `browserAutomation` to `webdriver` to make sure your tests run using Selenium.

   - In your test code, set `testFx.PortalConfigurationManager.default.portalContext.browserAutomation` in one of the clauses that runs before a test case (i.e. `before`, `beforeAll`, `beforeEach`):

   ```ts
   before(() => {
     testFx.PortalConfigurationManager.default.portalContext.browserAutomation =
       testFx.BrowserAutomationType.Playwright;
   });
   ```

   It is recommended to use the first method unless you have some tests that are consistently failing using Playwright automation. When using the second method, note that the automation will be set only for that test file. That means that if you are running several test files in one go (i.e. via `.mocharc` or using `grep`), when `portal` class is being initialized at the beginning of each test file execution, it will set automation to either what is set as `browserAutomation` in `config.json` or will default to Selenium. Also, if you have several test suites/cases in one test file, using the second method will set the automation for the rest of the test cases in all test suites after it.

1. If you are using `testFx.portal.getDriver()` and `testFx.portal.hasDriver()`, replace them with `testFx.portal.getBrowser()` and `testFx.portal.hasBrowser()` respectively, e.g.:

   ```ts
   const activeElement = await testFx.portal.getBrowser().getActiveElement();
   ```

1. If you are using xpath locator queries that start with `.//` prefix, replace that prefix with `testFx.Locators.By.currentNodeXPathPrefix()`:

   ```ts
   const listViewGallery = testFx.portal.element(
     testFx.Locators.By.xpath(
       `${testFx.Locators.By.currentNodeXPathPrefix()}div[contains(@class, 'fxc-listView-gallery')]`
     )
   );
   ```

1. If you are using Selenium specific functions, use `testFx.BrowserAutomation.runAutomation()` (or `testFx.BrowserAutomation.runAutomationSync()` for synchronous functions) and create Playwright version of that functionality. Those functions expect callbacks for each automation, and pass automation classes which are optional to use:

   ```ts
   const dropDownArrow = testFx.portal.element(testFx.Locators.By.className(dropDownArrowClass));
   await testFx.BrowserAutomation.runAutomation(
     async (wd) =>
       await wd.executeScript(
         "$(arguments[0]).trigger('mousedown').trigger('mouseup').trigger('click');",
         dropDownArrow
       ),
     async () => await dropDownArrow.click()
   );
   ```

1. If you are using `testFx.portal.executeScript()` or `testFx.portal.executeAsyncScript()`, you might have to adjust that script and use `testFx.BrowserAutomation.runAutomation()` to distinct two versions of the script.

   - Remove `return` in Playwright versions of scripts:

   ```ts
   const result: string = await testFx.BrowserAutomation.runAutomation<string>(
     async (wd) => await wd.executeScript("return JSON.stringify(FxImpl.getAssetTypeMappingData());"),
     async (pw) => await pw.executeScript("JSON.stringify(FxImpl.getAssetTypeMappingData())")
   );
   ```

   - If script is running on an element, you'd have to run `executeScript` of that element in the Playwright version:

   ```ts
   const journeyBlade = testFx.portal.element(testFx.Locators.By.className(journeyBladeClass));
   const result: string = await testFx.BrowserAutomation.runAutomation<string>(
     async (wd) => await wd.executeScript("return $.contains(arguments[0], document.activeElement)", journeyBlade),
     async () =>
       await (<testFx.PlaywrightElement>(await journeyBlade.getWebElements())[0]).executeScript(
         "(htmlElem) => $.contains(htmlElem, document.activeElement)"
       )
   );
   ```

   Notice the format of the Playwright version of the script. It's a function with `htmlElem` parameter passed to it, and that parameter is used as the element in the script.

1. If you encounter error `Error opening Portal: Error: browserType.launch: Executable doesn't exist at`, please run `npx playwright install` **after** installing your test project dependencies.

### Compile and run

Compile your TypeScript test file (note if you are using a newer version of TSC than 1.8 then you may need to pass in additional flags that aren't present in older versions of TSC):

(TSC 1.8) tsc portaltests.ts --module commonjs
(TSC 3+) tsc portaltests.ts --module commonjs --lib ES2021 --moduleResolution classic

...and then run Mocha against the generated JavaScript file (note using an elevated command prompt may cause Chrome to crash. Use a non-elevated command prompt for best results):

node_modules\.bin\mocha portaltests.js

The following output will be sent to your console as the test progresses:

Portal Tests
Opening the Browse blade for the microsoft.classicCompute/domainNames resource type...
Starting the ChromeDriver process...
Performing SignIn...
Waiting for the Portal...
Waiting for the splash screen to go away...
Applying filter 'mycloudservice'...
√ Can Browse To A Cloud Service (37822ms)

1 passing (38s)

If you run into a compilation error with node.d.ts, verify that the tsc version you are using matches the compilation command above. You can check the version by running:

```sh
tsc --version
```

If the version is incorrect, then you may need to adjust your path variables or directly call the correct version of tsc.exe. A version of tsc is usually included in the node_modules folder at node_modules/.bin/tsc that can be used.

If you see errors regarding duplicate identifiers due to some definitions being imported twice, you can try setting [moduleResolution compiler option](https://www.typescriptlang.org/docs/handbook/compiler-options.htm) to classic in your tsconfig.json file.

### Updating

1. In order to keep up to date with the latest changes, we recommend that you update whenever a new version of @microsoft/azureportal-test is released. npm install will automatically pull the latest version of @microsoft/azureportal-test.

   > Make sure to copy typescript definition files in your _typings\* folder from the updated version in_\node_modules\@microsoft\azureportal-test\typescript\*.

### More Examples

More examples can be found

- within this document
- in the `test` folder [here](https://aka.ms/portalfx/microsoft-azureportal-test/src)
- and the [Contacts Extension Tests](http://vstfrd:8080/Azure/One/_git/AzureUX-PortalFx#path=%2Fsrc%2FSDK%2FAcceptanceTests%2FExtensions%2FContactsExtension%2FTests).

If you don't have access, please follow the enlistment instructions below.

### Running tests in Visual Studio

1. Install [Node Tools for Visual Studio](https://www.visualstudio.com/en-us/features/node-js-vs.aspx) (Note that we recommend using the Node.js “LTS” versions rather than the “Stable” versions since sometimes NTVS doesn’t work with newer Node.js versions.)

1. Once that’s done, you should be able to open Visual Studio and then create new project: _New -> Project -> Installed, Templates, TypeScript, Node.js -> From Existing Node.js code_.

![NewTypeScriptNodeJsExistingProject][NewTypeScriptNodeJsExistingProject]

1. Then open the properties on your typescript file and set the TestFramework property to “mocha”.

![FileSetTestFrameworkPropertyMocha][FileSetTestFrameworkPropertyMocha]

1. Once that is done you should be able to build and then see your test in the test explorer. If you don’t see your tests, then make sure you don’t have any build errors. You can also try restarting Visual Studio to see if that makes them show up.

[FileSetTestFrameworkPropertyMocha]: /docs/media/microsoft-azureportal-test/FileSetTestFrameworkPropertyMocha.png
[NewTypeScriptNodeJsExistingProject]: /docs/media/microsoft-azureportal-test/NewTypeScriptNodeJsExistingProject.png
