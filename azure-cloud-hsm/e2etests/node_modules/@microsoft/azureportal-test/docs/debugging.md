<!-- markdownlint-disable MD041 REASON: File assembled with GitDown -->

### debug tests 101

### debugging tests in VS Code

If you run mocha with the --debug-brk flag, you can press F5 and the project will attach to a debugger.

### Checking the result of the currently running test in code

Sometimes it is useful to get the result of the currently running test, for example: you want to take a screenshot only when the test fails.

```ts
{"gitdown": "include-section", "file": "../test/PortalTests.ts", "section": "debugging#takeScreenshot"}
```

One thing to watch out for in typescript is how lambda functions, "() => {}", behave. Lambda functions (also called "fat arrow" sometimes) in Typescript capture the "this" variable from the surrounding context. This can cause problems when trying to access Mocha's current test state. See [arrow functions](https://basarat.gitbooks.io/typescript/content/docs/arrow-functions.html) for details.

### How to take a screenshot of the browser

This is an example of how to take a screenshot of what is currently displayed in the browser.

```ts
//1. import test fx
import * as testFx from '@microsoft/azureportal-test';
...
    var screenshotPromise = testFx.portal.takeScreenshot(ScreenshotTitleHere);
```

Taking a screenshot when there is a test failure is a handy way to help diagnose issues. If you are using the mocha test runner, then you can do the following to take a screenshot whenever a test fails:

```ts
import * as testFx from '@microsoft/azureportal-test';
...
{"gitdown": "include-section", "file": "../test/PortalTests.ts", "section": "debugging#takeScreenshot"}
```

### How to capture browser console output

When trying to identify reasons for failure of a test its useful to capture the console logs of the browser that was used to execute your test. You can capture the logs at a given level e.g error, warning, etc or at all levels using the LogLevel parameter. The following example demonstrates how to call getBrowserLogs and how to work with the result. getBrowserLogs will return a Promise of string[] which when resolved will contain the array of logs that you can view during debug or write to the test console for later analysis.

```ts
import * as testFx from '@microsoft/azureportal-test';
...
{"gitdown": "include-section", "file": "../test/PortalTests.ts", "section": "debugging#getBrowserLogs"}
```

### Node 18 upgrade

Update your development environments and any CI/CD pipelines that make use of node to use the v18 LTS >= 18.18.2 or later - <https://nodejs.org/en/download/>

As part of upgrading to Node 18, you may want to update your package.json file's type dependencies:

```json
"dependencies": {
    "@types/node": "^18.18.2",
}
```

If you are seeing error `done() called multiple times in test`, this may be due to Node 16 which has started surfacing errors thrown by async calls (previously in Node 12 they were hidden). Try verifying the following in your code:

- Call `await` on functions/properties that return a promise type.
  - eg: `switchDashboard(destinationDashboardTitle);` should be `await switchDashboard(destinationDashboardTitle);`
- Don't call `await` on functions/properties that do not return a promise type.
  - Check the return type of any function/properties you call.
  - The `PortalElement` type is not a promise. Do not `await` on it.
- You can use [es-lint](https://eslint.org/) rules such as [await-thenable](https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/await-thenable.md) and [no-floating-promises](https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-floating-promises.md) to help (note they are not perfect).
- Check the Common Issues section below as well.

If you are seeing errors when running `npm test` or other npm commands related to the path not being parsed properly, please note that npm has changed how it parses paths. Try removing any escape characters and use double backslashes `\\` instead of a forward slash `/`.

### Common Issues

- The `PortalElement.element()` function (ie `portal.element()`, `blade.element()`, etc) does not verify if an item is present or visible. You must call `await element.isPresent()` or `await element.isDisplayed()` to check.
- Before interacting with a blade or view that was just opened (IE from a click() on something else), ensure that it is present and loaded.

  - eg:

    ```ts
    const allResourcesBlade = testFx.portal.blade({ bladeType: testFx.Blades.AllResourcesBlade });
    await portal.waitForElementPresent(allResourcesBlade);
    ```

    or

    ```ts
    browseRecentResourcesBlade = testFx.portal.view({
      title: BrowseClientResources.assetTypeNames.recentResource.plural,
      viewType: testFx.Views.ReactView,
    });
    await testFx.portal.waitForElementPresent(browseRecentResourcesBlade);
    ```

- `blade.waitUntilLoaded()` and related methods have been updated to automatically check `isPresent()` as well.
- Before interacting with a control that just appeared, ensure that it is present and loaded via `await control.isPresent()` . Note that `isPresent` returns a `boolean` whether the control is present or not. It does NOT automatically wait until the control is loaded. You can wrap it in a `portal.wait()` to wait for it to be present (and any other conditions you may require).

  - eg:

    ```ts
    await testFx.portal.wait(
      async () => await dialogEditor.isPresent(),
      null,
      "There should be a popup dialog of class " + dialogBalloonClass
    );
    ```
