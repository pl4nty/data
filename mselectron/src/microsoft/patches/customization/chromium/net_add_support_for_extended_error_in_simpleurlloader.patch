From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: deepak1556 <hop2deep@gmail.com>
Date: Tue, 11 Nov 2025 02:38:53 +0900
Subject: add support for extended error in SimpleURLLoader

It is possible to additional context to a net::Error code
via network::URLCompletionStatus, currently this is used
to populate context for the generic net::ERR_HTTP2_PROTOCOL_ERROR.

For https://github.com/microsoft/vscode-internalbacklog/issues/5985

Patch will be upstreamed.

diff --git a/net/BUILD.gn b/net/BUILD.gn
index 6975ed49b24ce965fd74043cb292dce3e8821ea2..f143f823e8b50b8459be77de002eb0d18b5e79be 100644
--- a/net/BUILD.gn
+++ b/net/BUILD.gn
@@ -241,6 +241,7 @@ component("net") {
     "base/mime_sniffer.h",
     "base/mime_util.cc",
     "base/mime_util.h",
+    "base/net_error_details.cc",
     "base/net_error_details.h",
     "base/net_error_list.h",
     "base/net_errors.cc",
diff --git a/net/base/net_error_details.cc b/net/base/net_error_details.cc
new file mode 100644
index 0000000000000000000000000000000000000000..a8c2cb119fcdd49483dfec94b20791b5139196e2
--- /dev/null
+++ b/net/base/net_error_details.cc
@@ -0,0 +1,22 @@
+// Copyright 2015 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/base/net_error_details.h"
+
+namespace net {
+  NetErrorDetails::NetErrorDetails()
+      : quic_broken(false),
+        quic_connection_error(quic::QUIC_NO_ERROR) {}
+
+  NetErrorDetails::NetErrorDetails(
+      bool quic_broken,
+      quic::QuicErrorCode quic_connection_error)
+      : quic_broken(quic_broken),
+        quic_connection_error(quic_connection_error) {}
+
+  NetErrorDetails::NetErrorDetails(const NetErrorDetails& other) = default;
+  NetErrorDetails& NetErrorDetails::operator=(const NetErrorDetails&) = default;
+  NetErrorDetails::NetErrorDetails(NetErrorDetails&&) = default;
+  NetErrorDetails& NetErrorDetails::operator=(NetErrorDetails&&) = default;
+}  // namespace net
\ No newline at end of file
diff --git a/net/base/net_error_details.h b/net/base/net_error_details.h
index 295f1def19000a827ace91d90fe6e0aad44fbf7f..28888c27de335a46e083df3a47bbaf6021cf89f9 100644
--- a/net/base/net_error_details.h
+++ b/net/base/net_error_details.h
@@ -15,12 +15,14 @@ namespace net {
 // A record of net errors with granular error specification generated by
 // net stack.
 struct NET_EXPORT NetErrorDetails {
-  NetErrorDetails()
-      : quic_broken(false), quic_connection_error(quic::QUIC_NO_ERROR) {}
+  NetErrorDetails();
 
-  NetErrorDetails(bool quic_broken, quic::QuicErrorCode quic_connection_error)
-      : quic_broken(quic_broken),
-        quic_connection_error(quic_connection_error) {}
+  NetErrorDetails(bool quic_broken, quic::QuicErrorCode quic_connection_error);
+
+  NetErrorDetails(const NetErrorDetails& other);
+  NetErrorDetails& operator=(const NetErrorDetails&);
+  NetErrorDetails(NetErrorDetails&&);
+  NetErrorDetails& operator=(NetErrorDetails&&);
 
   // True if all QUIC alternative services are marked broken for the origin.
   bool quic_broken;
@@ -37,6 +39,7 @@ struct NET_EXPORT NetErrorDetails {
   bool quic_port_migration_detected = false;
   bool quic_connection_migration_attempted = false;
   bool quic_connection_migration_successful = false;
+  std::string spdy_protocol_error_details;
 };
 
 }  // namespace net
diff --git a/net/spdy/spdy_http_stream.cc b/net/spdy/spdy_http_stream.cc
index 54677771aeb2104ce96551222964ccb61d912ae9..3bb6e4efba0b7814934f2aca7dd77a2f78eb61da 100644
--- a/net/spdy/spdy_http_stream.cc
+++ b/net/spdy/spdy_http_stream.cc
@@ -579,6 +579,10 @@ int SpdyHttpStream::GetRemoteEndpoint(IPEndPoint* endpoint) {
 
 void SpdyHttpStream::PopulateNetErrorDetails(NetErrorDetails* details) {
   details->connection_info = HttpConnectionInfo::kHTTP2;
+  if (spdy_session_) {
+    details->spdy_protocol_error_details =
+        spdy_session_->spdy_protocol_error_details();
+  }
   return;
 }
 
diff --git a/net/spdy/spdy_session.cc b/net/spdy/spdy_session.cc
index a03733471abeddfe54d4e20a965d51083f9975e9..de62dde5984b6ad9950465a371df1957bcadd999 100644
--- a/net/spdy/spdy_session.cc
+++ b/net/spdy/spdy_session.cc
@@ -1838,6 +1838,8 @@ void SpdySession::ResetStreamIterator(ActiveStreamMap::iterator it,
   }
   spdy::SpdyStreamId stream_id = it->first;
   RequestPriority priority = it->second->priority();
+  rst_stream_error_ = static_cast<net::Error>(error);
+  rst_stream_description_ = description;
   EnqueueResetStreamFrame(stream_id, priority, error_code, description);
 
   // Removes any pending writes for the stream except for possibly an
diff --git a/net/spdy/spdy_session.h b/net/spdy/spdy_session.h
index 7e1adc583e9d656f668eda47583abc1d89ce14f5..018da9983841acb7f813e8daa25815e5b53f8412 100644
--- a/net/spdy/spdy_session.h
+++ b/net/spdy/spdy_session.h
@@ -617,6 +617,22 @@ class NET_EXPORT SpdySession
     return spdy_session_initiator_;
   }
 
+  std::string spdy_protocol_error_details() const {
+    if (drain_error_.has_value() && *drain_error_ == ERR_HTTP2_PROTOCOL_ERROR) {
+      return drain_description_;
+    }
+    if (go_away_error_.has_value() &&
+        *go_away_error_ != spdy::ERROR_CODE_HTTP_1_1_REQUIRED &&
+        *go_away_error_ != spdy::ERROR_CODE_NO_ERROR) {
+      return go_away_debug_data_;
+    }
+    if (rst_stream_error_.has_value() &&
+        *rst_stream_error_ == ERR_HTTP2_PROTOCOL_ERROR) {
+      return rst_stream_description_;
+    }
+    return "UNKNOWN";
+  }
+
  private:
   friend class test::SpdyStreamTest;
   friend class base::RefCounted<SpdySession>;
@@ -1302,6 +1318,8 @@ class NET_EXPORT SpdySession
   std::string drain_description_;
   std::optional<spdy::SpdyErrorCode> go_away_error_;
   std::string go_away_debug_data_;
+  std::optional<Error> rst_stream_error_;
+  std::string rst_stream_description_;
   spdy::SpdyStreamId last_good_stream_id_ = 0;
 
   // Represents how this session is created.
diff --git a/services/network/public/cpp/simple_url_loader.cc b/services/network/public/cpp/simple_url_loader.cc
index bfb83e26e2d83371acceacf0c615fcdebe42d21d..b1ea8fc0a59c4c8be5c9ae55127614134ae222e2 100644
--- a/services/network/public/cpp/simple_url_loader.cc
+++ b/services/network/public/cpp/simple_url_loader.cc
@@ -295,6 +295,7 @@ class SimpleURLLoaderImpl : public SimpleURLLoader,
   void SetTimeoutDuration(base::TimeDelta timeout_duration) override;
 
   int NetError() const override;
+  std::string NetExtendedError() const override;
   const mojom::URLResponseHead* ResponseInfo() const override;
   mojom::URLResponseHeadPtr TakeResponseInfo() override;
   const std::optional<URLLoaderCompletionStatus>& CompletionStatus()
@@ -348,6 +349,7 @@ class SimpleURLLoaderImpl : public SimpleURLLoader,
 
     // Result of the request.
     int net_error = net::ERR_IO_PENDING;
+    std::string net_extended_error;
 
     bool loaded_from_cache = false;
 
@@ -1625,6 +1627,12 @@ int SimpleURLLoaderImpl::NetError() const {
   return request_state_->net_error;
 }
 
+std::string SimpleURLLoaderImpl::NetExtendedError() const {
+  // Should only be called once the request is complete.
+  DCHECK(request_state_->finished);
+  return request_state_->net_extended_error;
+}
+
 const GURL& SimpleURLLoaderImpl::GetFinalURL() const {
   // Should only be called once the request is complete.
   DCHECK(request_state_->finished);
@@ -1992,6 +2000,9 @@ void SimpleURLLoaderImpl::OnComplete(const URLLoaderCompletionStatus& status) {
   request_state_->completion_status = status;
   request_state_->request_completed = true;
   request_state_->net_error = status.error_code;
+  if (status.error_code == net::ERR_HTTP2_PROTOCOL_ERROR) {
+    request_state_->net_extended_error = status.spdy_protocol_extended_error;
+  }
   request_state_->loaded_from_cache = status.exists_in_cache;
   // If |status| indicates success, but the body pipe was never received, the
   // URLLoader is violating the API contract.
diff --git a/services/network/public/cpp/simple_url_loader.h b/services/network/public/cpp/simple_url_loader.h
index aadbe9721a29bebae48de834d2d776a9b6a37ba3..9bce3ffb57ff1cf58cf47e2e141bdfeb8afb6e2b 100644
--- a/services/network/public/cpp/simple_url_loader.h
+++ b/services/network/public/cpp/simple_url_loader.h
@@ -419,6 +419,11 @@ class COMPONENT_EXPORT(NETWORK_CPP) SimpleURLLoader {
   // only be called once the loader has informed the caller of completion.
   virtual int NetError() const = 0;
 
+  // Returns additional descriptive information for a net::Error representing
+  // the final status of the request. May only be called once the loader has
+  // informed the caller of completion.
+  virtual std::string NetExtendedError() const = 0;
+
   // The URLResponseHead for the request. Will be nullptr if ResponseInfo
   // was never received or if `TakeResponseInfo()` has been called. May only be
   // called once the loader has informed the caller of completion.
diff --git a/services/network/public/cpp/url_loader_completion_status.h b/services/network/public/cpp/url_loader_completion_status.h
index 0e92a19cb320bd6e92adfc978a8c1744bac2ad6a..cfc574b1011b460272f1ea48a90a30149a67e1b5 100644
--- a/services/network/public/cpp/url_loader_completion_status.h
+++ b/services/network/public/cpp/url_loader_completion_status.h
@@ -109,6 +109,9 @@ struct COMPONENT_EXPORT(NETWORK_CPP_BASE) URLLoaderCompletionStatus {
   // Whether the initiator of this request should be collapsed.
   bool should_collapse_initiator = false;
 
+  // Extra detail on HTTP2_PROTOCOL_ERROR.
+  std::string spdy_protocol_extended_error;
+
   // Write a representation of this struct into a trace.
   void WriteIntoTrace(perfetto::TracedValue context) const;
 };
diff --git a/services/network/url_loader.cc b/services/network/url_loader.cc
index 3d32e5d540deea75a453f603a2902c44a1b82287..2a5680d0d8f0893e2adb4e5a5284991fc1901f05 100644
--- a/services/network/url_loader.cc
+++ b/services/network/url_loader.cc
@@ -2000,6 +2000,11 @@ void URLLoader::NotifyCompleted(int error_code) {
       // The error code is only used internally, translate it into a CORS error.
       DCHECK(cors_error_status_.has_value());
       status.error_code = net::ERR_FAILED;
+    } else if (error_code == net::ERR_HTTP2_PROTOCOL_ERROR) {
+      net::NetErrorDetails details;
+      url_request_->PopulateNetErrorDetails(&details);
+      status.spdy_protocol_extended_error =
+          details.spdy_protocol_error_details;
     }
     status.exists_in_cache = url_request_->response_info().was_cached;
     status.completion_time = base::TimeTicks::Now();
